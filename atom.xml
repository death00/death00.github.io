<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>健程之道</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.death00.top/"/>
  <updated>2020-01-04T02:50:27.287Z</updated>
  <id>https://www.death00.top/</id>
  
  <author>
    <name>健健</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>力扣73——矩阵置零</title>
    <link href="https://www.death00.top/2019/12/20/%E5%8A%9B%E6%89%A373%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/"/>
    <id>https://www.death00.top/2019/12/20/力扣73——矩阵置零/</id>
    <published>2019-12-20T02:00:00.000Z</published>
    <updated>2020-01-04T02:50:27.287Z</updated>
    
    <content type="html"><![CDATA[<p>准备开一个力扣解题的系列，督促自己每天刷题，就从今天开始。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [1,1,1],</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [1,1,1]</span><br><span class="line">]</span><br><span class="line">输出: </span><br><span class="line">[</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [1,0,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [0,1,2,0],</span><br><span class="line">  [3,4,5,2],</span><br><span class="line">  [1,3,1,5]</span><br><span class="line">]</span><br><span class="line">输出: </span><br><span class="line">[</span><br><span class="line">  [0,0,0,0],</span><br><span class="line">  [0,4,5,0],</span><br><span class="line">  [0,3,1,0]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>进阶:</p><ul><li>一个直接的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。</li><li>一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。</li><li>你能想出一个常数空间的解决方案吗？</li></ul><p>原题url:<a href="https://leetcode-cn.com/problems/set-matrix-zeroes/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/set-matrix-zeroes/</a></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>其实题目本身不难，只要判断出哪些数字是0，将其所在行和列记录一下， 最终全部置0即可，关键在于你所需要消耗的空间是多少。</p><h3 id="用一个数字"><a href="#用一个数字" class="headerlink" title="用一个数字"></a>用一个数字</h3><p>首先我想到的是用一个数字进行表示，用二进制表示，一共<code>m + n</code>位，其中前<code>m</code>位表示行，后<code>n</code>位表示列，矩阵中哪个数字为0，则其行列所在位的数字为1，也就是加上相应的二进制数。为了不重复添加，可以用<code>&amp;</code>进行判断。来看看代码是什么：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 转化为二进制后，前m位表示列，后n位表示行</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 第j列是否已经被设置为0</span></span><br><span class="line">                <span class="keyword">int</span> num = <span class="number">1</span> &lt;&lt; (matrix.length + j);</span><br><span class="line">                <span class="keyword">if</span> ((temp &amp; num) != num) &#123;</span><br><span class="line">                    <span class="comment">// 如果没有，则加上</span></span><br><span class="line">                    temp += num;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 第i行是否已经被设置为0</span></span><br><span class="line">                num = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">                <span class="keyword">if</span> ((temp &amp; num) != num) &#123;</span><br><span class="line">                    <span class="comment">// 如果没有，则加上</span></span><br><span class="line">                    temp += num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[i].length; j++) &#123;</span><br><span class="line">                <span class="comment">// 第j列是否已经被设置为0</span></span><br><span class="line">                <span class="keyword">int</span> numCol = <span class="number">1</span> &lt;&lt; (matrix.length + j);</span><br><span class="line">                <span class="comment">// 第i行是否已经被设置为0</span></span><br><span class="line">                <span class="keyword">int</span> numRow = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">                <span class="keyword">if</span> ((temp &amp; numRow) == numRow || (temp &amp; numCol) == numCol) &#123;</span><br><span class="line">                    <span class="comment">// 如果有，则设置当前值为0</span></span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>理论上没什么问题，提交之后报错。当<code>m</code>和<code>n</code>很大时，数字会很大，这个时候<code>temp</code>会越界。我想着是不是求2的幂用<code>Math.pow()</code>，并且 temp 的类型改为 long ，是不是就可以了，说干就干：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 转化为二进制后，前m位表示列，后n位表示行</span></span><br><span class="line">        <span class="keyword">long</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 第j列是否已经被设置为0</span></span><br><span class="line">                <span class="keyword">long</span> num = (<span class="keyword">long</span>)Math.pow(<span class="number">2</span>, matrix.length + j);</span><br><span class="line">                <span class="keyword">if</span> ((temp &amp; num) != num) &#123;</span><br><span class="line">                    <span class="comment">// 如果没有，则加上</span></span><br><span class="line">                    temp += num;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 第i行是否已经被设置为0</span></span><br><span class="line">                num = (<span class="keyword">long</span>)Math.pow(<span class="number">2</span>, i);</span><br><span class="line">                <span class="keyword">if</span> ((temp &amp; num) != num) &#123;</span><br><span class="line">                    <span class="comment">// 如果没有，则加上</span></span><br><span class="line">                    temp += num;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[i].length; j++) &#123;</span><br><span class="line">                <span class="comment">// 第j列是否已经被设置为0</span></span><br><span class="line">                <span class="keyword">long</span> numCol = (<span class="keyword">long</span>)Math.pow(<span class="number">2</span>, matrix.length + j);</span><br><span class="line">                <span class="comment">// 第i行是否已经被设置为0</span></span><br><span class="line">                <span class="keyword">long</span> numRow = (<span class="keyword">long</span>)Math.pow(<span class="number">2</span>, i);</span><br><span class="line">                <span class="keyword">if</span> ((temp &amp; numRow) == numRow || (temp &amp; numCol) == numCol) &#123;</span><br><span class="line">                    <span class="comment">// 如果有，则设置当前值为0</span></span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好吧，依然不可以，看来确实很大，最终还是溢出变成负数了。看来得另寻他法了。</p><h3 id="利用矩阵本身"><a href="#利用矩阵本身" class="headerlink" title="利用矩阵本身"></a>利用矩阵本身</h3><p>如果1个数字不够，那么多来几个数字应该也是不够用的，而且如果用的太多也可能会增长到<code>m + n</code>，空间依旧比较多。这个时候我也想不出来，看了看别人的解法，让我顿时领悟——利用矩阵本身。</p><p>就是利用矩阵的第一行和第一列来记录需要置零的行和列，至于第一行和第一列是否需要置零，则可以单独拿两个 boolean 对象来表示。（怎么好的思路，为啥我就是没想到呢）来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用第一行和第一列表示当前行和当前列是否需要置0</span></span><br><span class="line">        <span class="comment">// 单独计算第一行和第一列是否需要置0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 第一行是否需要置0</span></span><br><span class="line">        <span class="keyword">boolean</span> row0 = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[<span class="number">0</span>][i] == <span class="number">0</span>) &#123;</span><br><span class="line">                row0 = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一列是否需要置0</span></span><br><span class="line">        <span class="keyword">boolean</span> col0 = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                col0 = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断每一行每一列是否需要置0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                matrix[i][<span class="number">0</span>] = matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 置0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一行是否需要都置0</span></span><br><span class="line">        <span class="keyword">if</span> (row0) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; col; i++) &#123;</span><br><span class="line">                matrix[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一列是否需要都置0</span></span><br><span class="line">        <span class="keyword">if</span> (col0) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>终于通过了，执行用时：<code>2ms</code>，内存消耗：<code>43.5MB</code>。那么是否可以继续优化呢？</p><h3 id="利用矩阵本身-优化"><a href="#利用矩阵本身-优化" class="headerlink" title="利用矩阵本身 优化"></a>利用矩阵本身 优化</h3><p>首先，需要第一行和第一列都判断一遍的吗？可以只判断其中一个即可，比如只判断第一列是否需要置零，那么第一行是否需要置零就可以依赖<code>matrix[0][0]</code>了。在置零的时候，也是将第一列单独判断即可。</p><p>需要注意的是，置零操作需要从后往前，因为<code>matrix[0][0]</code>会有双重含义，所以最后判断即可。来看看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一列是否需要置零</span></span><br><span class="line">        <span class="keyword">boolean</span> col0 = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否需要置零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果第一列不需要置零，并且第一列有数字是0，则col0设置为true</span></span><br><span class="line">            <span class="keyword">if</span> (!col0 &amp;&amp; matrix[i][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                col0 = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; col; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 置零，从后往前开始，因为如果从前往后，第一行如果因为第一列置为0，会对之后结果误导</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 第一列不动</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = col - <span class="number">1</span>; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第一列置零</span></span><br><span class="line">            <span class="keyword">if</span> (col0) &#123;</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。我准备把我刷力扣的过程记录下来，作为这个系列的内容，希望能和大家多多分享。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://jjcoder.top/" target="_blank" rel="noopener">https://jjcoder.top/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;准备开一个力扣解题的系列，督促自己每天刷题，就从今天开始。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>ThreadLocal的进化——TransmittableThreadLocal</title>
    <link href="https://www.death00.top/2019/12/15/ThreadLocal%E7%9A%84%E8%BF%9B%E5%8C%96%E2%80%94%E2%80%94TransmittableThreadLocal/"/>
    <id>https://www.death00.top/2019/12/15/ThreadLocal的进化——TransmittableThreadLocal/</id>
    <published>2019-12-15T02:00:00.000Z</published>
    <updated>2020-01-04T02:48:10.127Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章中，我们谈到了 InheritableThreadLocal，它解决了 ThreadLocal 针对父子线程无法共享<code>上下文</code>的问题。但我们可能听说过阿里的开源产品<code>TransmittableThreadLocal</code>，那么它又是做什么的呢？<br><a id="more"></a></p><h2 id="线程池中的共享"><a href="#线程池中的共享" class="headerlink" title="线程池中的共享"></a>线程池中的共享</h2><p>我们在多线程中，很少会直接 new 一个线程，更多的可能是利用线程池处理任务，那么利用 InheritableThreadLocal 可以将生成任务线程的上下文传递给执行任务的线程吗？废话不多说，直接上代码测试一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocalContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InheritableThreadLocal&lt;Context&gt; context = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 固定线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(</span><br><span class="line">                    () -&gt; &#123;</span><br><span class="line">                        <span class="comment">// 生成任务的线程对context进行赋值</span></span><br><span class="line">                        Context contextMain = <span class="keyword">new</span> Context();</span><br><span class="line">                        contextMain.name = String.format(<span class="string">"Thread%s name"</span>, finalI);</span><br><span class="line">                        contextMain.value = finalI * <span class="number">20</span>;</span><br><span class="line">                        InheritableThreadLocalContext.context.set(contextMain);</span><br><span class="line">                        <span class="comment">// 提交任务</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"Thread"</span> + finalI + <span class="string">" produce task "</span> + (finalI * <span class="number">20</span> + j));</span><br><span class="line">                            executorService.execute(() -&gt; &#123;</span><br><span class="line">                                <span class="comment">// 执行任务的子线程</span></span><br><span class="line">                                Context contextChild = InheritableThreadLocalContext.context.get();</span><br><span class="line">                                System.out.println(Thread.currentThread().getName() + <span class="string">" execute task, name : "</span> + contextChild.name + <span class="string">" value : "</span> + contextChild.value);</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">            ).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们希望的结果是，子线程输出的内容能够和父线程对应上。然而，实际的结果却出乎所料，我将结果整理一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Thread1 produce task 21</span><br><span class="line">// 省略8行</span><br><span class="line">Thread1 produce task 30</span><br><span class="line"></span><br><span class="line">Thread2 produce task 41</span><br><span class="line">// 省略8行</span><br><span class="line">Thread2 produce task 50</span><br><span class="line">pool-1-thread-1 execute task, name : Thread2 name value : 40</span><br><span class="line">// 省略47行</span><br><span class="line">pool-1-thread-1 execute task, name : Thread2 name value : 40</span><br><span class="line"></span><br><span class="line">Thread3 produce task 61</span><br><span class="line">// 省略8行</span><br><span class="line">Thread3 produce task 70</span><br><span class="line"></span><br><span class="line">Thread4 produce task 81</span><br><span class="line">// 省略8行</span><br><span class="line">Thread4 produce task 90</span><br><span class="line"></span><br><span class="line">Thread5 produce task 101</span><br><span class="line">// 省略8行</span><br><span class="line">Thread5 produce task 110</span><br><span class="line"></span><br><span class="line">Thread6 produce task 121</span><br><span class="line">// 省略8行</span><br><span class="line">Thread6 produce task 130</span><br><span class="line"></span><br><span class="line">Thread7 produce task 141</span><br><span class="line">// 省略8行</span><br><span class="line">Thread7 produce task 150</span><br><span class="line">pool-1-thread-2 execute task, name : Thread7 name value : 140</span><br><span class="line">// 省略6行</span><br><span class="line">pool-1-thread-2 execute task, name : Thread7 name value : 140</span><br><span class="line"></span><br><span class="line">Thread8 produce task 161</span><br><span class="line">// 省略8行</span><br><span class="line">Thread8 produce task 170</span><br><span class="line"></span><br><span class="line">Thread9 produce task 181</span><br><span class="line">// 省略8行</span><br><span class="line">Thread9 produce task 190</span><br><span class="line">pool-1-thread-4 execute task, name : Thread9 name value : 180</span><br><span class="line">pool-1-thread-4 execute task, name : Thread9 name value : 180</span><br><span class="line"></span><br><span class="line">Thread10 produce task 201</span><br><span class="line">// 省略8行</span><br><span class="line">Thread10 produce task 210</span><br><span class="line">pool-1-thread-3 execute task, name : Thread10 name value : 200</span><br><span class="line">// 省略39行</span><br><span class="line">pool-1-thread-3 execute task, name : Thread10 name value : 200</span><br></pre></td></tr></table></figure></p><p>虽然生产总数和消费总数都是100，但是明显有的消费多了，有的消费少了。合理推测一下，应该是在主线程放进任务后，子线程才生成。为了验证这个猜想，将线程池用 ThreadPoolExecutor 生成，并在用子线程生成任务之前，先赋值 context 并开启所有线程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 固定线程池</span></span><br><span class="line">    ThreadPoolExecutor executorService = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">4</span>,</span><br><span class="line">            <span class="number">4</span>,</span><br><span class="line">            <span class="number">0L</span>,</span><br><span class="line">            TimeUnit.MILLISECONDS,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;() );</span><br><span class="line">    <span class="comment">// 在main线程中赋值</span></span><br><span class="line">    Context context = <span class="keyword">new</span> Context();</span><br><span class="line">    context.name = <span class="string">"Thread0 name"</span>;</span><br><span class="line">    context.value = <span class="number">0</span>;</span><br><span class="line">    InheritableThreadLocalContext.context.set(context);</span><br><span class="line">    <span class="comment">// 开启所有线程</span></span><br><span class="line">    executorService.prestartAllCoreThreads();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> finalI = i;</span><br><span class="line">        <span class="keyword">new</span> Thread(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 生成任务的线程对context进行赋值</span></span><br><span class="line">                    Context contextMain = <span class="keyword">new</span> Context();</span><br><span class="line">                    contextMain.name = String.format(<span class="string">"Thread%s name"</span>, finalI);</span><br><span class="line">                    contextMain.value = finalI * <span class="number">20</span>;</span><br><span class="line">                    InheritableThreadLocalContext.context.set(contextMain);</span><br><span class="line">                    <span class="comment">// 提交任务</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"Thread"</span> + finalI + <span class="string">" produce task "</span> + (finalI * <span class="number">20</span> + j));</span><br><span class="line">                        executorService.execute(() -&gt; &#123;</span><br><span class="line">                            <span class="comment">// 执行任务的子线程</span></span><br><span class="line">                            Context contextChild = InheritableThreadLocalContext.context.get();</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">" execute task, name : "</span> + contextChild.name + <span class="string">" value : "</span> + contextChild.value);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">        ).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果不出所料，执行任务的线程输出的，都是最外面主线程设置的值。</p><p>那么我们该如何才能达到最初想要的效果呢？就是利用线程池执行任务时，如何能够让执行者线程能够获取调用者线程的 context 呢？</p><h2 id="使用-TransmittableThreadLocal-解决"><a href="#使用-TransmittableThreadLocal-解决" class="headerlink" title="使用 TransmittableThreadLocal 解决"></a>使用 TransmittableThreadLocal 解决</h2><p>上面的问题主要是因为执行任务的线程是被线程池管理，可以被复用（可以称为<code>池化复用</code>）。那复用了之后，如果还是依赖于父线程的 context，自然是有问题的，因为我们想要的效果是执行线程获取调用线程的 context，这时候就是<code>TransmittableThreadLocal</code>出场了。</p><p>TransmittableThreadLocal 是阿里提供的工具类，其主要解决的就是上面遇到的问题。那么该如何使用呢？</p><p>首先，你需要引入相应的依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;transmittable-thread-local&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.11.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>具体代码，就拿上文提到的情况，我们用 TransmittableThreadLocal 做一个改造：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransmittableThreadLocalTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TransmittableThreadLocal&lt;Context&gt; context = <span class="keyword">new</span> TransmittableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 固定线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> finalI = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(</span><br><span class="line">                    () -&gt; &#123;</span><br><span class="line">                        <span class="comment">// 生成任务的线程对context进行赋值</span></span><br><span class="line">                        Context contextMain = <span class="keyword">new</span> Context();</span><br><span class="line">                        contextMain.name = String.format(<span class="string">"Thread%s name"</span>, finalI);</span><br><span class="line">                        contextMain.value = finalI * <span class="number">20</span>;</span><br><span class="line">                        TransmittableThreadLocalTest.context.set(contextMain);</span><br><span class="line">                        <span class="comment">// 提交任务</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"Thread"</span> + finalI + <span class="string">" produce task "</span> + (finalI * <span class="number">20</span> + j));</span><br><span class="line">                            Runnable task = () -&gt; &#123;</span><br><span class="line">                                <span class="comment">// 执行任务的子线程</span></span><br><span class="line">                                Context contextChild = TransmittableThreadLocalTest.context.get();</span><br><span class="line">                                System.out.println(Thread.currentThread().getName() + <span class="string">" execute task, name : "</span> + contextChild.name + <span class="string">" value : "</span> + contextChild.value);</span><br><span class="line">                            &#125;;</span><br><span class="line">                            <span class="comment">// 额外的处理，生成修饰了的对象ttlRunnable</span></span><br><span class="line">                            Runnable ttlRunnable = TtlRunnable.get(task);</span><br><span class="line">                            executorService.execute(ttlRunnable);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">            ).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时再次运行，就会发现执行线程运行时的输出内容是完全可以和调用线程对应上的了。当然了，我这种方式是修改了 Runnable 的写法，阿里也提供了线程池的写法，简单如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 固定线程池</span></span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 额外的处理，生成修饰了的对象executorService</span></span><br><span class="line">    executorService = TtlExecutors.getTtlExecutorService(executorService);</span><br><span class="line">    ExecutorService finalExecutorService = executorService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> finalI = i;</span><br><span class="line">        <span class="keyword">new</span> Thread(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 生成任务的线程对context进行赋值</span></span><br><span class="line">                    Context contextMain = <span class="keyword">new</span> Context();</span><br><span class="line">                    contextMain.name = String.format(<span class="string">"Thread%s name"</span>, finalI);</span><br><span class="line">                    contextMain.value = finalI * <span class="number">20</span>;</span><br><span class="line">                    TransmittableThreadLocalTest.context.set(contextMain);</span><br><span class="line">                    <span class="comment">// 提交任务</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">10</span>; j++) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"Thread"</span> + finalI + <span class="string">" produce task "</span> + (finalI * <span class="number">20</span> + j));</span><br><span class="line">                        Runnable task = () -&gt; &#123;</span><br><span class="line">                            <span class="comment">// 执行任务的子线程</span></span><br><span class="line">                            Context contextChild = TransmittableThreadLocalTest.context.get();</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">" execute task, name : "</span> + contextChild.name + <span class="string">" value : "</span> + contextChild.value);</span><br><span class="line">                        &#125;;</span><br><span class="line">                        finalExecutorService.execute(task);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">        ).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实还有更加简单的写法，具体可以参考其github:<a href="https://github.com/alibaba/transmittable-thread-local" target="_blank" rel="noopener">https://github.com/alibaba/transmittable-thread-local</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实两篇 ThreadLocal 升级文章的出现，都是因为周三听了一个部门关于 TTL 的分享会，也是介绍了 TransmittableThreadLocal，但因为携程商旅面临国际化的改动，当前的语种信息肯定是存储在线程的 context 中最方便，但涉及到线程传递的问题（因为会调用异步接口等等），所以自然就需要考虑这个了。性能方面的话，他们有做过测试，但我也只是一个听者，并没有具体使用过，大家也可以一起交流。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://jjcoder.top/" target="_blank" rel="noopener">https://jjcoder.top/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章中，我们谈到了 InheritableThreadLocal，它解决了 ThreadLocal 针对父子线程无法共享&lt;code&gt;上下文&lt;/code&gt;的问题。但我们可能听说过阿里的开源产品&lt;code&gt;TransmittableThreadLocal&lt;/code&gt;，那么它又是做什么的呢？&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.death00.top/tags/Java/"/>
    
      <category term="ThreadLocal" scheme="https://www.death00.top/tags/ThreadLocal/"/>
    
      <category term="TransmittableThreadLocal" scheme="https://www.death00.top/tags/TransmittableThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal的进化——InheritableThreadLocal</title>
    <link href="https://www.death00.top/2019/12/13/ThreadLocal%E7%9A%84%E8%BF%9B%E5%8C%96%E2%80%94%E2%80%94InheritableThreadLocal/"/>
    <id>https://www.death00.top/2019/12/13/ThreadLocal的进化——InheritableThreadLocal/</id>
    <published>2019-12-13T02:00:00.000Z</published>
    <updated>2020-01-04T02:46:54.015Z</updated>
    
    <content type="html"><![CDATA[<p>之前有介绍过 ThreadLocal，JDK 后来针对此做了一个升级版本 InheritableThreadLocal，今天就来好好介绍下。<br><a id="more"></a></p><h2 id="为什么要升级"><a href="#为什么要升级" class="headerlink" title="为什么要升级"></a>为什么要升级</h2><p>首先我们来想想，为什么要升级？这就要说起 ThreadLocal 的功能了。</p><p>我们知道，ThreadLocal 设计初衷是为了在多线程环境下，针对每一个线程能有一个自己的副本，这样可以在一定程度上解决多线程并发修改的问题。但是，我们可以在此基础上做一个拓展，比如<code>context</code>，我们可以利用 ThreadLocal 针对每一个线程都有一个自己的上下文，一般都是写成<code>ThreadLocal&lt;Context&gt;</code>，这样在这个线程上做的所有修改都可以被大家利用到。</p><p>此时设想一下，假如我们新建一个子线程，那这个子线程可以获取到父线程的<code>context</code>吗？理论上希望可以达成这样的效果，实际上呢？让我们看看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Context&gt; context = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context();</span><br><span class="line">        context.name = <span class="string">"mainName"</span>;</span><br><span class="line">        context.value = <span class="number">10</span>;</span><br><span class="line">        ThreadLocalContext.context.set(context);</span><br><span class="line"></span><br><span class="line">        Thread childThread = <span class="keyword">new</span> Thread(</span><br><span class="line">                <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        Context childContext = ThreadLocalContext.context.get();</span><br><span class="line">                        System.out.println(childContext.name);</span><br><span class="line">                        System.out.println(childContext.value);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        childThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行 main 方法之后，直接在子线程中抛错，这样确实符合我们的预期，但如果我们想达到<code>子线程可以获取到父线程的 context</code>这样的效果该如何做呢？</p><p>首先想到的就是在生成子线程的时候，将父线程 ThreadLocal 里的值传给子线程。这样做虽然能达到效果，但过程比较繁杂，且代码侵入性强。</p><p>这个时候就可以用<code>InheritableThreadLocal</code>了。</p><h2 id="什么是-InheritableThreadLocal"><a href="#什么是-InheritableThreadLocal" class="headerlink" title="什么是 InheritableThreadLocal"></a>什么是 InheritableThreadLocal</h2><h3 id="看源码"><a href="#看源码" class="headerlink" title="看源码"></a>看源码</h3><p>先让我们看看它的源码，大家不要怕，它的源码很少：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先它继承自 ThreadLocal，那么它其实就是 ThreadLocal 的一个拓展版本，接下来就是这三个方法，其实这三个方法在 ThreadLocal 都是有的，我们来看看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除了<code>childValue</code>方法在 ThreadLocal 中是抛出异常的，其余两个方法在两个类中都几乎是一样，只是针对的对象不同而已，但<code>threadLocals</code>和<code>inheritableThreadLocals</code>都是<code>ThreadLocal.ThreadLocalMap</code>类型，这个在之前的文章中有说过，就是一个 key 为<code>弱引用</code>的 Entry，这个倒不是重点。</p><p>我们再来看看 inheritableThreadLocals 是在何时被初始化的，从源码可以得知：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">long</span> stackSize, AccessControlContext acc)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 省略无关代码</span></span><br><span class="line">            ...</span><br><span class="line">            Thread parent = currentThread();</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 省略无关代码</span></span><br><span class="line">            ...</span><br><span class="line">    <span class="keyword">if</span> (parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>当我们通过父线程调用 Thread 的构造方法生成一个子线程时，其构造方法最终会调用这个 init 方法。从这儿可以看出， inheritableThreadLocals 是来自于父线程的 inheritableThreadLocals，那这样也就解释了为什么 inheritableThreadLocals 支持在子线程中使用父线程中存储的变量。</p><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>让我们还是回到上文提到的 context 的例子，用 InheritableThreadLocal 进行改造：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InheritableThreadLocal&lt;Context&gt; context = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Context context = <span class="keyword">new</span> Context();</span><br><span class="line">        context.name = <span class="string">"mainName"</span>;</span><br><span class="line">        context.value = <span class="number">10</span>;</span><br><span class="line">        ThreadLocalContext.context.set(context);</span><br><span class="line"></span><br><span class="line">        Thread childThread = <span class="keyword">new</span> Thread(</span><br><span class="line">                <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        Context childContext = ThreadLocalContext.context.get();</span><br><span class="line">                        System.out.println(childContext.name);</span><br><span class="line">                        System.out.println(childContext.value);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        childThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行后，不仅没有抛出异常，而且在子线程中输出了父线程设置好的值。皆大欢喜！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天分享了 InheritableThreadLocal，主要是因为周三在携程的分享会上听到了别人谈了这方面的分享，主讲人讲了一个更加普遍的问题，如果我们用线程池提交任务的话，线程池中的线程在执行任务时，如何能够获得提交任务的线程的 context，这时就要用到阿里的开源组件 TTL，我会在之后进行介绍。</p><p>加入携程也有1个月了，虽然感受到大公司有不少的弊端，比如沟通难等，但也有不少的优点，比如技术分享会，虽然也是忙里偷闲去参加的，但有了更多和技术相关的可以学习和交流的机会，也挺好的。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://jjcoder.top/" target="_blank" rel="noopener">https://jjcoder.top/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前有介绍过 ThreadLocal，JDK 后来针对此做了一个升级版本 InheritableThreadLocal，今天就来好好介绍下。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.death00.top/tags/Java/"/>
    
      <category term="ThreadLocal" scheme="https://www.death00.top/tags/ThreadLocal/"/>
    
      <category term="InheritableThreadLocal" scheme="https://www.death00.top/tags/InheritableThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>Java——内部类详解</title>
    <link href="https://www.death00.top/2019/11/26/Java%E2%80%94%E2%80%94%E5%86%85%E9%83%A8%E7%B1%BB%E8%AF%A6%E8%A7%A3/"/>
    <id>https://www.death00.top/2019/11/26/Java——内部类详解/</id>
    <published>2019-11-26T02:00:00.000Z</published>
    <updated>2020-01-04T02:46:38.882Z</updated>
    
    <content type="html"><![CDATA[<p>说起内部类，大家肯定感觉熟悉又陌生，因为一定在很多框架源码中有看到别人使用过，但又感觉自己使用的比较少，今天我就带你具体来看看内部类。<br><a id="more"></a></p><h2 id="内部类基础"><a href="#内部类基础" class="headerlink" title="内部类基础"></a>内部类基础</h2><blockquote><p>所谓内部类就是在类的内部继续定义其他内部结构类。</p></blockquote><p>在 Java 中，广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类。下面就先来了解一下这四种内部类的用法。</p><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>成员内部类是最普通的内部类，它的定义为位于另一个类的内部，具体使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内部类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"drawshape"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样看起来，类 Draw 像是类 Circle 的一个成员， Circle 称为外部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括 private 成员和静态成员），例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count =<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内部类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 外部类的private成员</span></span><br><span class="line">            System.out.println(radius);</span><br><span class="line">            <span class="comment">// 外部类的静态成员</span></span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要采取以下形式进行访问：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">外部类.this.成员变量</span><br><span class="line">外部类.this.成员方法</span><br></pre></td></tr></table></figure></p><p>虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问，其具体形式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">        <span class="comment">// 必须先创建成员内部类的对象，再进行访问</span></span><br><span class="line">        getDrawInstance().drawSahpe();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Draw <span class="title">getDrawInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Draw();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内部类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 外部类的private成员</span></span><br><span class="line">            System.out.println(radius);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="comment">// 第一种方式</span></span><br><span class="line">        Outter outter = <span class="keyword">new</span> Outter();</span><br><span class="line">        <span class="comment">// 必须通过Outter对象来创建</span></span><br><span class="line">        Outter.Inner inner = outter.new Inner();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二种方式</span></span><br><span class="line">        Outter.Inner inner1 = outter.getInnerInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Inner inner = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">getInnerInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inner == <span class="keyword">null</span>)</span><br><span class="line">            inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        <span class="keyword">return</span> inner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类可以拥有 private 访问权限、 protected 访问权限、 public 访问权限及包访问权限。</p><p>比如上面的例子，如果成员内部类 Inner 用 private 修饰，则只能在外部类的内部访问；如果用 public 修饰，则任何地方都能访问；如果用 protected 修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。</p><p>这一点和外部类有一点不一样，外部类只能被 public 和包访问两种权限修饰。</p><p>我个人是这么理解的，由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。</p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> People <span class="title">getWoman</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 局部内部类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> age =<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Woman();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>注意，局部内部类就像是方法里面的一个局部变量一样，是不能用 public 、 protected 、 private 以及 static 修饰的。</code></p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类应该是平时我们编写代码时用得最多的，比如创建一个线程的时候：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(</span><br><span class="line">                <span class="comment">// 匿名内部类</span></span><br><span class="line">                <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"Thread run"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，匿名内部类也是不能有访问修饰符和 static 修饰符的。</p><p>匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。</p><p>匿名内部类在编译的时候由系统自动起名为<code>Outter$1.class</code>。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字 static 。</p><p>静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非 static 成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非 static 成员就会产生矛盾，因为外部类的非 static 成员必须依附于具体的对象。</p><p>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        Outter.Inner inner = <span class="keyword">new</span> Outter.Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="深入理解内部类"><a href="#深入理解内部类" class="headerlink" title="深入理解内部类"></a>深入理解内部类</h2><p>通过上面的介绍，相比你已经大致了解的内部类的使用，那么你的心里想必会有一个疑惑：</p><h3 id="为什么成员内部类可以无条件访问外部类的成员？"><a href="#为什么成员内部类可以无条件访问外部类的成员？" class="headerlink" title="为什么成员内部类可以无条件访问外部类的成员？"></a>为什么成员内部类可以无条件访问外部类的成员？</h3><p>首先我们先定义一个内部类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Inner inner = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">getInnerInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inner == <span class="keyword">null</span>)</span><br><span class="line">            inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        <span class="keyword">return</span> inner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先用 javac 进行编译，你可以发现会生成两个文件： Outter$Inner.class 和 Outter.class 。接下来利用<code>javap -p</code>反编译 Outter$Inner.class ，其结果如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">Classfile /D:/project/Test/src/test/java/test/Outter$Inner.class</span><br><span class="line">  Last modified <span class="number">2019</span>-<span class="number">11</span>-<span class="number">25</span>; size <span class="number">408</span> bytes</span><br><span class="line">  MD5 checksum b936e37bc77059b83951429e28f3f225</span><br><span class="line">  Compiled from <span class="string">"Outter.java"</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span>$<span class="title">Inner</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Fieldref           #3.#13         // test/Outter$Inner.this$0:Ltest/Outter;</span><br><span class="line">   #2 = Methodref          #4.#14         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #3 = Class              #16            // test/Outter$Inner</span><br><span class="line">   #4 = Class              #19            // java/lang/Object</span><br><span class="line">   #5 = Utf8               this$0</span><br><span class="line">   #6 = Utf8               Ltest/Outter;</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               (Ltest/Outter;)V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               SourceFile</span><br><span class="line">  #12 = Utf8               Outter.java</span><br><span class="line">  #13 = NameAndType        #5:#6          // this$0:Ltest/Outter;</span><br><span class="line">  #14 = NameAndType        #7:#20         // "&lt;init&gt;":()V</span><br><span class="line">  #15 = Class              #21            // test/Outter</span><br><span class="line">  #16 = Utf8               test/Outter$Inner</span><br><span class="line">  #17 = Utf8               Inner</span><br><span class="line">  #18 = Utf8               InnerClasses</span><br><span class="line">  #19 = Utf8               java/lang/Object</span><br><span class="line">  #20 = Utf8               ()V</span><br><span class="line">  #21 = Utf8               test/Outter</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">final</span> Outter <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line">    descriptor: Ltest/Outter;</span><br><span class="line">    flags: ACC_FINAL, ACC_SYNTHETIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Outter$Inner(Outter);</span><br><span class="line">    descriptor: (Ltest/Outter;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">2</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: aload_1</span><br><span class="line">         2: putfield      #1                  // Field this$0:Ltest/Outter;</span><br><span class="line">         <span class="number">5</span>: aload_0</span><br><span class="line">         6: invokespecial #2                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">9</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">16</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">17</span>: <span class="number">9</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">"Outter.java"</span></span><br><span class="line">InnerClasses:</span><br><span class="line">     protected #17= #3 of #15; //Inner=class test/Outter$Inner of class test/Outter</span><br></pre></td></tr></table></figure><p>32行的内容为：<code>final Outter this$0;</code></p><p>学过 C 的朋友应该能知道，这是一个指向外部类 Outter 对象的指针，也就是说编译器会默认为成员内部类添加一个指向外部类对象的引用，这样也就解释了为什么成员内部类能够无条件访问外部类了。</p><p>那么这个引用是如何赋初值的呢？下面接着看内部类的构造器：<code>public Outter$Inner(Outter);</code></p><p>从这里可以看出，虽然我们在定义的内部类的构造器是无参构造器，但编译器还是会默认添加一个参数，该参数的类型为指向外部类对象的一个引用，所以成员内部类中的 Outter this&amp;0 指针便指向了外部类对象，因此可以在成员内部类中随意访问外部类的成员。</p><p>从这里也间接说明了成员内部类是依赖于外部类的，如果没有创建外部类的对象，则无法对 Outter this&amp;0 引用进行初始化赋值，也就无法创建成员内部类的对象了。</p><h3 id="为什么局部内部类和匿名内部类只能访问局部final变量？"><a href="#为什么局部内部类和匿名内部类只能访问局部final变量？" class="headerlink" title="为什么局部内部类和匿名内部类只能访问局部final变量？"></a>为什么局部内部类和匿名内部类只能访问局部final变量？</h3><p>我们还是采用和之前一样的解答方式，先定义一个类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        Outter outter = <span class="keyword">new</span> Outter();</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">        outter.test(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过 javac 编译 Outter，也会生成两个文件： Outter.class 和 Outter1.class。默认情况下，编译器会为匿名内部类和局部内部类起名为 Outter$x.class（ x 为正整数）。</p><p>根据我提供的类，可以思考一个问题：</p><p>当 test 方法执行完毕之后，变量 a 的生命周期就结束了，而此时 Thread 对象的生命周期很可能还没有结束，那么在 Thread 的 run 方法中继续访问变量 a 就变成不可能了，但是又要实现这样的效果，怎么办呢？</p><p>Java 采用了<code>复制</code>的手段来解决这个问题。将 Outter$1.class 反编译可以得到下面的内容：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">Classfile /D:/project/Test/src/test/java/test/Outter$<span class="number">1</span>.class</span><br><span class="line">  Last modified <span class="number">2019</span>-<span class="number">11</span>-<span class="number">25</span>; size <span class="number">653</span> bytes</span><br><span class="line">  MD5 checksum <span class="number">2e238</span>dafbd73356eba22d473c6469082</span><br><span class="line">  Compiled from <span class="string">"Outter.java"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span>.<span class="title">Outter</span>$1 <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Thread</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Fieldref           #6.#23         // test/Outter$1.this$0:Ltest/Outter;</span><br><span class="line">   #2 = Fieldref           #6.#24         // test/Outter$1.val$b:I</span><br><span class="line">   #3 = Methodref          #7.#25         // java/lang/Thread."&lt;init&gt;":()V</span><br><span class="line">   #4 = Fieldref           #26.#27        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #5 = Methodref          #28.#29        // java/io/PrintStream.println:(I)V</span><br><span class="line">   #6 = Class              #30            // test/Outter$1</span><br><span class="line">   #7 = Class              #32            // java/lang/Thread</span><br><span class="line">   #8 = Utf8               val$b</span><br><span class="line">   #9 = Utf8               I</span><br><span class="line">  #10 = Utf8               this$0</span><br><span class="line">  #11 = Utf8               Ltest/Outter;</span><br><span class="line">  #12 = Utf8               &lt;init&gt;</span><br><span class="line">  #13 = Utf8               (Ltest/Outter;I)V</span><br><span class="line">  #14 = Utf8               Code</span><br><span class="line">  #15 = Utf8               LineNumberTable</span><br><span class="line">  #16 = Utf8               run</span><br><span class="line">  #17 = Utf8               ()V</span><br><span class="line">  #18 = Utf8               SourceFile</span><br><span class="line">  #19 = Utf8               Outter.java</span><br><span class="line">  #20 = Utf8               EnclosingMethod</span><br><span class="line">  #21 = Class              #33            // test/Outter</span><br><span class="line">  #22 = NameAndType        #34:#35        // test:(I)V</span><br><span class="line">  #23 = NameAndType        #10:#11        // this$0:Ltest/Outter;</span><br><span class="line">  #24 = NameAndType        #8:#9          // val$b:I</span><br><span class="line">  #25 = NameAndType        #12:#17        // "&lt;init&gt;":()V</span><br><span class="line">  #26 = Class              #36            // java/lang/System</span><br><span class="line">  #27 = NameAndType        #37:#38        // out:Ljava/io/PrintStream;</span><br><span class="line">  #28 = Class              #39            // java/io/PrintStream</span><br><span class="line">  #29 = NameAndType        #40:#35        // println:(I)V</span><br><span class="line">  #30 = Utf8               test/Outter$1</span><br><span class="line">  #31 = Utf8               InnerClasses</span><br><span class="line">  #32 = Utf8               java/lang/Thread</span><br><span class="line">  #33 = Utf8               test/Outter</span><br><span class="line">  #34 = Utf8               test</span><br><span class="line">  #35 = Utf8               (I)V</span><br><span class="line">  #36 = Utf8               java/lang/System</span><br><span class="line">  #37 = Utf8               out</span><br><span class="line">  #38 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #39 = Utf8               java/io/PrintStream</span><br><span class="line">  #40 = Utf8               println</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> val$b;</span><br><span class="line">    descriptor: I</span><br><span class="line">    flags: ACC_FINAL, ACC_SYNTHETIC</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> test.Outter <span class="keyword">this</span>$<span class="number">0</span>;</span><br><span class="line">    descriptor: Ltest/Outter;</span><br><span class="line">    flags: ACC_FINAL, ACC_SYNTHETIC</span><br><span class="line"></span><br><span class="line">  test.Outter$<span class="number">1</span>(test.Outter, <span class="keyword">int</span>);</span><br><span class="line">    descriptor: (Ltest/Outter;I)V</span><br><span class="line">    flags:</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">3</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: aload_1</span><br><span class="line">         2: putfield      #1                  // Field this$0:Ltest/Outter;</span><br><span class="line">         <span class="number">5</span>: aload_0</span><br><span class="line">         <span class="number">6</span>: iload_2</span><br><span class="line">         7: putfield      #2                  // Field val$b:I</span><br><span class="line">        <span class="number">10</span>: aload_0</span><br><span class="line">        11: invokespecial #3                  // Method java/lang/Thread."&lt;init&gt;":()V</span><br><span class="line">        <span class="number">14</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">10</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         <span class="number">3</span>: bipush        <span class="number">10</span></span><br><span class="line">         5: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">         8: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        <span class="number">11</span>: aload_0</span><br><span class="line">        12: getfield      #2                  // Field val$b:I</span><br><span class="line">        15: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        <span class="number">18</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">12</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">13</span>: <span class="number">8</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">"Outter.java"</span></span><br><span class="line">EnclosingMethod: #21.#22                // test.Outter.test</span><br><span class="line">InnerClasses:</span><br><span class="line">     #6; //class test/Outter$1</span><br></pre></td></tr></table></figure><p>我们看到在 run 方法中有一条指令：<code>bipush 10</code></p><p>这条指令表示将操作数10压栈，表示使用的是一个本地局部变量。</p><p>这个过程是在编译期间由编译器默认进行，如果这个变量的值在编译期间可以确定，则编译器默认会在匿名内部类（局部内部类）的常量池中添加一个内容相等的字面量或直接将相应的字节码嵌入到执行字节码中。</p><p>这样一来，匿名内部类使用的变量是另一个局部变量，只不过值和方法中局部变量的值相等，因此和方法中的局部变量完全独立开。</p><p>接下来也来看一下 test.Outter$1 的构造方法：<code>test.Outter$1(test.Outter, int);</code></p><p>我们看到匿名内部类 Outter$1 的构造器含有两个参数，一个是指向外部类对象的引用，一个是 int 型变量，很显然，这里是将变量 test 方法中的形参 b 以参数的形式传进来对匿名内部类中的拷贝（变量 b 的拷贝）进行赋值初始化。</p><p><code>也就说如果局部变量的值在编译期间就可以确定，则直接在匿名内部里面创建一个拷贝。如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值。</code></p><p>从上面可以看出，在 run 方法中访问的变量 b 根本就不是test方法中的局部变量 b 。这样一来就解决了前面所说的 生命周期不一致的问题。但是新的问题又来了，既然在 run 方法中访问的变量 b 和test方法中的变量 b 不是同一个变量，那么当在 run 方法中改变变量 b 的值的话，会出现什么情况？</p><p><code>会造成数据不一致性</code>，这样就达不到原本的意图和要求。为了解决这个问题， Java 编译器就限定必须将变量 b 限制为 final ，不允许对变量 b 进行更改（对于引用类型的变量，是不允许指向新的对象），这样数据不一致性的问题就得以解决了。</p><p>到这里，想必大家应该清楚为何 方法中的局部变量和形参都必须用 final 进行限定了。</p><h3 id="静态内部类有特殊的地方吗？"><a href="#静态内部类有特殊的地方吗？" class="headerlink" title="静态内部类有特殊的地方吗？"></a>静态内部类有特殊的地方吗？</h3><p>从前面可以知道，静态内部类是不依赖于外部类的，也就说可以在不创建外部类对象的情况下创建内部类的对象。</p><p>另外，静态内部类是不持有指向外部类对象的引用的，这个读者可以自己尝试反编译 class 文件看一下就知道了，是没有 Outter this&amp;0 引用的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天介绍了内部类相关的知识，包括其一般的用法以及内部类和外部类的依赖关系，通过对字节码进行反编译详细了解了其实现模式，最后留给大家一个任务自己去实际探索一下静态内部类的实现。希望通过这篇介绍可以帮大家更加深刻了解内部类。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://jjcoder.top/" target="_blank" rel="noopener">https://jjcoder.top/</a></p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说起内部类，大家肯定感觉熟悉又陌生，因为一定在很多框架源码中有看到别人使用过，但又感觉自己使用的比较少，今天我就带你具体来看看内部类。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.death00.top/tags/Java/"/>
    
      <category term="内部类" scheme="https://www.death00.top/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>GC 知识点补充——CMS</title>
    <link href="https://www.death00.top/2019/11/01/GC%20%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85%E2%80%94%E2%80%94CMS/"/>
    <id>https://www.death00.top/2019/11/01/GC 知识点补充——CMS/</id>
    <published>2019-11-01T02:00:00.000Z</published>
    <updated>2020-01-04T02:42:55.631Z</updated>
    
    <content type="html"><![CDATA[<p>之前已经讲过了不少有关 GC 的内容，今天准备将之前没有细讲的部分进行补充，首先要提到的就是垃圾收集器。<br><a id="more"></a></p><p>基础的回收方式有三种：<code>清除</code>、<code>压缩</code>、<code>复制</code>，衍生出来的垃圾收集器有：</p><h2 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h2><p>新生代收集器，使用停止复制算法，使用一个线程进行 GC ，串行，其它工作线程暂停。</p><p>使用<code>-XX:+UseSerialGC</code>开关来控制使用<code>Serial + Serial Old</code>模式运行进行内存回收（这也是虚拟机在 Client 模式下运行的默认值）。</p><h2 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h2><p>新生代收集器，使用停止复制算法，Serial 收集器的多线程版，用多个线程进行 GC ，并行，其它工作线程暂停，关注缩短垃圾收集时间。</p><p>使用<code>-XX:+UseParNewGC</code>开关来控制使用<code>ParNew + Serial Old</code>收集器组合收集内存；使用<code>-XX:ParallelGCThreads</code>来设置执行内存回收的线程数。</p><h2 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h2><p>新生代收集器，使用停止复制算法，关注 CPU 吞吐量，即<code>运行用户代码的时间/总时间</code>，比如：JVM 运行 100 分钟，其中运行用户代码 99 分钟，垃 圾收集 1 分钟，则吞吐量是 99% ，这种收集器能最高效率的利用 CPU ，适合运行后台运算（其他关注缩短垃圾收集时间的收集器，如 CMS ，等待时间很少，所以适 合用户交互，提高用户体验）。</p><p>使用<code>-XX:+UseParallelGC</code>开关控制使用<code>Parallel Scavenge + Serial Old</code>收集器组合回收垃圾（这也是在 Server 模式下的默认值）；使用<code>-XX:GCTimeRatio</code>来设置用户执行时间占总时间的比例，默认 99 ，即 1% 的时间用来进行垃圾回收。使用<code>-XX:MaxGCPauseMillis</code>设置 GC 的最大停顿时间（这个参数只对 Parallel Scavenge 有效），用开关参数<code>-XX:+UseAdaptiveSizePolicy</code>可以进行动态控制，如自动调整 Eden / Survivor 比例，老年代对象年龄，新生代大小等，这个参数在 ParNew 下没有。</p><h2 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h2><p>老年代收集器，单线程收集器，串行，使用<code>标记-整理</code>算法，使用单线程进行GC，其它工作线程暂停（注意：在老年代中进行<code>标记-整理</code>算法清理，也需要暂停其它线程），在JDK1.5之前，Serial Old 收集器与 ParallelScavenge 搭配使用。</p><blockquote><p>整理的方法是 Sweep （清除）和 Compact （压缩），清除是将废弃的对象干掉，只留幸存的对象，压缩是移动对象，将空间填满保证内存分为2块，一块全是对象，一块空闲），</p></blockquote><h2 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h2><p>老年代收集器，多线程，并行，多线程机制与 Parallel Scavenge 差不错，使用<code>标记-整理</code>算法，在 Parallel Old 执行时，仍然需要暂停其它工作线程。</p><blockquote><p>Parallel Old 收集器的整理，与 Serial Old 不同，这里的整理是Copy（复制）和Compact（压缩），复制的意思就是将幸存的对象复制到预先准备好的区域，而不是像Sweep（清除）那样清除废弃的对象。</p></blockquote><p>Parallel Old 在多核计算中很有用。 Parallel Old 出现后（JDK 1.6），与 Parallel Scavenge 配合有很好的效果，充分体现 Parallel Scavenge 收集器吞吐量优先的效果。使用<code>-XX:+UseParallelOldGC</code>开关控制使用<code>Parallel Scavenge + Parallel Old</code>组合收集器进行收集。</p><h2 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h2><p>全称 Concurrent Mark Sweep，老年代收集器，致力于获取最短回收停顿时间（即缩短垃圾回收的时间），使用<code>标记-清除</code>算法，多线程，优点是并发收集（用户线程可以和 GC 线程同时工作），停顿小。</p><p>使用<code>-XX:+UseConcMarkSweepGC</code>进行<code>ParNew + CMS + Serial Old</code>进行内存回收，优先使用<code>ParNew + CMS</code>（原因见后面），当用户线程内存不足时，采用备用方案<code>Serial Old</code>收集。</p><h3 id="如何开始"><a href="#如何开始" class="headerlink" title="如何开始"></a>如何开始</h3><p>首先来看一下 CMS 是在什么情况下进行 GC：</p><ol><li>首先 JVM 根据<code>-XX:CMSInitiatingOccupancyFraction</code>、<code>-XX:+UseCMSInitiatingOccupancyOnly</code>来决定什么时间开始垃圾收集。</li><li>如果设置了<code>-XX:+UseCMSInitiatingOccupancyOnly</code>，那么只有当老年代占用确实达到了<code>-XX:CMSInitiatingOccupancyFraction</code>参数所设定的比例时才会触发 CMS GC。</li><li>如果没有设置<code>-XX:+UseCMSInitiatingOccupancyOnly</code>，那么系统会根据统计数据自行决定什么时候触发 CMS GC。因此有时会遇到设置了 80% 比例才 CMS GC，但是 50% 时就已经触发了，就是因为这个参数没有设置的原因。</li></ol><h3 id="具体执行"><a href="#具体执行" class="headerlink" title="具体执行"></a>具体执行</h3><p>CMS GC 的执行过程，具体来说就是：</p><h4 id="初始标记-CMS-initial-mark"><a href="#初始标记-CMS-initial-mark" class="headerlink" title="初始标记(CMS-initial-mark)"></a>初始标记(CMS-initial-mark)</h4><p>该阶段是 stop the world 阶段，因此此阶段标记的对象只是从 root 集最直接可达的对象。</p><p>此阶段会打印 1 条日志：CMS-initial-mark：961330K（1572864K），指标记时，老年代的已用空间和总空间</p><h4 id="并发标记-CMS-concurrent-mark"><a href="#并发标记-CMS-concurrent-mark" class="headerlink" title="并发标记(CMS-concurrent-mark)"></a>并发标记(CMS-concurrent-mark)</h4><p>此阶段是和应用线程并发执行的，所谓并发收集器指的就是这个，主要作用是标记可达的对象，此阶段不需要用户线程停顿。</p><p>此阶段会打印 2 条日志：CMS-concurrent-mark-start，CMS-concurrent-mark</p><h4 id="预清理-CMS-concurrent-preclean"><a href="#预清理-CMS-concurrent-preclean" class="headerlink" title="预清理(CMS-concurrent-preclean)"></a>预清理(CMS-concurrent-preclean)</h4><p>此阶段主要是进行一些预清理，因为标记和应用线程是并发执行的，因此会有些对象的状态在标记后会改变，此阶段正是解决这个问题。因为之后的 CMS-remark 阶段也会 stop the world，为了使暂停的时间尽可能的小，也需要 preclean 阶段先做一部分工作以节省时间。</p><p>此阶段会打印 2 条日志：CMS-concurrent-preclean-start，CMS-concurrent-preclean</p><h4 id="可控预清理-CMS-concurrent-abortable-preclean"><a href="#可控预清理-CMS-concurrent-abortable-preclean" class="headerlink" title="可控预清理(CMS-concurrent-abortable-preclean)"></a>可控预清理(CMS-concurrent-abortable-preclean)</h4><p>此阶段的目的是使 CMS GC 更加可控一些，作用也是执行一些预清理，以减少 CMS-remark 阶段造成应用暂停的时间。</p><p>此阶段涉及几个参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:CMSMaxAbortablePrecleanTime：当 abortable-preclean 阶段执行达到这个时间时才会结束。</span><br><span class="line">-XX:CMSScheduleRemarkEdenSizeThreshold（默认2m）：控制 abortable-preclean 阶段什么时候开始执行，即当年轻代使用达到此值时，才会开始 abortable-preclean 阶段。</span><br><span class="line">-XX:CMSScheduleRemarkEdenPenetratio（默认50%）：控制 abortable-preclean 阶段什么时候结束执行。</span><br></pre></td></tr></table></figure></p><p>此阶段会打印 3 条日志：CMS-concurrent-abortable-preclean-start，CMS-concurrent-abortable-preclean，CMS：abort preclean due to time XXX</p><h4 id="重新标记-CMS-remark"><a href="#重新标记-CMS-remark" class="headerlink" title="重新标记(CMS-remark)"></a>重新标记(CMS-remark)</h4><p>此阶段暂停应用线程，停顿时间比并发标记小得多，但比初始标记稍长，因为会对所有对象进行重新扫描并标记。</p><p>此阶段会打印以下日志：</p><ol><li>YG occupancy：964861K（2403008K），指执行时年轻代的情况。</li><li>CMS remark：961330K（1572864K），指执行时老年代的情况。</li><li>此外，还打印出了弱引用处理、类卸载等过程的耗时。</li></ol><h4 id="并发清除-CMS-concurrent-sweep"><a href="#并发清除-CMS-concurrent-sweep" class="headerlink" title="并发清除(CMS-concurrent-sweep)"></a>并发清除(CMS-concurrent-sweep)</h4><p>此阶段进行并发的垃圾清理。</p><h4 id="并发重设状态等待下次CMS的触发-CMS-concurrent-reset"><a href="#并发重设状态等待下次CMS的触发-CMS-concurrent-reset" class="headerlink" title="并发重设状态等待下次CMS的触发(CMS-concurrent-reset)"></a>并发重设状态等待下次CMS的触发(CMS-concurrent-reset)</h4><p>此阶段是为下一次 CMS GC 重置相关数据结构。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>CMS 的收集过程，概括一下就是：2 次标记，2 次预清除，1 次重新标记，1 次清除。</p><p>在CMS清理过程中，只有初始标记和重新标记需要短暂停顿用户线程，并发标记和并发清除都不需要暂停用户线程，因此效率很高，很适合高交互的场合。</p><p>CMS也有<code>缺点</code>，它需要消耗额外的 CPU 和内存资源。在 CPU 和内存资源紧张，会加重系统负担（CMS 默认启动线程数为( CPU数量 + 3 ) / 4 ）。</p><p>另外，在并发收集过程中，用户线程仍然在运行，仍然产生内存垃圾，所以可能产生“浮动垃圾”（本次无法清理，只能下一次Full GC才清理）。因此在 GC 期间，需要预留足够的内存给用户线程使用。</p><p>所以使用 CMS 的收集器并不是老年代满了才触发 Full GC ，而是在使用了一大半（默认 68% ，即 2/3 ，使用<code>-XX:CMSInitiatingOccupancyFraction</code>来设置）的时候就要进行 Full GC。如果用户线程消耗内存不是特别大，可以适当调高<code>-XX:CMSInitiatingOccupancyFraction</code>以降低 GC 次数，提高性能。如果预留的用户线程内存不够，则会触发 Concurrent Mode Failure，此时，将触发备用方案：使用 Serial Old 收集器进行收集，但这样停顿时间就长了，因此<code>-XX:CMSInitiatingOccupancyFraction</code>不宜设的过大。</p><p>还有，CMS 采用的是<code>标记-清除</code>算法，会导致内存碎片的产生，可以使用<code>-XX：+UseCMSCompactAtFullCollection</code>来设置是否在 Full GC 之后进行碎片整理，用<code>-XX：CMSFullGCsBeforeCompaction</code>来设置在执行多少次不压缩的 Full GC 之后，来一次带压缩的 Full GC。</p><h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><p>并发收集：</p><blockquote><p>指用户线程与GC线程同时执行（不一定是并行，可能交替，但总体上是在同时执行的），不需要停顿用户线程（其实在 CMS 中用户线程还是需要停顿的，只是非常短，GC 线程在另一个 CPU 上执行）；</p></blockquote><p>并行收集：</p><blockquote><p>指多个 GC 线程并行工作，但此时用户线程是暂停的；</p></blockquote><p>所以，Serial 是串行的，Parallel 收集器是并行的，而 CMS 收集器是并发的。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>今天了解了一下普通的垃圾收集器，并且详细介绍了 CMS，其特性其实是基于普通的垃圾算法，增加了预处理、预清除的过程，因此效率更加优越。当然它也有自己的缺点，更加消耗资源，因此在选用的时候需要结合实际场景。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://jjcoder.top/" target="_blank" rel="noopener">https://jjcoder.top/</a></p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前已经讲过了不少有关 GC 的内容，今天准备将之前没有细讲的部分进行补充，首先要提到的就是垃圾收集器。&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://www.death00.top/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://www.death00.top/tags/JVM/"/>
    
      <category term="GC" scheme="https://www.death00.top/tags/GC/"/>
    
      <category term="CMS" scheme="https://www.death00.top/tags/CMS/"/>
    
  </entry>
  
  <entry>
    <title>JVM 知识点补充——永久代和元空间</title>
    <link href="https://www.death00.top/2019/10/31/JVM%20%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85%E2%80%94%E2%80%94%E6%B0%B8%E4%B9%85%E4%BB%A3%E5%92%8C%E5%85%83%E7%A9%BA%E9%97%B4/"/>
    <id>https://www.death00.top/2019/10/31/JVM 知识点补充——永久代和元空间/</id>
    <published>2019-10-31T02:00:00.000Z</published>
    <updated>2020-01-04T02:39:39.432Z</updated>
    
    <content type="html"><![CDATA[<p>之前已经讲过了不少有关 JVM 的内容，今天准备将之前没有细讲的部分进行补充，比如：永久代和元空间。<br><a id="more"></a></p><h2 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h2><p>Java 的内存中有一块称之为方法区的部分，在 JDK8 之前， Hotspot 虚拟机中的实现方式为永久代（Permanent Generation），别的JVM都没有这个东西。</p><p>在过去（当自定义类加载器使用不普遍的时候），类几乎是“静态的”并且很少被卸载和回收，因此类也可以被看成“永久的”。另外由于类作为 JVM 实现的一部分，它们不由程序来创建，因为它们也被认为是“非堆”的内存。</p><p>永久代是一段连续的内存空间，我们在 JVM 启动之前可以通过设置<code>-XX:MaxPermSize</code>的值来控制永久代的大小，32 位机器默认的永久代的大小为 64M，64 位的机器则为 85M。</p><p>永久代的垃圾回收和老年代的垃圾回收是绑定的，一旦其中一个区域被占满，这两个区都要进行垃圾回收。但是有一个明显的问题，由于我们可以通过<code>‑XX:MaxPermSize</code>设置永久代的大小，一旦类的元数据超过了设定的大小，程序就会耗尽内存，并出现内存溢出错误 (java.lang.OutOfMemoryError: PermGen space)。</p><p>为什么类的元数据占用内存会那么大？因为在 JDK7 之前的 HotSpot 虚拟机中，纳入字符串常量池的字符串被存储在永久代中，因此导致了一系列的性能问题和内存溢出错误。</p><p>为了解决这些性能问题，也为了能够让 Hotspot 能和其他的虚拟机一样管理，<code>元空间</code>就产生了。</p><h2 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h2><p>元空间是 Hotspot 在 JDK8 中新加的内容，其本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：</p><blockquote><p>元空间并不在虚拟机中，而是使用<code>本地内存</code>。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：</p><p>-XX:MetaspaceSize　</p><blockquote><p>初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。<br>　　<br>-XX:MaxMetaspaceSize<br>最大空间，默认是没有限制的。</p></blockquote><p>除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：</p><p>-XX:MinMetaspaceFreeRatio</p><blockquote><p>在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集</p></blockquote><p>-XX:MaxMetaspaceFreeRatio</p><blockquote><p>在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</p></blockquote></blockquote><h3 id="移除永久代的影响"><a href="#移除永久代的影响" class="headerlink" title="移除永久代的影响"></a>移除永久代的影响</h3><p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。因此，我们就不会遇到永久代存在时的内存溢出错误，也不会出现泄漏的数据移到交换区这样的事情。最终用户可以为元空间设置一个可用空间最大值，如果不进行设置，JVM 会自动根据类的元数据大小动态增加元空间的容量。</p><p>注意：永久代的移除并不代表自定义的类加载器泄露问题就解决了。因此，你还必须监控你的内存消耗情况，因为一旦发生泄漏，会占用你的大量本地内存，并且还可能导致交换区交换更加糟糕。</p><h3 id="元空间内存管理"><a href="#元空间内存管理" class="headerlink" title="元空间内存管理"></a>元空间内存管理</h3><p>元空间的内存管理由元空间虚拟机来完成。</p><p>先前，对于类的元数据我们需要不同的垃圾回收器进行处理，现在只需要执行元空间虚拟机的 C++ 代码即可完成。在元空间中，类和其元数据的生命周期和其对应的类加载器是相同的。话句话说，只要类加载器存活，其加载的类的元数据也是存活的，因而不会被回收掉。</p><p>准确的来说，每一个类加载器的存储区域都称作一个元空间，所有的元空间合在一起就是我们一直说的元空间。当一个类加载器被垃圾回收器标记为不再存活，其对应的元空间会被回收。在元空间的回收过程中没有重定位和压缩等操作。但是元空间内的元数据会进行扫描来确定 Java 引用。</p><p>那具体是如何管理的呢？</p><p>元空间虚拟机负责元空间的分配，其采用的形式为组块分配。组块的大小因类加载器的类型而异。在元空间虚拟机中存在一个全局的空闲组块列表。</p><ol><li>当一个类加载器需要组块时，它就会从这个全局的组块列表中获取并维持一个自己的组块列表。</li><li>当一个类加载器不再存活时，那么其持有的组块将会被释放，并返回给全局组块列表。</li><li>类加载器持有的组块又会被分成多个块，每一个块存储一个单元的元信息。组块中的块是线性分配（指针碰撞分配形式）。组块分配自内存映射区域。这些全局的虚拟内存映射区域以链表形式连接，一旦某个虚拟内存映射区域清空，这部分内存就会返回给操作系统。</li></ol><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池在 JDK6 及之前版本的 JVM 中是方法区的一部分，而在 HotSpot 虚拟机中方法区的实现是永久代(Permanent Generation)。所以运行时常量池也是在永久代的。</p><p>但是 JDK7 及之后版本的 JVM 已经将字符串常量池从方法区中移了出来，在堆（Heap）中开辟了一块区域存放运行时常量池。</p><p><code>String.intern()</code>是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。</p><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><p>前面已经提到，元空间虚拟机采用了组块分配的形式，同时区块的大小由类加载器类型决定。类信息并不是固定大小，因此有可能分配的空闲区块和类需要的区块大小不同，这种情况下可能导致碎片存在。元空间虚拟机目前并不支持压缩操作，所以碎片化是目前最大的问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>曾经的永久代，因为容易产生 OOM 而被优化成了元空间，但即便这样，依然存在着问题，不知道 JDK 之后还会怎样优化呢？</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://jjcoder.top/" target="_blank" rel="noopener">https://jjcoder.top/</a></p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前已经讲过了不少有关 JVM 的内容，今天准备将之前没有细讲的部分进行补充，比如：永久代和元空间。&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://www.death00.top/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://www.death00.top/tags/JVM/"/>
    
      <category term="永久代" scheme="https://www.death00.top/tags/%E6%B0%B8%E4%B9%85%E4%BB%A3/"/>
    
      <category term="元空间" scheme="https://www.death00.top/tags/%E5%85%83%E7%A9%BA%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>设计模式——原型模式</title>
    <link href="https://www.death00.top/2019/10/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.death00.top/2019/10/30/设计模式——原型模式/</id>
    <published>2019-10-30T02:00:00.000Z</published>
    <updated>2020-01-04T02:40:20.514Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式中，单例模式应该是大家最为熟悉的了，那如果我们需要对一个对象进行多次复制的话，大家会用什么呢？这就要用到今天要讲的原型模式了。<br><a id="more"></a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>其定义为：</p><blockquote><p>使用原型实例指定将要创建的对象类型，通过复制这个实例创建新的对象。</p></blockquote><p>具体来说就是，通过给出一个原型对象来指明所创建的对象的类型，然后使用自身实现的克隆接口来复制这个原型对象，该模式就是用这种方式来创建出更多同类型的对象。</p><p>这样的好处是：</p><blockquote><p>Object 类的 clone() 方法是一个本地方法，它可以直接操作内存中的二进制流，所以性能相对 new 实例化来说，更加优秀。</p></blockquote><p>一个对象通过 new 实例化创建过程为：</p><ol><li>在内存中开辟一块空间。</li><li>在开辟的内存空间中创建对象。</li><li>调用对象的构造函数进行初始化对象。</li></ol><p>而一个对象通过 clone() 创建过程为：</p><ol><li>根据原对象内存大小开辟一块内存空间。</li><li>复制已有对象，克隆对象中所有属性值。</li></ol><p>相对 new 来说，clone() 少了调用构造函数。如果构造函数中存在大量属性初始化或大对象，则使用 clone() 的复制对象的方式性能会好一些。</p><h2 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h2><p>让我们通过一个例子来具体了解一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 实现Cloneable 接口的原型抽象类Prototype</span><br><span class="line"> */</span><br><span class="line">public class Prototype implements Cloneable &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 重写 clone() 方法</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public Prototype clone() &#123;</span><br><span class="line">        Prototype prototype = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            prototype = (Prototype) super.clone();</span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return prototype;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 实现原型类</span><br><span class="line"> */</span><br><span class="line">public class ConcretePrototype extends Prototype &#123;</span><br><span class="line">    public void show() &#123;</span><br><span class="line">        System.out.println(&quot;原型模式实现类&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 测试类</span><br><span class="line"> */</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ConcretePrototype cp = new ConcretePrototype();</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            ConcretePrototype cloneCp = (ConcretePrototype) cp.clone();</span><br><span class="line">            cloneCp.show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当我们实现原型抽象类时，需要注意三点：</p><ol><li>实现 Cloneable 接口：Cloneable 接口与序列化接口的作用类似，它只是告诉虚拟机可以安全地在实现了这个接口的类上使用 clone() 方法。在 JVM 中，只有实现了 Cloneable 接口的类才可以被拷贝，否则会抛出 CloneNotSupportedException 异常。</li><li>重写 Object 类中的 clone() 方法：在 Java 中，所有类的父类都是 Object 类，而 Object 类中有一个 clone() 方法，作用是返回对象的一个拷贝。</li><li>在重写的 clone() 方法中调用 super.clone()：默认情况下，类不具备复制对象的能力，需要调用 super.clone() 来实现。</li></ol><h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><p>谈到了拷贝，就不得不说到一个经典的问题：<code>深拷贝与浅拷贝</code>，有的地方也叫<code>深克隆与浅克隆</code>。</p><p>在上面的原型模式中，在调用 super.clone() 方法之后，首先会检查当前对象所属的类是否支持 clone，也就是看该类是否实现了 Cloneable 接口。</p><p>如果支持，则创建当前对象所属类的一个新对象，并对该对象进行初始化，使得新对象的成员变量的值与当前对象的成员变量的值一模一样，但<code>对于其它对象的引用以及 List 等类型的成员属性，则只能复制这些对象的引用了</code>。所以简单调用 super.clone() 这种克隆对象方式，就是一种<code>浅拷贝</code>。</p><p>为了让大家更加清楚<code>浅拷贝</code>的弊端，举个具体的例子：</p><p>Student 类中有一个 Teacher 对象，我们让这两个类都实现 Cloneable 接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 学生姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 学生所属的老师</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Teacher teacher;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写克隆方法，对学生进行克隆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            student = (Student) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 老师姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写克隆方法，对老师类进行克隆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Teacher <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Teacher teacher= <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            teacher= (Teacher) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> teacher;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试的时候，我们先定义一个学生和一个老师，并让其关联在一起。然后复制之前的学生，生成一个新的学生，修改新学生的老师。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义老师1</span></span><br><span class="line">        Teacher teacher = <span class="keyword">new</span> Teacher();</span><br><span class="line">        teacher.setName(<span class="string">"刘老师"</span>);</span><br><span class="line">        <span class="comment">// 定义学生1</span></span><br><span class="line">        Student stu1 = <span class="keyword">new</span> Student();</span><br><span class="line">        stu1.setName(<span class="string">"test1"</span>);</span><br><span class="line">        <span class="comment">// 老师1和学生1进行关联</span></span><br><span class="line">        stu1.setTeacher(teacher);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 复制学生1，生成学生2</span></span><br><span class="line">        Student stu2 = stu1.clone();</span><br><span class="line">        stu2.setName(<span class="string">"test2"</span>);</span><br><span class="line">        <span class="comment">// 修改学生2的老师</span></span><br><span class="line">        stu2.getTeacher().setName(<span class="string">"王老师"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看修改结果</span></span><br><span class="line">        System.out.println(<span class="string">"学生"</span> + stu1.getName() + <span class="string">"的老师是:"</span> + stu1.getTeacher().getName());</span><br><span class="line">        System.out.println(<span class="string">"学生"</span> + stu1.getName() + <span class="string">"的老师是:"</span> + stu2.getTeacher().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们想要的结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">学生test1的老师是：刘老师</span><br><span class="line">学生test2的老师是：王老师</span><br></pre></td></tr></table></figure></p><p>但实际结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">学生test1的老师是：王老师</span><br><span class="line">学生test2的老师是：王老师</span><br></pre></td></tr></table></figure></p><p>观察以上运行结果，我们可以发现：在我们给学生2修改老师的时候，学生1的老师也跟着被修改了。这就是浅拷贝带来的问题。</p><p>我们可以通过<code>深拷贝</code>的方式解决这类问题，修改 Student 类的 clone() 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重写克隆方法，对学生和老师都进行克隆</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Student <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Student student = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        student = (Student) <span class="keyword">super</span>.clone();</span><br><span class="line">        <span class="comment">// 克隆 teacher 对象</span></span><br><span class="line">        Teacher teacher = <span class="keyword">this</span>.teacher.clone();</span><br><span class="line">        student.setTeacher(teacher);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> student;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时，我们再次运行 Test 中的 main() 方法，就可以得到我们预想的结果了。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>在一些重复创建对象的场景下，我们就可以使用原型模式来提高对象的创建性能。例如：循环体内创建对象时，我们就可以考虑用 clone() 的方式来实现。</p><p>除此之外，原型模式在开源框架中的应用也非常广泛。例如 Spring 中，@Service 默认都是单例的。用了私有全局变量，若不想影响下次注入或每次上下文获取 bean，就需要用到原型模式，我们可以通过以下注解来实现，@Scope(“prototype”)。有兴趣的朋友深入了解一下其中的原理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>原型模式，就是针对需要大量复制同一对象的场景，比如用户获取商品、循环体内创建对象等，都是不错的选择，且效率好。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://jjcoder.top/" target="_blank" rel="noopener">https://jjcoder.top/</a></p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计模式中，单例模式应该是大家最为熟悉的了，那如果我们需要对一个对象进行多次复制的话，大家会用什么呢？这就要用到今天要讲的原型模式了。&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://www.death00.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://www.death00.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="原型模式" scheme="https://www.death00.top/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Netty - 粘包和半包(下)</title>
    <link href="https://www.death00.top/2019/10/24/Netty%20-%20%E7%B2%98%E5%8C%85%E5%92%8C%E5%8D%8A%E5%8C%85(%E4%B8%8B)/"/>
    <id>https://www.death00.top/2019/10/24/Netty - 粘包和半包(下)/</id>
    <published>2019-10-24T02:00:00.000Z</published>
    <updated>2019-10-24T01:01:53.278Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇介绍了粘包和半包及其通用的解决方案，今天重点来看一下 Netty 是如何实现封装成帧(Framing)方案的。<br><a id="more"></a></p><h2 id="解码核心流程"><a href="#解码核心流程" class="headerlink" title="解码核心流程"></a>解码核心流程</h2><p>之前介绍过三种解码器<code>FixedLengthFrameDecoder</code>、<code>DelimiterBasedFrameDecoder</code>、<code>LengthFieldBasedFrameDecoder</code>，它们都继承自<code>ByteToMessageDecoder</code>，而<code>ByteToMessageDecoder</code>继承自<code>ChannelInboundHandlerAdapter</code>，其核心方法为<code>channelRead</code>。因此，我们来看看<code>ByteToMessageDecoder</code>的<code>channelRead</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ByteBuf) &#123;</span><br><span class="line">        CodecOutputList out = CodecOutputList.newInstance();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将传入的消息转化为data</span></span><br><span class="line">            ByteBuf data = (ByteBuf) msg;</span><br><span class="line">            <span class="comment">// 最终实现的目标是将数据全部放进cumulation中</span></span><br><span class="line">            first = cumulation == <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 第一笔数据直接放入</span></span><br><span class="line">            <span class="keyword">if</span> (first) &#123;</span><br><span class="line">                cumulation = data;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不是第一笔数据就进行追加</span></span><br><span class="line">                cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 解码</span></span><br><span class="line">            callDecode(ctx, cumulation, out);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 以下代码省略，因为不属于解码过程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再来看看<code>callDecode</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">callDecode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (in.isReadable()) &#123;</span><br><span class="line">            <span class="keyword">int</span> outSize = out.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (outSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 以下代码省略，因为初始状态时，outSize 只可能是0，不可能进入这里</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> oldInputLength = in.readableBytes();</span><br><span class="line">            <span class="comment">// 在进行 decode 时，不执行handler的remove操作。</span></span><br><span class="line">            <span class="comment">// 只有当 decode 执行完之后，开始清理数据。</span></span><br><span class="line">            decodeRemovalReentryProtection(ctx, in, out);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 省略以下代码，因为后面的内容也不是解码的过程</span></span><br></pre></td></tr></table></figure></p><p>再来看看<code>decodeRemovalReentryProtection</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">decodeRemovalReentryProtection</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 设置当前状态为正在解码</span></span><br><span class="line">    decodeState = STATE_CALLING_CHILD_DECODE;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 解码</span></span><br><span class="line">        decode(ctx, in, out);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 执行hander的remove操作</span></span><br><span class="line">        <span class="keyword">boolean</span> removePending = decodeState == STATE_HANDLER_REMOVED_PENDING;</span><br><span class="line">        decodeState = STATE_INIT;</span><br><span class="line">        <span class="keyword">if</span> (removePending) &#123;</span><br><span class="line">            handlerRemoved(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类都重写了该方法，每种实现都会有自己特殊的解码方式</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure></p><p>从上面的过程可以总结出，在解码之前，需要先将数据写入<code>cumulation</code>，当解码结束后，需要通过 handler 进行移除。</p><h2 id="具体解码过程"><a href="#具体解码过程" class="headerlink" title="具体解码过程"></a>具体解码过程</h2><p>刚刚说到<code>decode</code>方法在子类中都有实现，那针对我们说的三种解码方式，一一看其实现。</p><h3 id="FixedLengthFrameDecoder"><a href="#FixedLengthFrameDecoder" class="headerlink" title="FixedLengthFrameDecoder"></a>FixedLengthFrameDecoder</h3><p>其源码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Object decoded = decode(ctx, in);</span><br><span class="line">    <span class="keyword">if</span> (decoded != <span class="keyword">null</span>) &#123;</span><br><span class="line">        out.add(decoded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">decode</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @SuppressWarnings(<span class="string">"UnusedParameters"</span>)</span> ChannelHandlerContext ctx, ByteBuf in) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 收集到的数据是否小于固定长度，小于就代表无法解析</span></span><br><span class="line">    <span class="keyword">if</span> (in.readableBytes() &lt; frameLength) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> in.readRetainedSlice(frameLength);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就和这个类的名字一样简单，就是固定长度进行解码，因此，在设置该解码器的时候，需要在构造方式里传入<code>frameLength</code>。</p><h3 id="DelimiterBasedFrameDecoder"><a href="#DelimiterBasedFrameDecoder" class="headerlink" title="DelimiterBasedFrameDecoder"></a>DelimiterBasedFrameDecoder</h3><p>其源码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Object decoded = decode(ctx, in);</span><br><span class="line">    <span class="keyword">if</span> (decoded != <span class="keyword">null</span>) &#123;</span><br><span class="line">        out.add(decoded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf buffer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 当前的分割符是否是换行分割符(\n或者\r\n)</span></span><br><span class="line">    <span class="keyword">if</span> (lineBasedDecoder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> lineBasedDecoder.decode(ctx, buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Try all delimiters and choose the delimiter which yields the shortest frame.</span></span><br><span class="line">    <span class="keyword">int</span> minFrameLength = Integer.MAX_VALUE;</span><br><span class="line">    ByteBuf minDelim = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 其他分割符进行一次切分</span></span><br><span class="line">    <span class="keyword">for</span> (ByteBuf delim: delimiters) &#123;</span><br><span class="line">        <span class="keyword">int</span> frameLength = indexOf(buffer, delim);</span><br><span class="line">        <span class="keyword">if</span> (frameLength &gt;= <span class="number">0</span> &amp;&amp; frameLength &lt; minFrameLength) &#123;</span><br><span class="line">            minFrameLength = frameLength;</span><br><span class="line">            minDelim = delim;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以下代码省略</span></span><br></pre></td></tr></table></figure></p><p>根据它的名字可以知道，分隔符才是它的核心。它将分割符分成两类，<code>只有换行分割符(\n或者\r\n)</code>和<code>其他</code>。因此，需要注意的是，你可以定义多种分割符，它都是支持的。</p><h3 id="LengthFieldBasedFrameDecoder"><a href="#LengthFieldBasedFrameDecoder" class="headerlink" title="LengthFieldBasedFrameDecoder"></a>LengthFieldBasedFrameDecoder</h3><p>该类比较复杂，如果直接看方法容易把自己看混乱，因此我准备结合类上的解释，先看看其私有变量。</p><blockquote><p>2 bytes length field at offset 1 in the middle of 4 bytes header, strip the first header field and the length field, the length field represents the length of the <code>whole message</code></p><p>Let’s give another twist to the previous example. The only difference from the previous example is that the length field represents the length of the whole message instead of the message body, just like the third example. We have to count the length of HDR1 and Length into lengthAdjustment. Please note that we don’t need to take the length of HDR2 into account because the length field already includes the whole header length.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* BEFORE DECODE (16 bytes)                       AFTER DECODE (13 bytes)</span><br><span class="line">* +------+--------+------+----------------+      +------+----------------+</span><br><span class="line">* | HDR1 | Length | HDR2 | Actual Content |-----&gt;| HDR2 | Actual Content |</span><br><span class="line">* | 0xCA | 0x0010 | 0xFE | &quot;HELLO, WORLD&quot; |      | 0xFE | &quot;HELLO, WORLD&quot; |</span><br><span class="line">* +------+--------+------+----------------+      +------+----------------+</span><br></pre></td></tr></table></figure><p><code>lengthFieldOffset</code> : 该字段代表 Length 字段是从第几个字节开始的。上面的例子里，Length 字段是从第1个字节开始（HDR1 是第0个字节），因此该值即为0。</p><p><code>lengthFieldLength</code> : 该字段代表 Length 字段所占用的字节数。上面的例子里，Length 字段占用2个字节，因此该值为2。</p><p><code>lengthAdjustment</code> : 该字段代表 Length 字段结束位置到真正的内容开始位置的距离。上面例子里，因为 Length 字段的含义是整个消息（包括 HDR1、Length、HDR2、Actual Content，一般 Length 指的只是 Actual Content），所以 Length 末尾到真正的内容开始位置（HDR1的开始处），相当于减少3个字节，所以是-3。</p><p><code>initialBytesToStrip</code> : 展示时需要从 Length 字段末尾开始跳过几个字节。上面例子里，因为真正的内容是从 HDR1 开始的，最终展示的内容是从 HDR2 开始的，所以中间差了3个字节，所以该值是3。</p><p>该类的解码方法比较复杂，有兴趣的同学可以试着自己分析一下。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一篇主要是结合 Netty 里的源代码讲解了 Netty 中封装成帧(Framing)的三种方式，相信你一定有了不一样的理解。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/attentionQrcode.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/toutiaoAttentionQrcode.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇介绍了粘包和半包及其通用的解决方案，今天重点来看一下 Netty 是如何实现封装成帧(Framing)方案的。&lt;br&gt;
    
    </summary>
    
      <category term="Netty" scheme="https://www.death00.top/categories/Netty/"/>
    
    
      <category term="Netty" scheme="https://www.death00.top/tags/Netty/"/>
    
      <category term="粘包" scheme="https://www.death00.top/tags/%E7%B2%98%E5%8C%85/"/>
    
      <category term="半包" scheme="https://www.death00.top/tags/%E5%8D%8A%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Netty - 粘包和半包(上)</title>
    <link href="https://www.death00.top/2019/10/23/Netty%20-%20%E7%B2%98%E5%8C%85%E5%92%8C%E5%8D%8A%E5%8C%85(%E4%B8%8A)/"/>
    <id>https://www.death00.top/2019/10/23/Netty - 粘包和半包(上)/</id>
    <published>2019-10-23T06:00:00.000Z</published>
    <updated>2019-10-23T06:01:41.325Z</updated>
    
    <content type="html"><![CDATA[<p>在网络传输中，粘包和半包应该是最长出现的问题，作为 Java 中最常使用的 NIO 网络框架 Netty，它又是如何解决的呢？今天就让我们来看看。<br><a id="more"></a></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>TCP 传输中，客户端发送数据，实际是把数据写入到了 TCP 的缓存中，粘包和半包也就会在此时产生。</p><p>客户端给服务端发送了两条消息<code>ABC</code>和<code>DEF</code>，服务端这边的接收会有多少种情况呢？有可能是一次性收到了所有的消息<code>ABCDEF</code>，有可能是收到了三条消息<code>AB</code>、<code>CD</code>、<code>EF</code>。</p><p>上面所说的一次性收到了所有的消息<code>ABCDEF</code>，类似于粘包。如果客户端发送的包的大小比 TCP 的缓存容量小，并且 TCP 缓存可以存放多个包，那么客户端和服务端的一次通信就可能传递了多个包，这时候服务端从 TCP 缓存就可能一下读取了多个包，这种现象就叫<code>粘包</code>。</p><p>上面说的后面那种收到了三条消息<code>AB</code>、<code>CD</code>、<code>EF</code>，类似于半包。如果客户端发送的包的大小比 TCP 的缓存容量大，那么这个数据包就会被分成多个包，通过 Socket 多次发送到服务端，服务端第一次从接受缓存里面获取的数据，实际是整个包的一部分，这时候就产生了<code>半包</code>(半包不是说只收到了全包的一半，是说收到了全包的一部分)。</p><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>其实从上面的定义，我们就可以大概知道产生的原因了。</p><p>粘包的主要原因：</p><ol><li>发送方每次写入数据 &lt; 套接字(Socket)缓冲区大小</li><li>接收方读取套接字(Socket)缓冲区数据不够及时</li></ol><p>半包的主要原因：</p><ol><li>发送方每次写入数据 &gt; 套接字(Socket)缓冲区大小</li><li>发送的数据大于协议的 MTU (Maximum Transmission Unit，最大传输单元)，因此必须拆包</li></ol><p>其实我们可以换个角度看待问题：</p><ol><li>从<code>收发</code>的角度看，便是一个发送可能被多次接收，多个发送可能被一次接收。</li><li>从<code>传输</code>的角度看，便是一个发送可能占用多个传输包，多个发送可能公用一个传输包。</li></ol><p>根本原因，其实是</p><blockquote><p>TCP 是流式协议，消息无边界。</p><p>(PS ： UDP 虽然也可以一次传输多个包或者多次传输一个包，但每个消息都是有边界的，因此不会有粘包和半包问题。)</p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>就像上面说的，UDP 之所以不会产生粘包和半包问题，主要是因为消息有边界，因此，我们也可以采取类似的思路。</p><h3 id="改成短连接"><a href="#改成短连接" class="headerlink" title="改成短连接"></a>改成短连接</h3><p>将 TCP 连接改成短连接，一个请求一个短连接。这样的话，建立连接到释放连接之间的消息即为传输的信息，消息也就产生了边界。</p><p>这样的方法就是十分简单，不需要在我们的应用中做过多修改。但缺点也就很明显了，效率低下，TCP 连接和断开都会涉及三次握手以及四次握手，每个消息都会涉及这些过程，十分浪费性能。</p><p>因此，并不推介这种方式。</p><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><p>封装成帧(Framing)，也就是原本发送消息的单位是缓冲大小，现在换成了帧，这样我们就可以自定义边界了。一般有4种方式：</p><h4 id="固定长度"><a href="#固定长度" class="headerlink" title="固定长度"></a>固定长度</h4><p>这种方式下，消息边界也就是固定长度即可。</p><p>优点就是实现很简单，缺点就是空间有极大的浪费，如果传递的消息中大部分都比较短，这样就会有很多空间是浪费的。</p><p>因此，这种方式一般也是不推介的。</p><h4 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h4><p>这种方式下，消息边界也就是分隔符本身。</p><p>优点是空间不再浪费，实现也比较简单。缺点是当内容本身出现分割符时需要转义，所以无论是发送还是接受，都需要进行整个内容的扫描。</p><p>因此，这种方式效率也不是很高，但可以尝试使用。</p><h4 id="专门的-length-字段"><a href="#专门的-length-字段" class="headerlink" title="专门的 length 字段"></a>专门的 length 字段</h4><p>这种方式，就有点类似 Http 请求中的 Content-Length，有一个专门的字段存储消息的长度。作为服务端，接受消息时，先解析固定长度的字段（length字段）获取消息总长度，然后读取后续内容。</p><p>优点是精确定位用户数据，内容也不用转义。缺点是长度理论上有限制，需要提前限制可能的最大长度从而定义长度占用字节数。</p><p>因次，十分推介用这种方式。</p><h4 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h4><p>其他方式就各不相同了，比如 JSON 可以看成是使用<code>{}</code>是否成对。这些优缺点就需要大家在各自的场景中进行衡量了。</p><h2 id="Netty-中的实现"><a href="#Netty-中的实现" class="headerlink" title="Netty 中的实现"></a>Netty 中的实现</h2><p>Netty 支持上文所讲的封装成帧(Framing)中的前三种方式，简单介绍下：</p><table><thead><tr><th style="text-align:left">方式</th><th style="text-align:left">解码</th><th style="text-align:left">编码</th></tr></thead><tbody><tr><td style="text-align:left">固定长度</td><td style="text-align:left">FixedLengthFrameDecoder</td><td style="text-align:left">简单</td></tr><tr><td style="text-align:left">分割符</td><td style="text-align:left">DelimiterBasedFrameDecoder</td><td style="text-align:left">简答</td></tr><tr><td style="text-align:left">专门的 length 字段</td><td style="text-align:left">LengthFieldBasedFrameDecoder</td><td style="text-align:left">LengthFieldPrepender</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天主要介绍了粘包和半包问题、解决思路和 Netty 中的支持，我会在下一篇文章里重点讲述 Netty 中的具体实现，敬请期待。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/attentionQrcode.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/toutiaoAttentionQrcode.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在网络传输中，粘包和半包应该是最长出现的问题，作为 Java 中最常使用的 NIO 网络框架 Netty，它又是如何解决的呢？今天就让我们来看看。&lt;br&gt;
    
    </summary>
    
      <category term="Netty" scheme="https://www.death00.top/categories/Netty/"/>
    
    
      <category term="Netty" scheme="https://www.death00.top/tags/Netty/"/>
    
      <category term="粘包" scheme="https://www.death00.top/tags/%E7%B2%98%E5%8C%85/"/>
    
      <category term="半包" scheme="https://www.death00.top/tags/%E5%8D%8A%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Java 面试 - ThreadLocal 原理</title>
    <link href="https://www.death00.top/2019/10/23/Java%20%E9%9D%A2%E8%AF%95%20-%20ThreadLocal%E5%8E%9F%E7%90%86/"/>
    <id>https://www.death00.top/2019/10/23/Java 面试 - ThreadLocal原理/</id>
    <published>2019-10-23T01:30:00.000Z</published>
    <updated>2019-10-22T08:57:58.314Z</updated>
    
    <content type="html"><![CDATA[<p>关于 ThreadLocal，我们经常用它来解决多线程并发问题，那它究竟是如何做到的？今天就让我们来好好看一下。<br><a id="more"></a></p><h2 id="从源码入手"><a href="#从源码入手" class="headerlink" title="从源码入手"></a>从源码入手</h2><p>首先，让我们看看 ThreadLocal 类中的介绍：</p><blockquote><p>This class provides thread-local variables. These variables differ from their normal counterparts in that each thread that accesses one (via its get or set method) has its own, independently initialized copy of the variable. ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread (e.g., a user ID or Transaction ID).</p><p>Each thread holds an implicit reference to its copy of a thread-local variable as long as the thread is alive and the ThreadLocal instance is accessible; after a thread goes away, all of its copies of thread-local instances are subject to garbage collection (unless other references to these copies exist).</p></blockquote><p>按照文中所述，ThreadLocal 提供的是线程本地变量，每个线程都有一份单独的副本，经常使用的方式是<code>私有静态变量</code>。关键在于下一段，线程存活，ThreadLocal 实例就可以被访问，线程消失，就会被垃圾回收。</p><h3 id="get-方法"><a href="#get-方法" class="headerlink" title="get()方法"></a>get()方法</h3><p>看到这儿，有没有想起上一篇内容所说的<code>引用类型</code>，有可能是<code>软引用</code>或者<code>弱引用</code>，具体是什么呢？还是来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取线程里的map</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面展示的是 ThreadLocal 中的<code>get()</code>方法，关键的 map 是在 Thread 类中的<code>threadLocals</code>变量，让我们继续看看 ThreadLocalMap 的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="comment">// 使用ThreadLocal作为key，并且是弱引用</span></span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上一篇文章所述，如果一个对象只有<code>弱引用</code>，那么当下一次 GC 进行时，该对象就会被回收。那么让我们整理一下：</p><ol><li>ThreadLocalMap 的 Entry 对 ThreadLocal 的引用为<code>弱引用</code>。</li><li>ThreadLocal 本身并不存储值，具体的 value 依旧在各个线程中。因此你可以把 ThreadLocal 看成一个工具类。</li></ol><p>但需要注意的是，Entry 中，只有key是弱引用，但 value 依旧是强引用。那会不会出现 key 被垃圾回收后，这个 map 的 key 为 null，但 value 依旧存在的情况呢？</p><h3 id="set-方法"><a href="#set-方法" class="headerlink" title="set()方法"></a>set()方法</h3><p>确实是有可能的，但 JDK 本身也做了优化，可以看看 ThreadLocalMap 的 set()方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don't use a fast path as with get() because it is at</span></span><br><span class="line">    <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">    <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用 set()的时候，ThreadLocalMap 检查到 key 为 null 的 entry 时，会将 value 也设置为 null，这样 value 之前对应的实例也可以被回收。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>先让我们看一个简单的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalSimpleDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> threads = <span class="number">3</span>;</span><br><span class="line">        InnerClass innerClass = <span class="keyword">new</span> InnerClass();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= threads; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                    innerClass.add(String.valueOf(j));</span><br><span class="line">                    innerClass.print();</span><br><span class="line">                &#125;</span><br><span class="line">                innerClass.set(<span class="string">"hello world"</span>);</span><br><span class="line">            &#125;, <span class="string">"thread - "</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 添加</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String newStr)</span> </span>&#123;</span><br><span class="line">            StringBuilder str = Counter.counter.get();</span><br><span class="line">            Counter.counter.set(str.append(newStr));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 打印</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.printf(</span><br><span class="line">                    <span class="string">"Thread name:%s , ThreadLocal hashcode:%s, Instance hashcode:%s, Value:%s\n"</span>,</span><br><span class="line">                    Thread.currentThread().getName(),</span><br><span class="line">                    Counter.counter.hashCode(),</span><br><span class="line">                    Counter.counter.get().hashCode(),</span><br><span class="line">                    Counter.counter.get().toString()</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 赋值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String words)</span> </span>&#123;</span><br><span class="line">            Counter.counter.set(<span class="keyword">new</span> StringBuilder(words));</span><br><span class="line">            System.out.printf(</span><br><span class="line">                    <span class="string">"Set, Thread name:%s , ThreadLocal hashcode:%s,  Instance hashcode:%s, Value:%s\n"</span>,</span><br><span class="line">                    Thread.currentThread().getName(),</span><br><span class="line">                    Counter.counter.hashCode(),</span><br><span class="line">                    Counter.counter.get().hashCode(),</span><br><span class="line">                    Counter.counter.get().toString()</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 初始化时是一个空的StringBuilder对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;StringBuilder&gt; counter = ThreadLocal.withInitial(StringBuilder::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其打印结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Thread name:thread - 3 , ThreadLocal hashcode:310471657, Instance hashcode:640658548, Value:0</span><br><span class="line">Thread name:thread - 2 , ThreadLocal hashcode:310471657, Instance hashcode:126253473, Value:0</span><br><span class="line">Thread name:thread - 2 , ThreadLocal hashcode:310471657, Instance hashcode:126253473, Value:01</span><br><span class="line">Thread name:thread - 2 , ThreadLocal hashcode:310471657, Instance hashcode:126253473, Value:012</span><br><span class="line">Thread name:thread - 2 , ThreadLocal hashcode:310471657, Instance hashcode:126253473, Value:0123</span><br><span class="line">Thread name:thread - 1 , ThreadLocal hashcode:310471657, Instance hashcode:829132711, Value:0</span><br><span class="line">Thread name:thread - 1 , ThreadLocal hashcode:310471657, Instance hashcode:829132711, Value:01</span><br><span class="line">Thread name:thread - 1 , ThreadLocal hashcode:310471657, Instance hashcode:829132711, Value:012</span><br><span class="line">Thread name:thread - 1 , ThreadLocal hashcode:310471657, Instance hashcode:829132711, Value:0123</span><br><span class="line">Set, Thread name:thread - 1 , ThreadLocal hashcode:310471657,  Instance hashcode:820066274, Value:hello world</span><br><span class="line">Thread name:thread - 3 , ThreadLocal hashcode:310471657, Instance hashcode:640658548, Value:01</span><br><span class="line">Thread name:thread - 3 , ThreadLocal hashcode:310471657, Instance hashcode:640658548, Value:012</span><br><span class="line">Set, Thread name:thread - 2 , ThreadLocal hashcode:310471657,  Instance hashcode:155293473, Value:hello world</span><br><span class="line">Thread name:thread - 3 , ThreadLocal hashcode:310471657, Instance hashcode:640658548, Value:0123</span><br><span class="line">Set, Thread name:thread - 3 , ThreadLocal hashcode:310471657,  Instance hashcode:1804272849, Value:hello world</span><br></pre></td></tr></table></figure></p><p>可以看出，我们在使用 ThreadLocal 时，用的是同一个对象，但各个线程对应的实例是不一样的。而在调用 set() 方法后，对应的实例会被替换。</p><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>对于 Java Web 应用而言，Session 保存了很多信息。很多时候需要通过 Session 获取信息，有些时候又需要修改 Session 的信息。一方面，需要保证每个线程有自己单独的 Session 实例。另一方面，由于很多地方都需要操作 Session，存在多方法共享 Session 的需求。使用 ThreadLocal 进行实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Session&gt; session = ThreadLocal.&lt;Session&gt;withInitial(() -&gt; <span class="keyword">new</span> Session());</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Data</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Session</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String user;</span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> session.get().getUser();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> session.get().getStatus();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStatus</span><span class="params">(String status)</span> </span>&#123;</span><br><span class="line">    session.get().setStatus(status);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      SessionHandler handler = <span class="keyword">new</span> SessionHandler();</span><br><span class="line">      handler.getStatus();</span><br><span class="line">      handler.getUser();</span><br><span class="line">      handler.setStatus(<span class="string">"close"</span>);</span><br><span class="line">      handler.getStatus();</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ThreadLocal 使用起来虽然简单，但考虑到其设计确实很精巧，值得了解一下。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/attentionQrcode.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/toutiaoAttentionQrcode.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于 ThreadLocal，我们经常用它来解决多线程并发问题，那它究竟是如何做到的？今天就让我们来好好看一下。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.death00.top/tags/Java/"/>
    
      <category term="ThreadLocal" scheme="https://www.death00.top/tags/ThreadLocal/"/>
    
      <category term="弱引用" scheme="https://www.death00.top/tags/%E5%BC%B1%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java 面试 - 四种引用类型</title>
    <link href="https://www.death00.top/2019/10/22/Java%20%E9%9D%A2%E8%AF%95%20-%20%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>https://www.death00.top/2019/10/22/Java 面试 - 四种引用类型/</id>
    <published>2019-10-22T01:30:00.000Z</published>
    <updated>2019-10-22T06:05:01.944Z</updated>
    
    <content type="html"><![CDATA[<p>之前我们提到过 GC，但当 Java 中引用的对象越来越多，会导致内存空间不足，最终会产生错误 OutOfMemoryError，并让应用程序终止。那为什么 GC 在此时不能多收集一些对象呢？这就和今天说的引用类型有关了。<br><a id="more"></a></p><p>首先，从 JDK1.2 开始，对象的引用被划分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：<code>强引用</code>、<code>软引用</code>、<code>弱引用</code>和<code>虚引用</code>。</p><h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>强引用(Strong Reference)是使用最普遍的引用。如果一个对象具有强引用，那么它永远不会被 GC。例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object strongReference = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure></p><p>当内存空间不足时，JVM 宁愿抛出<code>OutOfMemoryError</code>，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。</p><p>如果强引用对象不使用时，需要弱化从而可以被 GC，例如<code>ArrayList</code>中的<code>clear()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes all of the elements from this list.  The list will</span></span><br><span class="line"><span class="comment"> * be empty after this call returns.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>显式地设置强引用对象为<code>null</code>，或让其超出对象的生命周期范围，则垃圾回收器认为该对象不存在引用，就会回收这个对象。具体什么时候收集这要取决于具体的垃圾回收器。</p><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>如果一个对象只具有软引用(Soft Reference)，当内存空间充足时，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。让我们来看一个例子具体了解一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">SoftReference&lt;String&gt; softReference = <span class="keyword">new</span> SoftReference&lt;&gt;(str);</span><br><span class="line">String result = softReference.get();</span><br></pre></td></tr></table></figure></p><p>让我们来看一下<code>get()</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T o = <span class="keyword">super</span>.get();</span><br><span class="line">    <span class="comment">// timestamp代表上一次软引用上一次被使用的时间(初始化、get())</span></span><br><span class="line">    <span class="comment">// clock代表上一次GC的时间</span></span><br><span class="line">    <span class="keyword">if</span> (o != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.timestamp != clock)</span><br><span class="line">        <span class="keyword">this</span>.timestamp = clock;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因此，<code>软引用</code>在被垃圾回收时，也遵循<code>LRU法则</code>，优先回收最近最少被使用的对象进行回收。</p><p>软引用的使用场景多是<code>内存敏感的高速缓存</code>。具体来说，就是我们希望将数据存放到缓存中，这样可以快速进行读取。但是，当 JVM 中内存不够用时，我们又不希望缓存数据会占用到 JVM 的内存。例如配合<code>ReferenceQueue</code>，如果软引用所引用对象被垃圾回收，JVM 就会把这个软引用加入到与之关联的引用队列中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue&lt;String&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">SoftReference&lt;String&gt; softReference = <span class="keyword">new</span> SoftReference&lt;&gt;(str, referenceQueue);</span><br><span class="line"></span><br><span class="line">str = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// Notify GC</span></span><br><span class="line">System.gc();</span><br><span class="line"></span><br><span class="line">System.out.println(softReference.get()); <span class="comment">// abc</span></span><br><span class="line"></span><br><span class="line">Reference&lt;? extends String&gt; reference = referenceQueue.poll();</span><br><span class="line">System.out.println(reference); <span class="comment">//null</span></span><br></pre></td></tr></table></figure></p><p>但是需要注意的时，如果使用软引用缓存，有可能导致<code>Full GC</code>增多。</p><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>如果一个对象只具有弱引用(Weak Reference)，其生命周期相比于软引用更加短暂。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会对它进行回收。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。其使用为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">WeakReference&lt;String&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(str);</span><br><span class="line">str = weakReference.get();</span><br></pre></td></tr></table></figure></p><p>讲到弱引用，就不得不提到<code>WeakHashMap</code>。和<code>HashMap</code>相比，当我们给 JVM 分配的内存不足的时候，HashMap 宁可抛出 OutOfMemoryError 异常，也不会回收其相应的没有被引用的对象，而 WeakHashMap 则会回收存储在其中但有被引用的对象。</p><p>WeakHashMap 通过将一些没有被引用的键的值赋值为 null ，这样的话就会告知GC去回收这些存储的值了。假如我们特地传入 key 为 null 的键，WeakHashMap 会将键设置为特殊的 Oject，源码为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    // key会被重新赋值</span><br><span class="line">    Object k = maskNull(key);</span><br><span class="line">    int h = hash(k);</span><br><span class="line">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class="line">    int i = indexFor(h, tab.length);</span><br><span class="line"></span><br><span class="line">    for (Entry&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123;</span><br><span class="line">        if (h == e.hash &amp;&amp; eq(k, e.get())) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (value != oldValue)</span><br><span class="line">                e.value = value;</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    Entry&lt;K,V&gt; e = tab[i];</span><br><span class="line">    tab[i] = new Entry&lt;&gt;(k, value, queue, h, e);</span><br><span class="line">    if (++size &gt;= threshold)</span><br><span class="line">        resize(tab.length * 2);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Value representing null keys inside tables.</span><br><span class="line"> * 特殊的key</span><br><span class="line"> */</span><br><span class="line">private static final Object NULL_KEY = new Object();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Use NULL_KEY for key if it is null.</span><br><span class="line"> */</span><br><span class="line">private static Object maskNull(Object key) &#123;</span><br><span class="line">    return (key == null) ? NULL_KEY : key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>虚引用(PhantomReference),顾名思义，就是形同虚设。与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p><p>虚引用主要用来跟踪对象被垃圾回收器回收的活动。 虚引用与软引用和弱引用的一个区别在于：</p><blockquote><p>虚引用必须和引用队列(ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p></blockquote><p>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">ReferenceQueue queue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line"><span class="comment">// 创建虚引用，要求必须与一个引用队列关联</span></span><br><span class="line">PhantomReference pr = <span class="keyword">new</span> PhantomReference(str, queue);</span><br></pre></td></tr></table></figure></p><p>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要进行垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动，也可以理解为一种回调方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java 中4种引用的级别和强度由高到低依次为：<code>强引用</code> -&gt; <code>软引用</code> -&gt; <code>弱引用</code> -&gt; <code>虚引用</code></p><p>通过表格，说明其特性：</p><table><thead><tr><th style="text-align:left">引用类型</th><th style="text-align:left">被垃圾回收的时间</th><th style="text-align:left">使用场景</th><th style="text-align:left">生存时间</th></tr></thead><tbody><tr><td style="text-align:left">强引用</td><td style="text-align:left">从来不会</td><td style="text-align:left">对象的一般状态</td><td style="text-align:left">JVM停止运行时</td></tr><tr><td style="text-align:left">软引用</td><td style="text-align:left">内存不足时</td><td style="text-align:left">对象缓存</td><td style="text-align:left">内存不足时</td></tr><tr><td style="text-align:left">弱引用</td><td style="text-align:left">正常垃圾回收时</td><td style="text-align:left">对象缓存</td><td style="text-align:left">垃圾回收后终止</td></tr><tr><td style="text-align:left">虚引用</td><td style="text-align:left">正常垃圾回收时</td><td style="text-align:left">跟踪对象的垃圾回收</td><td style="text-align:left">垃圾回收后终止</td></tr></tbody></table><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/attentionQrcode.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/toutiaoAttentionQrcode.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前我们提到过 GC，但当 Java 中引用的对象越来越多，会导致内存空间不足，最终会产生错误 OutOfMemoryError，并让应用程序终止。那为什么 GC 在此时不能多收集一些对象呢？这就和今天说的引用类型有关了。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.death00.top/tags/Java/"/>
    
      <category term="弱引用" scheme="https://www.death00.top/tags/%E5%BC%B1%E5%BC%95%E7%94%A8/"/>
    
      <category term="强引用" scheme="https://www.death00.top/tags/%E5%BC%BA%E5%BC%95%E7%94%A8/"/>
    
      <category term="软引用" scheme="https://www.death00.top/tags/%E8%BD%AF%E5%BC%95%E7%94%A8/"/>
    
      <category term="虚引用" scheme="https://www.death00.top/tags/%E8%99%9A%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java 面试 - 垃圾回收（下）</title>
    <link href="https://www.death00.top/2019/10/21/Java%20%E9%9D%A2%E8%AF%95%20-%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>https://www.death00.top/2019/10/21/Java 面试 - 垃圾回收（下）/</id>
    <published>2019-10-21T01:30:00.000Z</published>
    <updated>2019-10-21T00:52:29.174Z</updated>
    
    <content type="html"><![CDATA[<p>接着上一篇，介绍完了 JVM 中识别需要回收的垃圾对象之后，这一篇我们来说说 JVM 是如何进行垃圾回收。<br><a id="more"></a></p><p>首先要在这里介绍一下<code>80/20 法则</code>:</p><blockquote><p>约仅有20%的变因操纵着80%的局面。也就是说：所有变量中，最重要的仅有20%，虽然剩余的80%占了多数，控制的范围却远低于“关键的少数”。</p></blockquote><p>Java 对象的生命周期也满足也这样的定律，即大部分的 Java 对象只存活一小段时间，而存活下来的小部分 Java 对象则会存活很长一段时间。</p><p>因此，这也就造就了 JVM 中<code>分代回收</code>的思想。简单来说，就是将堆空间划分为两代，分别叫做<code>新生代</code>和<code>老年代</code>。新生代用来存储新建的对象。当对象存活时间够长时，则将其移动到老年代。</p><p>这样也就可以让 JVM 给不同代使用不同的回收算法。</p><p>对于新生代，我们猜测大部分的 Java 对象只存活一小段时间，那么便可以频繁地采用耗时较短的垃圾回收算法，让大部分的垃圾都能够在新生代被回收掉。</p><p>对于老年代，我们猜测大部分的垃圾已经在新生代中被回收了，而在老年代中的对象有大概率会继续存活。当真正触发针对老年代的回收时，则代表这个假设出错了，或者堆的空间已经耗尽了。此时，JVM 往往需要做一次全堆扫描，耗时也将不计成本。（当然，现代的垃圾回收器都在并发收集的道路上发展，来避免这种全堆扫描的情况。）</p><p>那么，我们先来看看 JVM 中堆究竟是如何划分的。</p><h2 id="堆划分"><a href="#堆划分" class="headerlink" title="堆划分"></a>堆划分</h2><p>按照上文所述，JVM 将堆划分为新生代和老年代，其中，新生代又被划分为 Eden 区，以及两个大小相同的 Survivor 区。</p><p><img src="https://github.com/death00/gitment-comments/blob/master/imgs/2019101901.png?raw=true" alt=""></p><p>通常来说，当我们调用 new 指令时，它会在 Eden 区中划出一块作为存储对象的内存。由于堆空间是线程共享的，因此直接在这里边划空间是需要进行同步的。否则，将有可能出现两个对象共用一段内存的事故。</p><p>JVM 的解决方法是为每个线程预先申请一段连续的堆空间，并且只允许每个线程在自己申请过的堆空间中创建对象，如果申请的堆空间被用完了，那么再继续申请即可，这也就是 TLAB（Thread Local Allocation Buffer，对应虚拟机参数 -XX:+UseTLAB，默认开启）。</p><p>此时，如果线程操作涉及到加锁，则该线程需要维护两个指针（实际上可能更多，但重要也就两个），一个指向 TLAB 中空余内存的起始位置，一个则指向 TLAB 末尾。</p><p>接下来的 new 指令，便可以直接通过指针加法（bump the pointer）来实现，即把指向空余内存位置的指针加上所请求的字节数。</p><p>如果加法后空余内存指针的值仍小于或等于指向末尾的指针，则代表分配成功。否则，TLAB 已经没有足够的空间来满足本次新建操作。这个时候，便需要当前线程重新申请新的 TLAB。</p><p>那有没有可能出现申请不到的情况呢？有的，这个时候就会触发<code>Minor GC</code>了。</p><h2 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h2><p>所谓 Minor GC，就是指：</p><blockquote><p>当 Eden 区的空间耗尽时，JVM 会进行一次 Minor GC，来收集新生代的垃圾。存活下来的对象，则会被送到 Survivor 区。</p></blockquote><p>上文提到，新生代共有两个 Survivor 区，我们分别用 from 和 to 来指代。其中 to 指向的 Survivior 区是空的。</p><p>当发生 Minor GC 时，Eden 区和 from 指向的 Survivor 区中的存活对象会被复制到 to 指向的 Survivor 区中，然后交换 from 和 to 指针，以保证下一次 Minor GC 时，to 指向的 Survivor 区还是空的。</p><p>JVM 会记录 Survivor 区中每个对象一共被来回复制了几次。如果一个对象被复制的次数为 15（对应虚拟机参数 -XX:+MaxTenuringThreshold），那么该对象将被晋升（promote）至老年代。</p><p>另外，如果单个 Survivor 区已经被占用了 50%（对应虚拟机参数 -XX:TargetSurvivorRatio），那么较高复制次数的对象也会被晋升至老年代。</p><p>总而言之，当发生 Minor GC 时，我们应用了<code>标记 - 复制</code>算法，将 Survivor 区中的老存活对象晋升到老年代，然后将剩下的存活对象和 Eden 区的存活对象复制到另一个 Survivor 区中。理想情况下，Eden 区中的对象基本都死亡了，那么需要复制的数据将非常少，因此采用这种<code>标记 - 复制</code>算法的效果极好。</p><p>Minor GC 的另外一个好处是不用对整个堆进行垃圾回收。但是，它却有一个问题，那就是老年代中的对象可能引用新生代的对象。也就是说，在标记存活对象的时候，我们需要扫描老年代中的对象。如果该对象拥有对新生代对象的引用，那么这个引用也会被作为 GC Roots。这样一来，岂不是又做了一次全堆扫描呢？</p><p>为了避免扫描全堆，JVM 引入了名为<code>卡表</code>的技术，大致地标出可能存在老年代到新生代引用的内存区域。有兴趣的朋友可以去详细了解一下，这里限于篇幅，就不具体介绍了。</p><h2 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h2><p>那什么时候会发生<code>Full GC</code>呢？针对不同的垃圾收集器，Full GC 的触发条件可能不都一样。按 HotSpot VM 的 serial GC 的实现来看，触发条件是:</p><blockquote><p>当准备要触发一次 Minor GC 时，如果发现统计数据说之前 Minor GC 的平均晋升大小比目前老年代剩余的空间大，则不会触发 Minor GC 而是转为触发 Full GC。</p><p>因为 HotSpot VM 的 GC 里，除了垃圾回收器 CMS 能单独收集老年代之外，其他的 GC 都会同时收集整个堆，所以不需要事先准备一次单独的 Minor GC。</p></blockquote><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>基础的回收方式有三种：<code>清除</code>、<code>压缩</code>、<code>复制</code>，接下来让我们来一一了解一下。</p><h3 id="清除"><a href="#清除" class="headerlink" title="清除"></a>清除</h3><p>所谓清除，就是把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。</p><p>其原理十分简单，但是有两个缺点：</p><ol><li>会造成内存碎片。由于 JVM 的堆中对象必须是连续分布的，因此可能出现总空闲内存足够，但是无法分配的极端情况。</li><li>分配效率较低。如果是一块连续的内存空间，那么我们可以通过指针加法（pointer bumping）来做分配。而对于空闲列表，JVM 则需要逐个访问空闲列表中的项，来查找能够放入新建对象的空闲内存。</li></ol><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>所谓压缩，就是把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。</p><p>这种做法能够解决内存碎片化的问题，但代价是压缩算法的性能开销，因此分配效率问题依旧没有解决。</p><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>所谓复制，就是把内存区域平均分为两块，分别用两个指针 from 和 to 来维护，并且只是用 from 指针指向的内存区域来分配内存。当发生垃圾回收时，便把存活的对象复制到 to 指针所指向的内存区域中，并且交换 from 指针和 to 指针的内容。</p><p>这种回收方式同样能够解决内存碎片化的问题，但是它的缺点也极其明显，即堆空间的使用效率极其低下。</p><h3 id="具体垃圾收集器"><a href="#具体垃圾收集器" class="headerlink" title="具体垃圾收集器"></a>具体垃圾收集器</h3><p>针对<code>新生代</code>的垃圾回收器共有三个：Serial ，Parallel Scavenge 和 Parallel New。这三个采用的都是<code>标记 - 复制</code>算法。</p><p>其中，Serial 是一个单线程的，Parallel New 可以看成是 Serial 的多线程版本，Parallel Scavenge 和 Parallel New 类似，但更加注重吞吐率。此外，Parallel Scavenge 不能与 CMS 一起使用。</p><p>针对<code>老年代</code>的垃圾回收器也有三个：Serial Old ，Parallel Old 和 CMS。</p><p>Serial Old 和 Parallel Old 都是<code>标记 - 压缩</code>算法。同样，前者是单线程的，而后者可以看成前者的多线程版本。</p><p>CMS 采用的是<code>标记 - 清除</code>算法，并且是并发的。除了少数几个操作需要 STW(Stop the world) 之外，它可以在应用程序运行过程中进行垃圾回收。在并发收集失败的情况下，JVM 会使用其他两个压缩型垃圾回收器进行一次垃圾回收。由于 G1 的出现，CMS 在 Java 9 中已被废弃。</p><p>G1（Garbage First）是一个横跨新生代和老年代的垃圾回收器。实际上，它已经打乱了前面所说的堆结构，直接将堆分成极其多个区域。每个区域都可以充当 Eden 区、Survivor 区或者老年代中的一个。它采用的是<code>标记 - 压缩</code>算法，而且和 CMS 一样都能够在应用程序运行过程中并发地进行垃圾回收。</p><p>G1 能够针对每个细分的区域来进行垃圾回收。在选择进行垃圾回收的区域时，它会优先回收死亡对象较多的区域。这也是 G1 名字的由来。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章主要讲述的是 JVM 中具体的垃圾回收方法，从对象的生存规律，引出回收方法，结合多线程的特点，逐步优化，最终产生了我们现在所能知道各种垃圾收集器。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/attentionQrcode.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/toutiaoAttentionQrcode.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接着上一篇，介绍完了 JVM 中识别需要回收的垃圾对象之后，这一篇我们来说说 JVM 是如何进行垃圾回收。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.death00.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://www.death00.top/tags/JVM/"/>
    
      <category term="GC" scheme="https://www.death00.top/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>Java 面试 - 垃圾回收（上）</title>
    <link href="https://www.death00.top/2019/10/20/Java%20%E9%9D%A2%E8%AF%95%20-%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>https://www.death00.top/2019/10/20/Java 面试 - 垃圾回收（上）/</id>
    <published>2019-10-20T01:30:00.000Z</published>
    <updated>2019-10-21T00:52:05.454Z</updated>
    
    <content type="html"><![CDATA[<p>Java 中的垃圾回收，常常是由 JVM 帮我们做好的。虽然这节省了大家很多的学习的成本，提高了项目的执行效率，但是当项目变得越来越复杂，用户量越来越大时，还是需要我们懂得垃圾回收机制，这样也能进行更深一步的优化。<br><a id="more"></a></p><h2 id="辨别对象存亡"><a href="#辨别对象存亡" class="headerlink" title="辨别对象存亡"></a>辨别对象存亡</h2><p>垃圾回收( Garbage Collection，以下简称 GC )，从字面上理解，就是将已经分配出去的，但却不再使用的内存回收回来，以便能够再次分配。</p><p>在 JVM 中，垃圾就是指的死亡对象所占据的堆空间( GC 是发生在堆空间中)，那么我们如果辨别一个对象是否死亡呢？JVM 使用的是<code>引用计数法</code>和<code>可达性分析</code>。</p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>引用计数法( Reference Counting)，是为每个对象添加一个引用计数器，用来统计引用该对象的个数。一旦某个对象的引用计数器为0，则说明该对象已经死亡，便可以被回收了。</p><p>其具体实现为：</p><blockquote><p>如果有一个引用，被赋值为某一对象，那么将该对象的引用计数器 +1。</p><p>如果一个指向某一对象的引用，被赋值为其他值，那么将该对象的引用计数器 -1。</p><p>也就是说，我们需要截获所有的引用更新操作，并且相应地增减目标对象的引用计数器。</p></blockquote><p>看似很简单的实现，其实里面有不少缺陷：</p><ol><li>需要额外的空间来存储计数器。</li><li>计数器的更新操作十分繁琐。</li><li>最重要的：无法处理循环引用对象。</li></ol><p>针对第3点，举个例子特别说明一下：</p><p>假设对象 a 与 b 相互引用，除此之外没有其他引用指向他们。在这种情况下，a 和 b 实际上已经死了。</p><p>但由于它们的引用计数器皆不为0（因为相互引用，两者均为1），在引用计数法的计算中，这两个对象还活着。因此，这些循环引用对象所占据的空间将不可回收，从而造成了<code>内存泄露</code>。</p><h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>可达性分析( Reachability Analysis )，是目前 JVM 主要采取的判定对象死亡的方法。实质在于将一系列<code>GC Roots</code>作为初始的存活对象合集（live set），然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。</p><p>那么什么是<code>GC Roots</code>呢？我们可以暂时理解为由堆外指向堆内的引用，一般而言，GC Roots 包括（但不限于）如下几种：</p><ol><li>Java 方法栈桢中的局部变量</li><li>已加载类的静态变量</li><li>JNI handles</li><li>已启动且未停止的 Java 线程</li></ol><p>之前我们说<code>引用计数法</code>会有循环引用的问题，<code>可达性分析</code>就不会了。举例来说，即便对象 a 和 b 相互引用，只要从 GC Roots 出发无法到达 a 或者 b，那么可达性分析便会认为它们已经死亡。</p><p>那<code>可达性分析</code>有没有什么缺点呢？有的，在多线程环境下，其他线程可能会更新已经分析过的对象中的引用，从而造成误报（将引用设置为 null）或者漏报（将引用设置为未被访问过的对象）。</p><p>误报并没有什么伤害，JVM 至多损失了部分垃圾回收的机会。漏报则比较麻烦，因为垃圾回收器可能回收事实上仍被引用的对象内存。一旦从原引用访问已经被回收了的对象，则很有可能会直接导致 JVM 崩溃。</p><h3 id="STW"><a href="#STW" class="headerlink" title="STW"></a>STW</h3><p>既然<code>可达性分析</code>在多线程下有缺点，那 JVM 是如何解决的呢？答案便是 Stop-the-world(以下简称<code>JWT</code>)，停止了其他非垃圾回收线程的工作直到完成垃圾回收。这也就造成了垃圾回收所谓的暂停时间（GC pause）。</p><p>那 SWT 是如何实现的呢？当 JVM 收到 SWT 请求后，它会等待所有的线程都到达安全点（Safe Point），才允许请求 SWT 的线程进行独占的工作。</p><p>那什么又叫安全点呢？安全点是 JVM 能找到一个稳定的执行状态，在这个执行状态下，JVM 的堆栈不会发生变化。</p><p>这么一来，垃圾回收器便能够“安全”地执行可达性分析，所有存活的对象也都可以成功被标记，那么之后就可以将死亡的对象进行垃圾回收了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上便是发现死亡对象的过程，这也为之后的垃圾回收进行铺垫，具体的垃圾回收过程，我会在下一篇文章中讲述，敬请期待。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/attentionQrcode.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/toutiaoAttentionQrcode.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java 中的垃圾回收，常常是由 JVM 帮我们做好的。虽然这节省了大家很多的学习的成本，提高了项目的执行效率，但是当项目变得越来越复杂，用户量越来越大时，还是需要我们懂得垃圾回收机制，这样也能进行更深一步的优化。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.death00.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://www.death00.top/tags/JVM/"/>
    
      <category term="GC" scheme="https://www.death00.top/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>Java 面试-即时编译( JIT )</title>
    <link href="https://www.death00.top/2019/10/14/Java%20%E9%9D%A2%E8%AF%95-%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91(%20JIT%20)%20/"/>
    <id>https://www.death00.top/2019/10/14/Java 面试-即时编译( JIT ) /</id>
    <published>2019-10-14T01:30:00.000Z</published>
    <updated>2019-10-18T10:03:15.709Z</updated>
    
    <content type="html"><![CDATA[<p>当我们在写代码时，一个方法内部的行数自然是越少越好，这样逻辑清晰、方便阅读，其实好处远不止如此，通过即时编译，甚至可以提高执行时的性能，今天就让我们好好来了解一下其中的原理。<br><a id="more"></a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>当 JVM 的初始化完成后，类在调用执行过程中，执行引擎会把字节码转为机器码，然后在操作系统中才能执行。在字节码转换为机器码的过程中，虚拟机中还存在着一道编译，那就是<code>即时编译</code>。</p><p>最初，JVM 中的字节码是由解释器（ Interpreter ）完成编译的，当虚拟机发现某个方法或代码块的运行特别频繁的时候，就会把这些代码认定为<code>热点代码</code>。</p><p>为了提高热点代码的执行效率，在运行时，即时编译器（JIT，Just In Time）会把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，然后保存到内存中。</p><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>在 HotSpot 虚拟机中，内置了两种 JIT，分别为<code>C1 编译器</code>和<code>C2 编译器</code>，这两个编译器的编译过程是不一样的。</p><h2 id="C1-编译器"><a href="#C1-编译器" class="headerlink" title="C1 编译器"></a>C1 编译器</h2><p>C1 编译器是一个简单快速的编译器，主要的关注点在于局部性的优化，适用于执行时间较短或对启动性能有要求的程序，也称为<code>Client Compiler</code>，例如，GUI 应用对界面启动速度就有一定要求。</p><h2 id="C2-编译器"><a href="#C2-编译器" class="headerlink" title="C2 编译器"></a>C2 编译器</h2><p>C2 编译器是为长期运行的服务器端应用程序做性能调优的编译器，适用于执行时间较长或对峰值性能有要求的程序，也称为<code>Server Compiler</code>，例如，服务器上长期运行的 Java 应用对稳定运行就有一定的要求。</p><h2 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h2><p>在 Java7 之前，需要根据程序的特性来选择对应的 JIT，虚拟机默认采用解释器和其中一个编译器配合工作。</p><p>Java7 引入了分层编译，这种方式综合了 C1 的启动性能优势和 C2 的峰值性能优势，我们也可以通过参数 <code>-client</code>或者<code>-server</code> 强制指定虚拟机的即时编译模式。</p><p>分层编译将 JVM 的执行状态分为了 5 个层次：</p><blockquote><p>第 0 层：程序解释执行，默认开启性能监控功能（Profiling），如果不开启，可触发第二层编译；</p><p>第 1 层：可称为 C1 编译，将字节码编译为本地代码，进行简单、可靠的优化，不开启 Profiling；</p><p>第 2 层：也称为 C1 编译，开启 Profiling，仅执行带方法调用次数和循环回边执行次数 profiling 的 C1 编译；</p><p>第 3 层：也称为 C1 编译，执行所有带 Profiling 的 C1 编译；</p><p>第 4 层：可称为 C2 编译，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。</p></blockquote><p>对于 C1 的三种状态，按执行效率从高至低：第 1 层、第 2层、第 3层。</p><p>通常情况下，C2 的执行效率比 C1 高出30%以上。</p><p>在 Java8 中，默认开启分层编译，<code>-client</code> 和 <code>-server</code> 的设置已经是无效的了。如果只想开启 C2，可以关闭分层编译（<code>-XX:-TieredCompilation</code>），如果只想用 C1，可以在打开分层编译的同时，使用参数：<code>-XX:TieredStopAtLevel=1</code>。</p><p>你可以通过 <code>java -version</code>命令行可以直接查看到当前系统使用的编译模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;java -version</span><br><span class="line">java version &quot;1.8.0_45&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_45-b14)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.45-b02, mixed mode)</span><br></pre></td></tr></table></figure></p><p><code>mixed mode</code>代表是默认的混合编译模式，除了这种模式外，我们还可以使用<code>-Xint</code>参数强制虚拟机运行于只有解释器的编译模式下，这时 JIT 完全不介入工作；也可以使用参数<code>-Xcomp</code>强制虚拟机运行于只有 JIT 的编译模式下。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;java -Xint -version</span><br><span class="line">java version &quot;1.8.0_45&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_45-b14)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.45-b02, interpreted mode)</span><br><span class="line"></span><br><span class="line">C:\Users\Administrator&gt;java -Xcomp -version</span><br><span class="line">java version &quot;1.8.0_45&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_45-b14)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.45-b02, compiled mode)</span><br></pre></td></tr></table></figure></p><h1 id="触发标准"><a href="#触发标准" class="headerlink" title="触发标准"></a>触发标准</h1><p>在 HotSpot 虚拟机中，<code>热点探测</code>是 JIT 的触发标准。</p><blockquote><p>热点探测是基于计数器的热点探测，采用这种方法的虚拟机会为每个方法建立计数器统计方法的执行次数，如果执行次数超过一定的阈值就认为它是“热点方法” 。</p></blockquote><p>虚拟机为每个方法准备了两类计数器：方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阈值，当计数器超过阈值溢出了，就会触发 JIT 编译。</p><h2 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h2><p>方法调用计数器用于统计方法被调用的次数，默认阈值在 C1 模式下是 1500 次，在 C2 模式在是 10000 次，可通过<code>-XX: CompileThreshold</code>来设定；而在分层编译的情况下<code>-XX: CompileThreshold</code>指定的阈值将失效，此时将会根据当前待编译的方法数以及编译线程数来动态调整。当方法计数器和回边计数器之和超过方法计数器阈值时，就会触发 JIT 编译器。</p><h2 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h2><p>回边计数器用于统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge），该值用于计算是否触发 C1 编译的阈值，在不开启分层编译的情况下，C1 默认为 13995，C2 默认为 10700，可通过<code>-XX: OnStackReplacePercentage=N</code>来设置；而在分层编译的情况下，<code>-XX: OnStackReplacePercentage</code>指定的阈值同样会失效，此时将根据当前待编译的方法数以及编译线程数来动态调整。</p><p>建立回边计数器的主要目的是为了触发 OSR（On StackReplacement）编译，即栈上编译。在一些循环周期比较长的代码段中，当循环达到回边计数器阈值时，JVM 会认为这段是热点代码，JIT 编译器就会将这段代码编译成机器语言并缓存，在该循环时间段内，会直接将执行代码替换，执行缓存的机器语言。</p><h1 id="优化技术"><a href="#优化技术" class="headerlink" title="优化技术"></a>优化技术</h1><p>JIT 编译运用了一些经典的编译优化技术来实现代码的优化，即通过一些例行检查优化，可以智能地编译出运行时的最优性能代码。主要有两种：<code>方法内联</code>、<code>逃逸分析</code>。</p><h2 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h2><p>调用一个方法通常要经历压栈和出栈。调用方法是将程序执行顺序转移到存储该方法的内存地址，将方法的内容执行完后，再返回到执行该方法前的位置。</p><p>这种执行操作要求在执行前保护现场并记忆执行的地址，执行后要恢复现场，并按原来保存的地址继续执行。 因此，方法调用会产生一定的时间和空间方面的开销（其实可以理解为一种<code>上下文切换</code>的精简版）。</p><p>那么对于那些方法体代码不是很大，又频繁调用的方法来说，这个时间和空间的消耗会很大。</p><p>方法内联的优化行为就是把目标方法的代码复制到发起调用的方法之中，避免发生真实的方法调用。</p><p>JVM 会自动识别热点方法，并对它们使用方法内联进行优化。我们可以通过<code>-XX:CompileThreshold</code>来设置热点方法的阈值。但要强调一点，热点方法不一定会被 JVM 做内联优化，如果这个方法体太大了，JVM 将不执行内联操作。而方法体的大小阈值，我们也可以通过参数设置来优化：</p><ol><li>经常执行的方法，默认情况下，方法体大小小于 325 字节的都会进行内联，我们可以通过<code>-XX:MaxFreqInlineSize=N</code>来设置大小值；</li><li>不是经常执行的方法，默认情况下，方法大小小于 35 字节才会进行内联，我们也可以通过<code>-XX:MaxInlineSize=N</code>来重置大小值。</li></ol><p>之后我们就可以通过配置 JVM 参数来查看到方法被内联的情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 在控制台打印编译过程信息</span><br><span class="line">-XX:+PrintCompilation</span><br><span class="line">// 解锁对 JVM 进行诊断的选项参数。默认是关闭的，开启后支持一些特定参数对 JVM 进行诊断</span><br><span class="line">-XX:+UnlockDiagnosticVMOptions</span><br><span class="line">// 将内联方法打印出来</span><br><span class="line">-XX:+PrintInlining</span><br></pre></td></tr></table></figure></p><p>热点方法的优化可以有效提高系统性能，一般我们可以通过以下几种方式来提高方法内联：</p><ol><li>通过设置 JVM 参数来减小热点阈值或增加方法体阈值，以便更多的方法可以进行内联，但这种方法意味着需要占用更多地内存；</li><li>在编程中，避免在一个方法中写大量代码，习惯使用小方法体；</li><li>尽量使用 final、private、static 关键字修饰方法，编码方法因为继承，会需要额外的类型检查。</li></ol><blockquote><p>此处就联系到了最开始提出的观点，一个方法中的内容越少，当该方法经常被执行时，则容易进行方法内联，从而优化性能。</p></blockquote><h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>逃逸分析（Escape Analysis）是判断一个对象是否被外部方法引用或外部线程访问的分析技术，编译器会根据逃逸分析的结果对代码进行优化。</p><p>可以通过JVM参数进行设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+DoEscapeAnalysis 开启逃逸分析（jdk1.8 默认开启）</span><br><span class="line">-XX:-DoEscapeAnalysis 关闭逃逸分析</span><br></pre></td></tr></table></figure></p><p>其具体优化方法主要有三种：<code>栈上分配</code>、<code>锁消除</code>、<code>标量替换</code>。</p><h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><p>在 Java 中默认创建一个对象是在堆中分配内存的，而当堆内存中的对象不再使用时，则需要通过垃圾回收机制回收，这个过程相对分配在栈中的对象的创建和销毁来说，更消耗时间和性能。</p><p>这个时候，逃逸分析如果发现一个对象只在方法中使用，就会将对象分配在栈上。</p><p>但是，HotSpot 虚拟机目前的实现导致栈上分配实现比较复杂，可以说，在 HotSpot 中暂时没有实现这项优化，所以大家可能暂时无法体会到这种优化（我看的资料显示在 Java8 中还没有实现，如果大家有什么其他的发现，欢迎留言）。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>如果是在单线程环境下，其实完全没有必要使用线程安全的容器，但就算使用了，因为不会有线程竞争，这个时候 JIT 编译会对这个对象的方法锁进行锁消除。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以通过JVM参数进行设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+EliminateLocks 开启锁消除（jdk1.8 默认开启）</span><br><span class="line">-XX:-EliminateLocks 关闭锁消除</span><br></pre></td></tr></table></figure></p><h3 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h3><p>逃逸分析证明一个对象不会被外部访问，如果这个对象可以被拆分的话，当程序真正执行的时候可能不创建这个对象，而直接创建它的成员变量来代替。将对象拆分后，可以分配对象的成员变量在栈或寄存器上，原本的对象就无需分配内存空间了。这种编译优化就叫做标量替换。</p><p>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TestInfo info = <span class="keyword">new</span> TestInfo();</span><br><span class="line">    info.id = <span class="number">1</span>;</span><br><span class="line">    info.count = <span class="number">99</span>;</span><br><span class="line">    <span class="comment">// to do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>逃逸分析后，代码会被优化为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    id = <span class="number">1</span>;</span><br><span class="line">    count = <span class="number">99</span>;</span><br><span class="line">    <span class="comment">// to do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以通过JVM参数进行设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+EliminateAllocations 开启标量替换（jdk1.8 默认开启）</span><br><span class="line">-XX:-EliminateAllocations 关闭就可以了</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今天的内容，由最基本的常识<code>方法内部行数和逻辑需要尽可能简单</code>引出，了解了 JVM 通过即时编译对热点代码进行优化的过程。如果你有什么想法，欢迎在下方留言。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/attentionQrcode.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/toutiaoAttentionQrcode.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们在写代码时，一个方法内部的行数自然是越少越好，这样逻辑清晰、方便阅读，其实好处远不止如此，通过即时编译，甚至可以提高执行时的性能，今天就让我们好好来了解一下其中的原理。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.death00.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://www.death00.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java面试- JVM 内存模型讲解</title>
    <link href="https://www.death00.top/2019/10/11/Java%E9%9D%A2%E8%AF%95-JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E8%AE%B2%E8%A7%A3/"/>
    <id>https://www.death00.top/2019/10/11/Java面试-JVM内存模型讲解/</id>
    <published>2019-10-11T01:30:00.000Z</published>
    <updated>2019-10-10T11:01:27.141Z</updated>
    
    <content type="html"><![CDATA[<p>经常有人会有这么一个疑惑，难道 Java 开发就一定要懂得 JVM 的原理吗？我不懂 JVM ，但我照样可以开发。确实，但如果懂得了 JVM ，可以让你在技术的这条路上走的更远一些。<br><a id="more"></a></p><h2 id="JVM-的重要性"><a href="#JVM-的重要性" class="headerlink" title="JVM 的重要性"></a>JVM 的重要性</h2><p>首先你应该知道，运行一个 Java 应用程序，我们必须要先安装 JDK 或者 JRE 。这是因为 Java 应用在编译后会变成字节码，然后通过字节码运行在 JVM 中，而 JVM 是 JRE 的核心组成部分。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>JVM 不仅承担了 Java 字节码的分析（JIT compiler）和执行（Runtime），同时也内置了自动内存分配管理机制。这个机制可以大大降低手动分配回收机制可能带来的内存泄露和内存溢出风险，使 Java 开发人员不需要关注每个对象的内存分配以及回收，从而更专注于业务本身。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>这个机制在提升 Java 开发效率的同时，也容易使 Java 开发人员过度依赖于自动化，弱化对内存的管理能力，这样系统就很容易发生 JVM 的堆内存异常、垃圾回收（GC）的不合适以及 GC 次数过于频繁等问题，这些都将直接影响到应用服务的性能。</p><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>JVM 内存模型共分为5个区：<code>堆(Heap)</code>、<code>方法区(Method Area)</code>、<code>程序计数器(Program Counter Register)</code>、<code>虚拟机栈(VM Stack)</code>、<code>本地方法栈(Native Method Stack)</code>。</p><p><img src="https://github.com/death00/gitment-comments/blob/master/imgs/2019101001.jpg?raw=true" alt=""></p><p>其中，<code>堆(Heap)</code>、<code>方法区(Method Area)</code>为<code>线程共享</code>，<code>程序计数器(Program Counter Register)</code>、<code>虚拟机栈(VM Stack)</code>、<code>本地方法栈(Native Method Stack)</code>为<code>线程隔离</code>。</p><h3 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆(Heap)"></a>堆(Heap)</h3><p>堆是 JVM 内存中最大的一块内存空间，该内存被所有线程共享，几乎所有对象和数组都被分配到了堆内存中。</p><p>堆被划分为新生代和老年代，新生代又被进一步划分为 Eden 区和 Survivor 区，最后 Survivor 由 From Survivor 和 To Survivor 组成。</p><p>随着 Java 版本的更新，其内容又有了一些新的变化：</p><blockquote><p>在 Java6 版本中，永久代在非堆内存区；到了 Java7 版本，永久代的静态变量和运行时常量池被合并到了堆中；而到了 Java8，永久代被<code>元空间</code>(处于本地内存)取代了。</p></blockquote><p><img src="https://github.com/death00/gitment-comments/blob/master/imgs/2019101002.png?raw=true" alt=""></p><p>为什么要用<code>元空间</code>替换永久代呢？</p><ol><li>为了融合 HotSpot JVM 与 JRockit VM，因为 JRockit 没有永久代，所以不需要配置永久代。</li><li>永久代内存经常不够用或发生内存溢出（应该是 JVM 中占用内存最大的一块），产生异常 <code>java.lang.OutOfMemoryError: PermGen</code>。在 JDK1.7 版本中，指定的 PermGen 区大小为 8M，由于 PermGen 中类的元数据信息在每次 FullGC 的时候都可能被收集，回收率都偏低，成绩很难令人满意；还有，为 PermGen 分配多大的空间很难确定，PermSize 的大小依赖于很多因素，比如，JVM 加载的 class 总数、常量池的大小和方法的大小等。</li></ol><p>看到这儿，自然就想到了 GC 回收算法，不用急，我会在之后的文章中进行讲解，现在还是以 JVM 内存模型为主。</p><h3 id="方法区-Method-Area"><a href="#方法区-Method-Area" class="headerlink" title="方法区(Method Area)"></a>方法区(Method Area)</h3><p>什么是方法区？</p><blockquote><p>方法区主要是用来存放已被虚拟机加载的类相关信息，包括<code>类信息</code>、<code>常量池</code>(字符串常量池以及所有基本类型都有其相应的常量池)、<code>运行时常量池</code>。这其中，类信息又包括了类的版本、字段、方法、接口和父类等信息。</p></blockquote><h4 id="类信息"><a href="#类信息" class="headerlink" title="类信息"></a>类信息</h4><p>JVM 在执行某个类的时候，必须经过加载、连接、初始化，而<code>连接</code>又包括验证、准备、解析三个阶段。</p><p>在加载类的时候，JVM 会先加载 class 文件，而在 class 文件中便有类的版本、字段、方法和接口等描述信息，这就是<code>类信息</code>。</p><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>在 class 文件中，除了<code>类信息</code>，还有一项信息是常量池 (Constant Pool Table)，用于存放编译期间生成的各种<code>字面量</code>和<code>符号引用</code>。</p><p>那<code>字面量</code>和<code>符号引用</code>又是什么呢？</p><p>字面量包括字符串（String a=“b”）、基本类型的常量（final 修饰的变量），符号引用则包括类和方法的全限定名（例如 String 这个类，它的全限定名就是 Java/lang/String）、字段的名称和描述符以及方法的名称和描述符。</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>当类加载到内存后，JVM 就会将 class 文件<code>常量池</code>中的内容存放到<code>运行时常量池</code>中；在解析阶段，JVM 会把符号引用替换为直接引用（对象的索引值）。</p><p>例如：</p><blockquote><p>类中的一个字符串常量在 class 文件中时，存放在 class 文件常量池中的。</p><p>在 JVM 加载完类之后，JVM 会将这个<code>字符串常量</code>放到<code>运行时常量池</code>中，并在解析阶段，指定该字符串对象的索引值。</p></blockquote><p><code>运行时常量池</code>是全局共享的，多个类共用一个运行时常量池，因此，class 文件中常量池多个相同的字符串在运行时常量池只会存在一份。</p><p>讲到这里，大家是不是有些头晕了，说实话，我在看到这些内容的时候，也是云里雾里的，这里举个例子帮助大家理解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String str = <span class="string">"Hello"</span>;</span><br><span class="line">    System.out.println((str == (<span class="string">"Hel"</span> + <span class="string">"lo"</span>)));</span><br><span class="line"></span><br><span class="line">    String loStr = <span class="string">"lo"</span>;</span><br><span class="line">    System.out.println((str == (<span class="string">"Hel"</span> + loStr)));</span><br><span class="line"></span><br><span class="line">    System.out.println(str == (<span class="string">"Hel"</span> + loStr).intern());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其运行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure></p><p>第一个为 true，是因为在编译成 class 文件时，能够识别为同一字符串的, JVM 会将其自动优化成字符串常量,引用自同一 String 对象。</p><p>第二个为 false，是因为在运行时创建的字符串具有独立的内存地址,所以不引用自同一 String 对象。</p><p>最后一个为 true，是因为 String 的 intern() 方法会查找在常量池中是否存在一个相等(调用 equals() 方法结果相等)的字符串,如果有则返回该字符串的引用,如果没有则添加自己的字符串进入常量池。</p><h4 id="涉及到的Error"><a href="#涉及到的Error" class="headerlink" title="涉及到的Error"></a>涉及到的Error</h4><ol><li><code>OutOfMemoryError</code>出现在方法区无法满足内存分配需求的时候，比如一直往常量池中加入数据，<code>运行时常量池</code>就会溢出，从而报错。</li></ol><h3 id="程序计数器-Program-Counter-Register"><a href="#程序计数器-Program-Counter-Register" class="headerlink" title="程序计数器(Program Counter Register)"></a>程序计数器(Program Counter Register)</h3><p>程序计数器是一块很小的内存空间，主要用来记录各个线程执行的字节码的地址，例如，分支、循环、跳转、异常、线程恢复等都依赖于计数器。</p><p>由于 Java 是多线程语言，当执行的线程数量超过 CPU 数量时，线程之间会根据时间片轮询争夺 CPU 资源。如果一个线程的时间片用完了，或者是其它原因导致这个线程的 CPU 资源被提前抢夺，那么这个退出的线程就需要单独的一个程序计数器，来记录下一条运行的指令。</p><p>由此可见，程序计数器和上下文切换有关。</p><h3 id="虚拟机栈-VM-Stack"><a href="#虚拟机栈-VM-Stack" class="headerlink" title="虚拟机栈(VM Stack)"></a>虚拟机栈(VM Stack)</h3><blockquote><p>虚拟机栈是线程私有的内存空间，它和 Java 线程一起创建。</p><p>当创建一个线程时，会在虚拟机栈中申请一个线程栈，用来保存方法的局部变量、操作数栈、动态链接方法和返回地址等信息，并参与方法的调用和返回。</p><p>每一个方法的调用都伴随着栈帧的入栈操作，方法的返回则是栈帧的出栈操作。</p></blockquote><p>可以这么理解，虚拟机栈针对当前 Java 应用中所有线程，都有一个其相应的线程栈，每一个线程栈都互相独立、互不影响，里面存储了该线程中独有的信息。</p><h4 id="涉及到的Error-1"><a href="#涉及到的Error-1" class="headerlink" title="涉及到的Error"></a>涉及到的Error</h4><ol><li><code>StackOverflowError</code>出现在栈内存设置成固定值的时候，当程序执行需要的栈内存超过设定的固定值时会抛出这个错误。</li><li><code>OutOfMemoryError</code>出现在栈内存设置成动态增长的时候，当JVM尝试申请的内存大小超过了其可用内存时会抛出这个错误。</li></ol><h3 id="本地方法栈-Native-Method-Stack"><a href="#本地方法栈-Native-Method-Stack" class="headerlink" title="本地方法栈(Native Method Stack)"></a>本地方法栈(Native Method Stack)</h3><blockquote><p>本地方法栈跟虚拟机栈的功能类似，虚拟机栈用于管理 Java 方法的调用，而本地方法栈则用于管理本地方法的调用。</p><p>但本地方法并不是用 Java 实现的，而是由 C 语言实现的。</p></blockquote><p>也就是说，本地方法栈中并没有我们写的代码逻辑，其由<code>native</code>修饰，由 C 语言实现。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是 JVM 内存模型的基本介绍，大致了解了一下5个分区及其相应的含义和功能，由此可以继续延伸出 Java 内存模型、 GC 算法等等，我也会在之后的文章中进行讲解。如果你有什么想法，欢迎在下方留言。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/attentionQrcode.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/toutiaoAttentionQrcode.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经常有人会有这么一个疑惑，难道 Java 开发就一定要懂得 JVM 的原理吗？我不懂 JVM ，但我照样可以开发。确实，但如果懂得了 JVM ，可以让你在技术的这条路上走的更远一些。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.death00.top/tags/Java/"/>
    
      <category term="JVM" scheme="https://www.death00.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Lombok中关于@Data的使用</title>
    <link href="https://www.death00.top/2019/10/10/Lombok%E4%B8%AD%E5%85%B3%E4%BA%8E-Data%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.death00.top/2019/10/10/Lombok中关于-Data的使用/</id>
    <published>2019-10-10T02:43:30.000Z</published>
    <updated>2019-10-10T03:24:36.493Z</updated>
    
    <content type="html"><![CDATA[<p>当你在使用 Lombok 的 @Data 注解时，其实会有一些坑需要关注，今天就让我们来见识一下。<br><a id="more"></a></p><h2 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h2><p>先来简单介绍一下 Lombok ，其官方介绍如下：</p><blockquote><p>Project Lombok makes java a spicier language by adding ‘handlers’ that know how to build and compile simple, boilerplate-free, not-quite-java code.</p></blockquote><p>大致意思是 Lombok 通过增加一些”处理程序”，可以让 Java 代码变得简洁、快速。</p><p>Lombok 提供了一系列的注解帮助我们简化代码，比如：</p><table><thead><tr><th style="text-align:center">注解名称</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>@Setter</code></td><td style="text-align:left">自动添加类中所有属性相关的 set 方法</td></tr><tr><td style="text-align:center"><code>@Getter</code></td><td style="text-align:left">自动添加类中所有属性相关的 get 方法</td></tr><tr><td style="text-align:center"><code>@Builder</code></td><td style="text-align:left">使得该类可以通过 builder (建造者模式)构建对象</td></tr><tr><td style="text-align:center"><code>@RequiredArgsConstructor</code></td><td style="text-align:left">生成一个该类的构造方法，禁止无参构造</td></tr><tr><td style="text-align:center"><code>@ToString</code></td><td style="text-align:left">重写该类的<code>toString()</code>方法</td></tr><tr><td style="text-align:center"><code>@EqualsAndHashCode</code></td><td style="text-align:left">重写该类的<code>equals()</code>和<code>hashCode()</code>方法</td></tr><tr><td style="text-align:center"><code>@Data</code></td><td style="text-align:left">等价于上面的<code>@Setter</code>、<code>@Getter</code>、<code>@RequiredArgsConstructor</code>、<code>@ToString</code>、<code>@EqualsAndHashCode</code></td></tr></tbody></table><p>看起来似乎这些注解都很正常，并且对我们的代码也有一定的优化，那为什么说<code>@Data</code>注解存在坑呢？</p><h2 id="Data注解"><a href="#Data注解" class="headerlink" title="@Data注解"></a>@Data注解</h2><h3 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h3><p>由上面的表格我们可以知道，<code>@Data</code>是包含了<code>@EqualsAndHashCode</code>的功能，那么它究竟是如何重写<code>equals()</code>和<code>hashCode()</code>方法的呢？</p><p>我们定义一个类<code>TestA</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String oldName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们将其编译后的 class 文件进行反编译：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String oldName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOldName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.oldName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOldName</span><span class="params">(String oldName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.oldName = oldName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否是同一个对象</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否是同一个类</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> TestA)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            TestA other = (TestA) o;</span><br><span class="line">            <span class="keyword">if</span> (!other.canEqual(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 比较类中的属性(注意这里，只比较了当前类中的属性)</span></span><br><span class="line">                Object <span class="keyword">this</span>$oldName = <span class="keyword">this</span>.getOldName();</span><br><span class="line">                Object other$oldName = other.getOldName();</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>$oldName == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (other$oldName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>$oldName.equals(other$oldName)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">canEqual</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> other <span class="keyword">instanceof</span> TestA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> PRIME = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        Object $oldName = <span class="keyword">this</span>.getOldName();</span><br><span class="line">        <span class="keyword">int</span> result = result * <span class="number">59</span> + ($oldName == <span class="keyword">null</span> ? <span class="number">43</span> : $oldName.hashCode());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"TestA(oldName="</span> + <span class="keyword">this</span>.getOldName() + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>针对其<code>equals()</code>方法，当它进行属性比较时，其实只比较了当前类中的属性。如果你不信的话，我们再来创建一个类<code>TestB</code>，它是<code>TestA</code>的子类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestB</span> <span class="keyword">extends</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们将其编译后的 class 文件进行反编译：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestB</span> <span class="keyword">extends</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> TestB)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            TestB other = (TestB)o;</span><br><span class="line">            <span class="keyword">if</span> (!other.canEqual(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 注意这里，真的是只比较了当前类中的属性，并没有比较父类中的属性</span></span><br><span class="line">                Object <span class="keyword">this</span>$name = <span class="keyword">this</span>.getName();</span><br><span class="line">                Object other$name = other.getName();</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>$name == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (other$name == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">this</span>.getAge() == other.getAge();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>$name.equals(other$name)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.getAge() == other.getAge();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">canEqual</span><span class="params">(Object other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> other <span class="keyword">instanceof</span> TestB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> PRIME = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        Object $name = <span class="keyword">this</span>.getName();</span><br><span class="line">        <span class="keyword">int</span> result = result * <span class="number">59</span> + ($name == <span class="keyword">null</span> ? <span class="number">43</span> : $name.hashCode());</span><br><span class="line">        result = result * <span class="number">59</span> + <span class="keyword">this</span>.getAge();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"TestB(name="</span> + <span class="keyword">this</span>.getName() + <span class="string">", age="</span> + <span class="keyword">this</span>.getAge() + <span class="string">")"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>按照代码的理解，如果两个子类对象，其子类中的属性相同、父类中的属性不同时，利用<code>equals()</code>方法时，依旧会认为这两个对象相同，测试一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TestB t1 = <span class="keyword">new</span> TestB();</span><br><span class="line">    TestB t2 = <span class="keyword">new</span> TestB();</span><br><span class="line"></span><br><span class="line">    t1.setOldName(<span class="string">"123"</span>);</span><br><span class="line">    t2.setOldName(<span class="string">"12345"</span>);</span><br><span class="line"></span><br><span class="line">    String name = <span class="string">"1"</span>;</span><br><span class="line">    t1.name = name;</span><br><span class="line">    t2.name = name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">1</span>;</span><br><span class="line">    t1.age = age;</span><br><span class="line">    t2.age = age;</span><br><span class="line"></span><br><span class="line">    System.out.println(t1.equals(t2));</span><br><span class="line">    System.out.println(t2.equals(t1));</span><br><span class="line">    System.out.println(t1.hashCode());</span><br><span class="line">    System.out.println(t2.hashCode());</span><br><span class="line">    System.out.println(t1 == t2);</span><br><span class="line">    System.out.println(Objects.equals(t1, t2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">true</span><br><span class="line">6373</span><br><span class="line">6373</span><br><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure></p><h3 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h3><blockquote><p>对于父类是Object且使用了<code>@EqualsAndHashCode(callSuper = true)</code>注解的类，这个类由 Lombok 生成的<code>equals()</code>方法只有在两个对象是同一个对象时，才会返回 true ，否则总为 false ，无论它们的属性是否相同。</p><p>这个行为在大部分时间是不符合预期的，<code>equals()</code>失去了其意义。即使我们期望<code>equals()</code>是这样工作的，那么其余的属性比较代码便是累赘，会大幅度降低代码的分支覆盖率。</p></blockquote><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol><li>用了<code>@Data</code>就不要有继承关系，类似 Kotlin 的做法。</li><li>自己重写<code>equals()</code>， Lombok 不会对显式重写的方法进行生成。</li><li>显式使用<code>@EqualsAndHashCode(callSuper = true)</code>， Lombok 会以显式指定的为准。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上便是我在使用<code>@Data</code>时碰到的问题以及自己的一些思考，在现在的项目，我干脆不再使用该注解。如果你有什么想法，欢迎在下方留言。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/attentionQrcode.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/toutiaoAttentionQrcode.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当你在使用 Lombok 的 @Data 注解时，其实会有一些坑需要关注，今天就让我们来见识一下。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.death00.top/tags/Java/"/>
    
      <category term="Lombok" scheme="https://www.death00.top/tags/Lombok/"/>
    
  </entry>
  
  <entry>
    <title>Java中Synchronized的优化原理</title>
    <link href="https://www.death00.top/2019/10/02/Java%E4%B8%ADSynchronized%E7%9A%84%E4%BC%98%E5%8C%96%E5%8E%9F%E7%90%86/"/>
    <id>https://www.death00.top/2019/10/02/Java中Synchronized的优化原理/</id>
    <published>2019-10-02T07:52:32.000Z</published>
    <updated>2019-10-02T08:36:13.883Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，从 JDK1.6 开始，Java 对 Synchronized 同步锁做了充分的优化，甚至在某些场景下，它的性能已经超越了 Lock 同步锁。那么就让我们来看看，它究竟是如何优化的。<br><a id="more"></a></p><h2 id="原本的问题"><a href="#原本的问题" class="headerlink" title="原本的问题"></a>原本的问题</h2><p><code>Synchronized</code>是基于底层操作系统的 Mutex Lock 实现的，每次获取锁和释放锁的操作都会带来<code>用户态</code>和<code>内核态</code>的切换，从而增加系统性能开销。</p><p>因此，在锁竞争激烈的情况下，<code>Synchronized</code>同步锁在性能上就表现得非常糟糕，它也常被大家称为<code>重量级锁</code>。</p><p>到了 JDK1.5 版本，并发包中新增了 Lock 接口来实现锁功能，它提供了与 Synchronized 关键字类似的同步功能，只是在使用时需要显示获取锁和释放锁。</p><p>在单个线程重复申请锁的情况下，JDK1.5 版本的 Lock 性能要比 Synchronized 锁的性能好很多，也就是当时的 Synchronized 并不具备<code>可重入锁</code>的功能。</p><p>那么当时的 Synchronized 是怎么实现的？又为什么不具备可重入的功能呢？</p><h2 id="Synchronized原理"><a href="#Synchronized原理" class="headerlink" title="Synchronized原理"></a>Synchronized原理</h2><p>JVM 中的同步是基于进入和退出管程（Monitor）对象实现的。每个对象实例都会有一个 Monitor，Monitor 可以和对象一起创建、销毁。</p><p>当多个线程同时访问一段同步代码时，多个线程会先被存放在<code>EntryList集合</code>（也可称为<code>阻塞队列</code>）中，处于<code>BLOCKED</code>状态的线程，都会被加入到该列表。</p><p>接下来当线程获取到对象的 Monitor 时，Monitor 是依靠底层操作系统的 Mutex Lock 来实现互斥的，线程申请 Mutex 成功，则持有该 Mutex，其它线程将无法获取到该 Mutex。</p><p>如果线程调用 wait() 方法，就会释放当前持有的 Mutex，并且该线程会进入<code>WaitSet集合</code>（也可称为<code>等待队列</code>）中，等待下一次被唤醒。此时线程会处于<code>WAITING</code>或者<code>TIMEDWAITING</code>状态，</p><p>如果当前线程顺利执行完方法，也将释放 Mutex。</p><p>总的来说，就是同步锁在这种实现方式中，因 Monitor 是依赖于底层的操作系统实现，存在<code>用户态</code>与<code>内核态</code>之间的切换(可以理解为<code>上下文切换</code>)，所以增加了性能开销。</p><h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><p>为了提升性能，JDK1.6 引入了偏向锁、轻量级锁、重量级锁概念，来减少锁竞争带来的上下文切换，而正是新增的<code>Java对象头</code>实现了<code>锁升级</code>功能。</p><p>所谓<code>锁升级</code>，就是指</p><blockquote><p>Synchronized 同步锁初始为<code>偏向锁</code>，随着线程竞争越来越激烈，<code>偏向锁</code>升级到<code>轻量级锁</code>，最终升级到<code>重量级锁</code>。</p></blockquote><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p><code>偏向锁</code>主要用来优化同一线程多次申请同一个锁的竞争，也就是现在的<code>Synchronized锁</code>实际已经拥有了可重入锁的功能。</p><p>为什么要有<code>偏向锁</code>？因为在我们的应用中，可能大部分时间是同一个线程竞争锁资源（比如单线程操作一个线程安全的容器），如果这个线程每次都要获取锁和释放锁，那么就在不断的从<code>内核态</code>与<code>用户态</code>之间切换。</p><p>那么有了<code>偏向锁</code>，当一个线程再次访问这个同步代码或方法时，该线程只需去对象头中去判断一下是否当前线程是否持有该偏向锁就可以了。</p><p>一旦出现其它线程竞争锁资源时，偏向锁就会被撤销。偏向锁的撤销需要等待<code>全局安全点</code>(JVM的<code>stop the world</code>)，暂停持有该锁的线程，同时检查该线程是否还在执行该方法，如果是，则升级锁，反之则被其它线程抢占。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>当有另外一个线程竞争获取这个锁时，由于该锁已经是偏向锁，当发现对象头中的线程 ID 不是自己的线程 ID，就会进行 CAS 操作获取锁，如果获取成功，直接替换对象头中的线程 ID 为自己的 ID，该锁会保持<code>偏向锁</code>状态；如果获取锁失败，代表当前锁有一定的竞争，偏向锁将升级为<code>轻量级锁</code>。</p><p><code>轻量级锁</code>适用于线程交替执行同步块的场景，绝大部分的锁在整个同步周期内都不存在长时间的竞争。</p><p>轻量级锁也支持<code>自旋</code>，因此其他线程再次争抢时，如果<code>CAS</code>失败，将不再会进入<code>阻塞状态</code>，而是不断自旋。</p><p>之所以自旋更好，是因为之前说了，默认线程持有锁的时间都不会太长，如果线程被挂起阻塞可能代价会更高。</p><p>如果自旋锁重试之后抢锁依然失败，那么同步锁就会升级至<code>重量级锁</code>。</p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>在这个状态下，未抢到锁的线程都会进入 Monitor，之后会被阻塞在<code>WaitSet集合</code>中，也就变成了优化之前的<code>Synchronized锁</code>。</p><h2 id="JVM参数优化"><a href="#JVM参数优化" class="headerlink" title="JVM参数优化"></a>JVM参数优化</h2><p><code>偏向锁</code>升级为<code>轻量级锁</code>时，会发生<code>stop the world</code>，如果系统常常是多线程竞争，那么禁止偏向锁也许是更好的选择，可以通过以下<code>JVM参数</code>进行优化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 关闭偏向锁（默认打开）</span><br><span class="line">-XX:-UseBiasedLocking</span><br><span class="line">// 设置重量级锁</span><br><span class="line">-XX:+UseHeavyMonitors</span><br></pre></td></tr></table></figure><p><code>轻量级锁</code>拥有<code>自旋锁</code>的功能，那么如果线程持有锁的时间很长，那么竞争的线程也会常常处于自旋状态，占用系统 CPU ，增加系统开销，那么此时关闭自旋锁的优化可以更好一些：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:-UseSpinning</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上便是 Java 中针对 Synchronized 锁的优化，也正是因为这个优化，ConcurrentHashMap 在 JDK1.8 之后，再次采用 Synchronized 锁。如果你有什么想法，欢迎在下方留言。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/attentionQrcode.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/toutiaoAttentionQrcode.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们知道，从 JDK1.6 开始，Java 对 Synchronized 同步锁做了充分的优化，甚至在某些场景下，它的性能已经超越了 Lock 同步锁。那么就让我们来看看，它究竟是如何优化的。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.death00.top/tags/Java/"/>
    
      <category term="Synchronized" scheme="https://www.death00.top/tags/Synchronized/"/>
    
      <category term="优化" scheme="https://www.death00.top/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>升级@Scheduled-分布式定时任务</title>
    <link href="https://www.death00.top/2019/09/30/%E5%8D%87%E7%BA%A7@Scheduled-%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <id>https://www.death00.top/2019/09/30/升级@Scheduled-分布式定时任务/</id>
    <published>2019-09-30T09:01:47.000Z</published>
    <updated>2019-10-01T01:16:41.430Z</updated>
    
    <content type="html"><![CDATA[<p>最近我在对项目的定时任务服务升级，希望改造成分布式，原本是利用<code>@Scheduled</code>注解实现，然而它并不支持分布式，如果改成<code>quartz</code>或者<code>Spring Cloud Task</code>，感觉对于自己这个简单的项目也没有必要。因此，我准备手写一个简单的支持分布式定时调度任务的框架。<br><a id="more"></a></p><p>项目地址是<a href="https://github.com/death00/dis-schedule" target="_blank" rel="noopener">https://github.com/death00/dis-schedule</a>，欢迎大家star、提意见。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>先分析了一下自己的项目，全都是用的cron表达式，因此执行时间点都是固定的，如果升级为分布式的话，肯定是希望在同一个时间点只有一个应用去执行定时调度。</p><p>场景就变成了：</p><blockquote><p>多个应用在同一个时间都尝试去执行任务，但最终只有一个应用真正执行。</p></blockquote><p>这样的话，立马就会让人联想到使用<code>锁</code>去解决，因为是多个应用，所以就是<code>分布式锁</code>。那么，场景又变了：</p><blockquote><p>多个应用在同一个时间都尝试去获取<code>分布式锁</code>，只有一个应用能抢到这把锁，抢到锁的应用可以执行定时任务，其他应用则直接放弃，等待下一次执行时间。</p></blockquote><p>抢锁的时机是每次定时任务执行之前，这又让我联想到了<code>AOP</code>，那么利用<code>注解</code>也就顺理成章了。</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>既然谈到了<code>分布式锁</code>，那么就想一下，这把锁的名称构成是什么。因为定时任务都有自己专门的时间，如果仅仅采用时间的话，那么当有两个任务同时执行时，则就是在抢一把锁，这同样是不合理的。</p><p>所以，锁的名称由两部分组成：任务执行时间、任务名称。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实现方案其实已经很成熟了，可以利用<code>Redis</code>、<code>数据库</code>、<code>Zookeeper</code>等，<code>Redis</code>用的命令是<code>setNx</code>，<code>数据库</code>一般都是利用的<code>唯一索引</code>，<code>Zookeeper</code>这点我也不是很了解（如果有感兴趣的同学，欢迎在我的项目中添加）。</p><p>我的项目中实现了<code>Redis</code>、<code>数据库</code>两种方式，可以看类<code>DisScheduleRedisServiceImpl</code>、<code>DisScheduleMongodbServiceImpl</code>。</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>其次，我自定义了一个注解<code>DisSchedule</code>，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> DisSchedule &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定时调度任务的名称(默认是方法名)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务的间隔时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">duration</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * duration的时间单位(默认：分钟)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">DisScheduleUnit <span class="title">unit</span><span class="params">()</span> <span class="keyword">default</span> DisScheduleUnit.MINUTES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>name</code>代表此次定时调度任务的名称。</li><li><code>duration</code>代表任务的间隔时间，配合<code>unit</code>。</li><li><code>unit</code>是自定义的时间单位，有秒、分钟。</li></ol><p>该注解需要配合<code>@Scheduled</code>共同使用，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DisSchedule</span>(name = <span class="string">"testSchedule"</span>, duration = <span class="number">1</span>, unit = DisScheduleUnit.MINUTES)</span><br><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"0 0/1 * * * ?"</span>)</span><br></pre></td></tr></table></figure></p><p>该<code>cron</code>表达式代表1分钟执行一次，且是在整数分钟开始的时候执行，因此<code>@DisSchedule</code>也需要设置为1分钟的时间。</p><h2 id="切面"><a href="#切面" class="headerlink" title="切面"></a>切面</h2><p>接下来，我们只需要在<code>Aspect</code>中定义好切入点（有注解<code>@DisSchedule</code>的方法上），针对这些方法，需要使用<code>Around</code>(环绕增强)进行拦截，因为当抢不到锁的时候，就不允许执行。</p><p>具体可以参考类<code>DisScheduleAspect</code>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是我实现的简单的分布式定时任务，虽然简单，但应该可以满足你的基础需求，接下来，我会在这个之上，逐步增加功能（比如监测、失败后预警等）。如果你有什么想法，欢迎在下方留言。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/attentionQrcode.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/toutiaoAttentionQrcode.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近我在对项目的定时任务服务升级，希望改造成分布式，原本是利用&lt;code&gt;@Scheduled&lt;/code&gt;注解实现，然而它并不支持分布式，如果改成&lt;code&gt;quartz&lt;/code&gt;或者&lt;code&gt;Spring Cloud Task&lt;/code&gt;，感觉对于自己这个简单的项目也没有必要。因此，我准备手写一个简单的支持分布式定时调度任务的框架。&lt;br&gt;
    
    </summary>
    
    
      <category term="分布式" scheme="https://www.death00.top/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Scheduled" scheme="https://www.death00.top/tags/Scheduled/"/>
    
      <category term="定时任务" scheme="https://www.death00.top/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Nginx的负载均衡</title>
    <link href="https://www.death00.top/2019/09/30/Nginx%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>https://www.death00.top/2019/09/30/Nginx的负载均衡/</id>
    <published>2019-09-30T01:34:06.000Z</published>
    <updated>2019-09-30T06:10:47.226Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道，Nginx支持负载均衡，可以很方便的帮助我们进行水平扩容，然而它究竟是依据什么原则进行请求的分发，其中又有哪些负载均衡算法可供选择和配置，今天就让我们好好来了解一下。<br><a id="more"></a></p><h2 id="负载均衡的定义"><a href="#负载均衡的定义" class="headerlink" title="负载均衡的定义"></a>负载均衡的定义</h2><p>什么叫负载均衡，我们可以参考一下图片中的这种情况：</p><p><img src="https://github.com/death00/gitment-comments/blob/master/imgs/2019093001.png?raw=true" alt=""></p><ol><li>当客户端发送请求时，会先到Nginx，然后Nginx会将请求分发到后台不同的服务器上。</li><li>如果后台的服务器群中有一个宕机了，那么Nginx会自动忽略这台服务器，不会将请求再次分发到这台服务器上。</li><li>如果有新加入的服务器，Nginx也会将请求分发到这台服务器上。</li></ol><p>我所理解的负载均衡，就是：</p><blockquote><p>能够将客户端的请求均匀地分发到后台各个应用服务器上，从而缓解服务器压力。</p><p>并且当服务器出现宕机或者扩容时，也能正常运行。</p></blockquote><h2 id="负载均衡的方法"><a href="#负载均衡的方法" class="headerlink" title="负载均衡的方法"></a>负载均衡的方法</h2><p>上面了解了什么是负载均衡，那么Nginx是怎么实现这个功能的呢？</p><h3 id="upstream和server的使用"><a href="#upstream和server的使用" class="headerlink" title="upstream和server的使用"></a>upstream和server的使用</h3><p>Nginx中负责与上游交互的模块，统称为upstream模块。</p><p>而指定上游服务地址是通过<code>upstream</code>和<code>server</code>指令完成的，其关系为：</p><p><img src="https://github.com/death00/gitment-comments/blob/master/imgs/2019093002.png?raw=true" alt=""></p><p>指定上游服务器的<code>address</code>时，其地址可以是域名、IP地址或者unix socket地址。</p><p>可以在域名或者IP地址后加端口，如果不加端口，那么<code>默认使用80端口</code>。</p><p>在<code>address</code>后面可以添加一些参数，比如：</p><p><code>backup</code>：指定当前server为备份服务，仅当非备份server不可用时，请求才会转发到该server。</p><p><code>down</code>：标识某台服务已经下线，不再服务。</p><p>举个例子：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> upstream-service &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:17002</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:17000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="round-robin"><a href="#round-robin" class="headerlink" title="round-robin"></a>round-robin</h3><p>在<code>upstream</code>这个模块中，它还提供了一个最基本的负载均衡算法<code>round-robin</code>。</p><p>其功能是：</p><blockquote><p>以加权轮询的方式访问server指令指定的上游服务。</p></blockquote><p>这个算法是默认集成在Nginx的框架中，无法移除，所以后面讲解的所有算法都是基于此，所有算法在某些特殊情况下最终都会变成<code>round-robin</code>。</p><p>涉及到的指令有：</p><ol><li><code>weight</code>：服务访问的权重，默认是1。</li><li><code>max_conns</code>：server的最大并发连接数，仅作用于单worker进程。</li><li><code>max_fails</code>：在<code>fail_timeout</code>时间内，最大的失败次数。当达到最大失败时，会在<code>fail_timeout</code>时间内不允许再次被选择。</li><li><code>fail_timeout</code>：单位为秒，默认是10秒。指定一段时间内，最大的失败次数<code>max_fails</code>。到达<code>max_fails</code>后，该server不能访问的时间。</li></ol><h3 id="简单的hash模块"><a href="#简单的hash模块" class="headerlink" title="简单的hash模块"></a>简单的hash模块</h3><p>有的时候，正常的轮询算法并不能满足我们的需求，</p><p>比如：带有cookie请求状态的连接，如果应用服务没有设置专门的管理cookie的服务器，那么我们就希望同一个用户能被分配到同一个服务器。</p><p>再比如：我们后端应用需要针对请求当中的参数或者URL，将相同的请求放到相同的服务器上进行处理。</p><p>针对第一种情况，就可以用<code>upstream_ip_hash</code>。针对第二种情况，可以使用<code>upstream_hash</code>。</p><h4 id="upstream-ip-hash"><a href="#upstream-ip-hash" class="headerlink" title="upstream_ip_hash"></a>upstream_ip_hash</h4><p>功能：</p><blockquote><p>以客户端的IP地址作为hash算法的关键字，映射到特定的上游服务器中。</p><ol><li>对IPV4地址使用前3个字节作为关键字，对IPV6则使用完整地址。</li><li>可以使用<code>round-robin</code>算法的参数。</li><li>可以基于<code>realip</code>模块修改用于执行算法的IP地址。</li></ol></blockquote><p>举个例子：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> upstream-service &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:17002</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:17000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="upstream-hash"><a href="#upstream-hash" class="headerlink" title="upstream_hash"></a>upstream_hash</h4><p>功能：</p><blockquote><p>通过制定关键字作为hash key，基于hash算法映射到特定的上游服务器中。</p><ol><li>关键字可以含有变量、字符串。</li><li>可以使用<code>round-robin</code>算法的参数。</li></ol></blockquote><p>举个例子(以请求中的参数username作为hash key)：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> upstream-service &#123;</span><br><span class="line">    <span class="attribute">hash</span> user_<span class="variable">$arg_username</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:17002</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:17000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h3><p>hash算法在一定程度上已经可以满足了我们的业务需求，但如果这个时候遇到应用宕机或者应用扩容，那么hash的总数就会变化，这样很有可能带来大量请求原本请求的服务器会更换，路由会失效，这样对于我们的应用服务也会产生极大的影响，这时候就可以采用一致性hash算法。</p><p>对于一致性哈希算法的理解，可以参考这篇文章：<a href="https://yikun.github.io/2016/06/09/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/" target="_blank" rel="noopener">一致性哈希算法的理解与实践</a></p><p>它的使用也十分简单，就是在之前说的<code>upstream_hash</code>模块的<code>hash</code>指令最后，添加参数<code>consistent</code>，这样Nginx就可以使用一致性哈希算法了。</p><p>举个例子(仍以请求中的参数username作为hash key)：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> upstream-service &#123;</span><br><span class="line">    <span class="attribute">hash</span> user_<span class="variable">$arg_username</span> consistent;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:17002</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:17000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是Nginx中比较常见的负载均衡方法了，还有一些比如<code>最少连接算法</code>等，都是在此之上的一些应用。如果大家有什么疑问，欢迎在下方留言。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/attentionQrcode.jpg" alt=""></p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/mark/toutiaoAttentionQrcode.jpeg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们都知道，Nginx支持负载均衡，可以很方便的帮助我们进行水平扩容，然而它究竟是依据什么原则进行请求的分发，其中又有哪些负载均衡算法可供选择和配置，今天就让我们好好来了解一下。&lt;br&gt;
    
    </summary>
    
    
      <category term="Nginx" scheme="https://www.death00.top/tags/Nginx/"/>
    
      <category term="负载均衡" scheme="https://www.death00.top/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>github博客Hexo引流到微信</title>
    <link href="https://www.death00.top/2019/09/26/github%E5%8D%9A%E5%AE%A2hexo%E5%BC%95%E6%B5%81%E5%88%B0%E5%BE%AE%E4%BF%A1/"/>
    <id>https://www.death00.top/2019/09/26/github博客hexo引流到微信/</id>
    <published>2019-09-26T05:31:59.000Z</published>
    <updated>2019-09-26T06:45:37.453Z</updated>
    
    <content type="html"><![CDATA[<p>相信有不少小伙伴都在github上创建了属于自己的博客，其中用<code>Hexo</code>的<code>Next</code>主题应该不少，那么，我们究竟该如何将博客的流量引流到微信呢？今天就来带你看一看。<br><a id="more"></a></p><h2 id="如何引流"><a href="#如何引流" class="headerlink" title="如何引流"></a>如何引流</h2><p>现在网上有一种套路，当你在看别人博客时，只能看一半，想继续看的话，需要扫码关注别人的公众号才能继续，这样的话，你的公众号粉丝自然就能蹭蹭上涨。</p><p>这里需要解决两个问题：</p><ol><li>文章看到一半就不允许继续观看</li><li>关注你的公众号后才能继续观看</li></ol><p>这里我是借助了<a href="https://openwrite.cn/" target="_blank" rel="noopener">OpenWrite</a>中的引流工具实现的。</p><h2 id="导流"><a href="#导流" class="headerlink" title="导流"></a>导流</h2><p>当你注册进入OpenWrite后，会有一个<code>博客导流公众号</code>功能，添加完相应的信息后，即可获得一段具有隐藏功能的<code>JS代码</code>：</p><p><img src="https://openwrite.cn/wp-content/uploads/2019/09/WeChat7c77e13e57068b5f402ad850e144e03d.png" alt=""></p><h2 id="如何设置文章看到一半"><a href="#如何设置文章看到一半" class="headerlink" title="如何设置文章看到一半"></a>如何设置文章看到一半</h2><p>这就需要我们在文章模块页面增加相应的隐藏功能，并且能够展示二维码并锁住页面。</p><h3 id="增加自定义swig文件"><a href="#增加自定义swig文件" class="headerlink" title="增加自定义swig文件"></a>增加自定义swig文件</h3><p>进入你的博客文件夹，在<code>themes\next\layout\_custom</code>文件夹中，新建一个<code>hide.swig</code>文件（这个文件夹专门用来存放自定义的一些代码），复制上文提到的JS代码，注意<code>id</code>的值，它默认用的是<code>container</code>，我设置成了<code>container-1</code>。</p><h3 id="修改文章模板文件"><a href="#修改文章模板文件" class="headerlink" title="修改文章模板文件"></a>修改文章模板文件</h3><p>进入你的博客文件夹，在<code>themes\next\layout</code>文件夹中，会有一个<code>_layout.swig</code>文件，这就是你的文章模板文件。其中有一段内容是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;main id=<span class="string">"main"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"main"</span>&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"main-inner"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"content-wrap"</span>&gt;</span><br><span class="line">        &lt;div id=<span class="string">"content"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"content"</span>&gt;</span><br><span class="line">          &#123;% block content %&#125;&#123;% endblock %&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p><code>id</code>为<code>content</code>的地方，就是你的文章内容，这时候你可以在外面再嵌套一层<code>div</code>，其<code>id</code>就是上面我设置的<code>container-1</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;main id=<span class="string">"main"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"main"</span>&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"main-inner"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"content-wrap"</span>&gt;</span><br><span class="line">      &lt;div id=<span class="string">"container-1"</span>&gt;</span><br><span class="line">        &lt;div id=<span class="string">"content"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"content"</span>&gt;</span><br><span class="line">          &#123;% block content %&#125;&#123;% endblock %&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br></pre></td></tr></table></figure><p>此时就可以发布你的博客，现在你的文章就会产生<code>阅读全文</code>的按钮了：</p><p><img src="https://i.loli.net/2019/09/25/YLjIcqtPlpvwCaZ.png" alt=""></p><p>按下这个按钮，就会弹出相应的二维码和你当初设置的关键字：</p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/imgs/2019092601.png" alt=""></p><h2 id="微信公众号自动回复设置"><a href="#微信公众号自动回复设置" class="headerlink" title="微信公众号自动回复设置"></a>微信公众号自动回复设置</h2><p>在微信公众号后台页面，选择<code>自动回复</code>-<code>关键词回复</code>，点击<code>添加回复</code>：</p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/imgs/2019092602.png" alt=""></p><p>填写<code>规则名称</code>、<code>关键词</code>(你当初在OpenWrite中设置的)，<code>回复内容</code>选择<code>文字</code>，填上<code>OpenWrite</code>中返回的那段文字。</p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/imgs/2019092603.png" alt=""></p><p>此时，当别人关注你的公众号并输入关键字后(比如我设置的关键字就是git)，就会显示回复了</p><p><img src="https://raw.githubusercontent.com/death00/gitment-comments/master/imgs/2019092604.png" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果你的博客有一定的日活，那就千万不要错过这种微信涨粉、互相引流的机会。如果大家有什么疑问，欢迎在下方留言。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信有不少小伙伴都在github上创建了属于自己的博客，其中用&lt;code&gt;Hexo&lt;/code&gt;的&lt;code&gt;Next&lt;/code&gt;主题应该不少，那么，我们究竟该如何将博客的流量引流到微信呢？今天就来带你看一看。&lt;br&gt;
    
    </summary>
    
    
      <category term="github" scheme="https://www.death00.top/tags/github/"/>
    
      <category term="Hexo" scheme="https://www.death00.top/tags/Hexo/"/>
    
      <category term="Next" scheme="https://www.death00.top/tags/Next/"/>
    
      <category term="微信" scheme="https://www.death00.top/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
</feed>
