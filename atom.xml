<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>健程之道</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.death00.top/"/>
  <updated>2020-06-07T10:54:23.280Z</updated>
  <id>https://www.death00.top/</id>
  
  <author>
    <name>健健</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指offer 38——字符串的排列</title>
    <link href="https://www.death00.top/2020/06/07/%E5%89%91%E6%8C%87offer%2038%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <id>https://www.death00.top/2020/06/07/剑指offer 38——字符串的排列/</id>
    <published>2020-06-07T01:00:00.000Z</published>
    <updated>2020-06-07T10:54:23.280Z</updated>
    
    <content type="html"><![CDATA[<p>本题主要在于对回溯的理解，优化时可以结合 java 特性，以及排列的一些知识。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure></p><p>限制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= s 的长度 &lt;= 8</span><br></pre></td></tr></table></figure></p><p>原题url：<a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p>回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。</p><p>大家在解决经典的<code>八皇后</code>问题时，大多都会采用<code>回溯</code>进行解决。</p><p>本问题其实就是求所有字符的排列组合，针对这种问题，也可以利用<code>回溯</code>进行解决，但要求不能重复，因此需要进行<code>剪枝</code>。</p><p>比如字符串 <code>abc</code> ，如果让我们求所有排列，肯定是：</p><ol><li>先固定第 1 位，从 a 、b 、 c 中选一个，比如 a。</li><li>在以 a 为第 1 位的前提下，固定第 2 位，从 b 、 c 中选一个，比如 b。</li><li>此时第 3 位也没有可以选择的余地了，只剩下 c，这一步就走完了。</li><li>退回第 2 步，依旧在第 2 位，这次选择 c 。</li><li>此时第 3 位也没有可以选择的余地了，只剩下 b，这一步也走完了。</li><li>退回第 1 步。</li></ol><p>从上面，你可以总结出，正常的回溯，就是先走一条路，当结束后，退回上一步继续走，反复执行，直至退无可退，结束流程。</p><p>我们可以发现，最终是没有可以选择的余地，这在程序里可以理解为，运行到下一位时，不能使用之前使用过的数据，因此会涉及到字符交换。</p><p>但因为会进行回溯，所以数字可以在回溯后再换回去，从而不影响下一次的回溯。</p><p>那什么叫<code>剪枝</code>呢？就是要排除一些情况，针对本题，就是要排除重复的情况。</p><p>也就是在同一位置，不能出现两次相同的字符，因为第 2 次出现时，之前肯定已经针对这种情况，所有路线都已经走过了。</p><p>因此可以联想到使用<code>集合</code>，存储当前位置出现过的字符，如果重复，就可以直接跳过。</p><p>接下来我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] array;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        array = s.toCharArray();</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        backtrack(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 赋值给数组</span></span><br><span class="line">        String[] resultArray = <span class="keyword">new</span> String[result.size()];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String str : result) &#123;</span><br><span class="line">            resultArray[index] = str;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果是最后一个位置，就可以添加进result中</span></span><br><span class="line">        <span class="keyword">if</span> (index == array.length - <span class="number">1</span>) &#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> temp : array) &#123;</span><br><span class="line">                sb.append(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 保证不会重复</span></span><br><span class="line">            <span class="keyword">if</span> (set.contains(array[i])) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(array[i]);</span><br><span class="line">            <span class="comment">// 交换两者的位置</span></span><br><span class="line">            swap(index, i);</span><br><span class="line">            <span class="comment">// 固定下一个位置，继续寻找</span></span><br><span class="line">            backtrack(index + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 还原两者的位置</span></span><br><span class="line">            swap(i, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> newIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = array[index];</span><br><span class="line">        array[index] = array[newIndex];</span><br><span class="line">        array[newIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK。</p><p>分析一下复杂度：</p><ul><li>时间复杂度 <code>O(N!)</code> ： 这个比较好理解，长度为 N 的字符串，需要计算的次数是： <code>N * (N - 1) * (N - 2) * ... * 2 * 1</code>，结果也就是 N! 。</li><li>空间复杂度 <code>O(N^2)</code> ： 需要借助的额外空间，也就是那个保证不会重复所使用到的<code>set</code>，它所存储的总量，最差情况下，长度为 N 的字符串中，所有字符各不相同，也就需要 <code>N + (N - 1) + (N - 2) * ... * 2 * 1</code>，结果也就是 N^2。</li></ul><h3 id="java-优化"><a href="#java-优化" class="headerlink" title="java 优化"></a>java 优化</h3><p>针对上面代码中出现的 <code>char[]</code> 转 <code>String</code>，可以使用<code>String.valueOf(char[])</code>方法进行优化，因为该方法，最终会使用<code>System.arrayCopy</code>方法，该方法属于<code>native</code>方法，更加高效。</p><p>至于最终，将 list 转 array 的过程，可以用<code>list.toArray(String[])</code>做写法上的简化，性能上倒并没有什么提升。</p><p>优化后的代码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] array;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        array = s.toCharArray();</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        backtrack(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 赋值给数组</span></span><br><span class="line">        <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> String[result.size()]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果是最后一个位置，就可以添加进result中</span></span><br><span class="line">        <span class="keyword">if</span> (index == array.length - <span class="number">1</span>) &#123;</span><br><span class="line">            result.add(String.valueOf(array));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 保证不会重复</span></span><br><span class="line">            <span class="keyword">if</span> (set.contains(array[i])) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(array[i]);</span><br><span class="line">            <span class="comment">// 交换两者的位置</span></span><br><span class="line">            swap(index, i);</span><br><span class="line">            <span class="comment">// 固定下一个位置，继续寻找</span></span><br><span class="line">            backtrack(index + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 还原两者的位置</span></span><br><span class="line">            swap(i, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> newIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = array[index];</span><br><span class="line">        array[index] = array[newIndex];</span><br><span class="line">        array[newIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="继续优化"><a href="#继续优化" class="headerlink" title="继续优化"></a>继续优化</h3><p>其实到了，如果想进一步优化的话，可以针对 list 转 array 这里。</p><p>因为我们使用的是 LinkedList，内部存储的 String 对象在物理上是不连续的，在最后遍历时会相对比较耗时。</p><p>如果我们一开始就可以求出所有该字符串所能获得的所有不重复字符串的总个数的话，就可以提前构造一个 array，不需要在最后又遍历一次 list 了。</p><p>那么如何求出有重复字符的所有排列呢？假设是字符串<code>aabbc</code>，其求法为：</p><ol><li>假设先排 a ，一共 5 个位置，选 2 个位置，<code>C(5, 2) = (5 * 4) / (2 * 1) = 10</code>。</li><li>再排 b ，剩下 3 个位置里，选 2 个位置，<code>C(3, 2) = (3 * 2) /  (2 * 1) = 3</code>。</li><li>最后排 c ，剩下 1 个位置里，选 1 个位置，<code>C(1, 1) = 1</code>。</li><li>综上，一共有<code>10 * 3 * 1 = 30</code>种排列。</li></ol><p>接下来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>[] array;</span><br><span class="line">    String[] result;</span><br><span class="line">    <span class="keyword">int</span> resultIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        array = s.toCharArray();</span><br><span class="line">        <span class="comment">// 求出一共有多少种可能</span></span><br><span class="line">        <span class="keyword">int</span> totalCount = calculate();</span><br><span class="line">        result = <span class="keyword">new</span> String[totalCount];</span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        backtrack(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 赋值给数组</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 各字符出现的次数，默认只会出现26个英文字母</span></span><br><span class="line">        <span class="keyword">int</span>[] countArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> temp : array) &#123;</span><br><span class="line">            countArray[temp - <span class="string">'a'</span>] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 统计总次数</span></span><br><span class="line">        <span class="keyword">int</span> length = array.length;</span><br><span class="line">        <span class="keyword">int</span> totalCount = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> count : countArray) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 求排列</span></span><br><span class="line">            totalCount *= cc(length, count);</span><br><span class="line">            length -= count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">cc</span><span class="params">(<span class="keyword">int</span> total, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果count超过total的一半，则换成 (total - count)，因为在排列中，C(5, 4) = C(5, 1)</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; total / <span class="number">2</span>) &#123;</span><br><span class="line">            count = total - count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分别求分子、分母</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> result1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            result *= (total - i);</span><br><span class="line">            result1 *= (count - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result / result1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果是最后一个位置，就可以添加进result中</span></span><br><span class="line">        <span class="keyword">if</span> (index == array.length - <span class="number">1</span>) &#123;</span><br><span class="line">            result[resultIndex++] = String.valueOf(array);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 默认只会出现26个英文字母</span></span><br><span class="line">        <span class="keyword">boolean</span>[] exists = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 保证不会重复</span></span><br><span class="line">            <span class="keyword">if</span> (exists[array[i] - <span class="string">'a'</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            exists[array[i] - <span class="string">'a'</span>] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 交换两者的位置</span></span><br><span class="line">            swap(index, i);</span><br><span class="line">            <span class="comment">// 固定下一个位置，继续寻找</span></span><br><span class="line">            backtrack(index + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 还原两者的位置</span></span><br><span class="line">            swap(i, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> newIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = array[index];</span><br><span class="line">        array[index] = array[newIndex];</span><br><span class="line">        array[newIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，其执行时间最短，因此认为优化是有效的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。本题主要在于对回溯的理解，优化时可以结合 java 特性，以及排列的一些知识。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本题主要在于对回溯的理解，优化时可以结合 java 特性，以及排列的一些知识。&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://www.death00.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="排列组合" scheme="https://www.death00.top/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    
      <category term="回溯" scheme="https://www.death00.top/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 33——二叉搜索树的后序遍历序列</title>
    <link href="https://www.death00.top/2020/05/24/%E5%89%91%E6%8C%87offer%2033%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"/>
    <id>https://www.death00.top/2020/05/24/剑指offer 33——二叉搜索树的后序遍历序列/</id>
    <published>2020-05-24T01:00:00.000Z</published>
    <updated>2020-05-24T09:42:39.769Z</updated>
    
    <content type="html"><![CDATA[<p>本题主要在于考察对二叉搜索树和后序遍历的理解。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 <code>true</code>，否则返回 <code>false</code>。假设输入的数组的任意两个数字都互不相同。</p><p>参考以下这颗二叉搜索树：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  2   6</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure></p><p>示例 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,6,3,2,5]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,2,6,5]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>数组长度 &lt;= 1000</li></ul><p>原题url：<a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>首先介绍一些基本概念，方便后续做题。</p><ol><li>后序遍历：[ 左子树 | 右子树 | 根节点 ] ，即遍历顺序为 “左、右、根” 。</li><li>二叉搜索树： 左子树中所有节点的值 &lt; 根节点的值；右子树中所有节点的值 &gt; 根节点的值；其左、右子树也分别为二叉搜索树。</li></ol><h3 id="递归分治"><a href="#递归分治" class="headerlink" title="递归分治"></a>递归分治</h3><p>既然本题只提供了后序遍历，那么我们就要在此基础之上下功夫了。</p><p>根据上面的提供的说明，后序遍历是，先左右子树再根节点，那么根是容易判断的，肯定在整个序列的最后。</p><p>而二叉搜索树节点值满足，左子树 &lt; 根 &lt; 右子树，因此我们就可以以根为基础，从后向前遍历，。</p><p>一开始的节点肯定都大于根，因为都在右子树上，一旦出现小于根的节点，说明就进入了左子树，那么之后所有的节点都应该小于根。然后再分别遍历左右子树，直至到叶子节点为止（即无左右子树的节点）。</p><p>按照上面的方法，就需要我们将后序遍历分成左右子树，不断递归遍历检查。</p><p>接下来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> checkTree(postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkTree</span><span class="params">(<span class="keyword">int</span>[] postorder, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果start &gt;= end，说明已经寻找结束</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到根</span></span><br><span class="line">        <span class="keyword">int</span> root = postorder[end];</span><br><span class="line">        <span class="comment">// 左子树开始的下标</span></span><br><span class="line">        <span class="keyword">int</span> leftStart = start;</span><br><span class="line">        <span class="comment">// 左子树结束的下标</span></span><br><span class="line">        <span class="keyword">int</span> leftEnd = leftStart;</span><br><span class="line">                <span class="comment">// 找到第一个大于根节点的值</span></span><br><span class="line">        <span class="keyword">while</span> (leftEnd &lt; end &amp;&amp; postorder[leftEnd] &lt; root) &#123;</span><br><span class="line">            leftEnd++;</span><br><span class="line">        &#125;</span><br><span class="line">        leftEnd--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右子树开始的下标</span></span><br><span class="line">        <span class="keyword">int</span> rightStart = leftEnd + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 右子树结束的下标</span></span><br><span class="line">        <span class="keyword">int</span> rightEnd = end - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 检查右子树是否都大于根节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = rightStart; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (postorder[i] &gt; root) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续检查左右子树</span></span><br><span class="line">        <span class="keyword">return</span> checkTree(postorder, leftStart, leftEnd) &amp;&amp;</span><br><span class="line">                checkTree(postorder, rightStart, rightEnd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK。</p><p>分析一下复杂度：</p><ul><li>时间复杂度 <code>O(N^2)</code> ： 每次调用 checkTree 方法减去一个根节点，因此递归占用 O(N) ；最差情况下（即当树退化为链表），每轮递归都需遍历树所有节点，占用 O(N ^ 2) 。</li><li>空间复杂度 <code>O(N)</code> ： 最差情况下（即当树退化为链表），递归深度将达到 N 。</li></ul><h3 id="递增栈"><a href="#递增栈" class="headerlink" title="递增栈"></a>递增栈</h3><p>既然上面分析出时间复杂度为 <code>O(N^2)</code> ，那么是否可以找到一种更高效的方法，只遍历一次序列，就可以解决问题呢？因为这样可以在时间复杂度上进行很大的优化。</p><p>这就需要再进一步结合搜索二叉树和后序遍历的特性了。（这个方法我是在网上看到的，感觉属于一种比较偏门的优化，一般很难像出这种方法）</p><p>在我们从后向前遍历序列时，大致是经历了<code>根、右子树、左子树</code>，而<code>左子树 &lt; 根 &lt; 右子树</code>，那么一开始应该是单调递增的，我们可以将这些节点依次入栈。</p><p>当不满足<code>单调递增</code>调试时，一般是碰到了右子树中某一个左子树节点，或者真正的左子树，这时候可以将栈顶元素出栈，直到碰到比当前节点小的元素，那么将最后的栈顶元素设为<code>根节点</code>。</p><p>此时继续遍历，应该保证所有节点都小于根节点，因为此时已经进入左子树序列了。否则说明该序列不满足搜索二叉树的后序遍历。</p><p>重复以上步骤，如果遍历结束，说明满足搜索二叉树的后序遍历。</p><p>这么说可能比较难懂，直接上代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 单调递增栈</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> root = Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">// 倒序遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = postorder.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (postorder[i] &gt; root) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前栈不为空，且当前遍历的节点小于栈顶节点</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; </span><br><span class="line">                postorder[i] &lt; stack.peek()) &#123;</span><br><span class="line">                <span class="comment">// 栈顶节点压出，且更新根节点</span></span><br><span class="line">                root = stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前节点入栈</span></span><br><span class="line">            stack.push(postorder[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK。</p><p>分析一下复杂度：</p><ul><li>时间复杂度 <code>O(N)</code> ： 遍历 postorder 所有节点，各节点均入栈 / 出栈一次，使用 O(N) 时间。</li><li>空间复杂度 <code>O(N)</code> ： 最差情况下（即当树退化为链表），单调递增栈 stack 存储所有节点。</li></ul><p>神奇的是，力扣给出的执行结果显示：递归分治方法消耗的时间更短。这点大家也可以研究研究是为什么。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。本题主要在于考察对二叉搜索树和后序遍历的理解，递归分治是容易想出来的方法，但是后面那种单调递增栈确实很难想到，可以作为一种特殊思路进行理解。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本题主要在于考察对二叉搜索树和后序遍历的理解。&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://www.death00.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="栈" scheme="https://www.death00.top/tags/%E6%A0%88/"/>
    
      <category term="二叉树" scheme="https://www.death00.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
      <category term="后序遍历" scheme="https://www.death00.top/tags/%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>Java 线程池讲解——针对 IO 密集型任务</title>
    <link href="https://www.death00.top/2020/05/20/Java%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AE%B2%E8%A7%A3%E2%80%94%E2%80%94%E9%92%88%E5%AF%B9%20IO%20%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1/"/>
    <id>https://www.death00.top/2020/05/20/Java 线程池讲解——针对 IO 密集型任务/</id>
    <published>2020-05-20T01:00:00.000Z</published>
    <updated>2020-05-20T14:00:55.819Z</updated>
    
    <content type="html"><![CDATA[<p>针对  IO  密集型的任务，我们可以针对原本的线程池做一些改造，从而可以提高任务的处理效率。<br><a id="more"></a></p><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><p>在<code>阿里巴巴泰山版java开发手册</code>中有这么一条：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，</span><br><span class="line">这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</span><br></pre></td></tr></table></figure></p><p>那么如果要使用 ThreadPoolExecutor  ，那就先来看看构造方法中的所有入参：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">corePoolSize : 核心线程数，当线程池中的线程数量为 corePoolSize 时，即使这些线程处于空闲状态，也不会销毁（除非设置 allowCoreThreadTimeOut）。</span><br><span class="line">maximumPoolSize : 最大线程数，线程池中允许的线程数量的最大值。</span><br><span class="line">keepAliveTime : 线程空闲时间，当线程池中的线程数大于 corePoolSize 时，多余的空闲线程将在销毁之前等待新任务的最长时间。</span><br><span class="line">workQueue : 任务队列</span><br><span class="line">unit ： 线程空闲时间的单位。</span><br><span class="line">threadFactory ： 线程工厂，线程池创建线程时使用的工厂。</span><br><span class="line">handler : 拒绝策略，因达到线程边界和任务队列满时，针对新任务的处理方法。</span><br></pre></td></tr></table></figure></p><p>这么说可能有些难以理解，你可以结合下图进行参考：<br><img src="https://upload-images.jianshu.io/upload_images/5401975-4493820fd31f3127.png?imageMogr2/auto-orient/strip|imageView2/2/w/833/format/webp" alt=""></p><p>那么由此我们可以知道，当大量任务被放入线程池之后，先是被核心线程执行，多余的会被放进队列里，当队列满了之后才会创建额外的线程进行处理，再多就会采取拒绝策略。</p><p>但这样真的能满足我们的所有需求吗？</p><h2 id="任务的分类"><a href="#任务的分类" class="headerlink" title="任务的分类"></a>任务的分类</h2><p>正常来说，我们可以把需要处理的任务按照消耗资源的不同，分为两种：<code>CPU 密集型</code>和<code>IO 密集型</code>。</p><h2 id="CPU-密集型"><a href="#CPU-密集型" class="headerlink" title="CPU 密集型"></a>CPU 密集型</h2><p>既然名字里带有<code>CPU</code>了，说明其消耗的主要资源就是 CPU 了。</p><p>具体是指那种包含大量运算、在持有的 CPU 分配的时间片上一直在执行任务、几乎不需要依赖或等待其他任何东西。</p><p>这样的任务，在我的理解中，处理起来其实没有多少优化空间，因为处理时几乎没有等待时间，所以一直占有 CPU 进行执行，才是最好的方式。</p><p>唯一能想到优化的地方，就是当单个线程累计较多任务时，其他线程能进行分担，类似<code>fork/join框架</code>的概念。</p><p>设置线程数时，针对单台机器，最好就是有几个 CPU ，就创建几个线程，然后每个线程都在执行这种任务，永不停歇。</p><h2 id="IO-密集型"><a href="#IO-密集型" class="headerlink" title="IO 密集型"></a>IO 密集型</h2><p>和上面一样，既然名字里带有<code>IO</code>了，说明其消耗的主要资源就是 IO 了。</p><p>我们所接触到的 IO ，大致可以分成两种：<code>磁盘 IO</code>和<code>网络 IO</code>。</p><p>磁盘 IO ，大多都是一些针对磁盘的读写操作，最常见的就是文件的读写，假如你的数据库、 Redis 也是在本地的话，那么这个也属于磁盘 IO。</p><p>网络 IO ，这个应该是大家更加熟悉的，我们会遇到各种网络请求，比如 http 请求、远程数据库读写、远程 Redis 读写等等。</p><p>IO 操作的特点就是需要等待，我们请求一些数据，由对方将数据写入<code>缓冲区</code>，在这段时间中，需要读取数据的线程根本无事可做，因此可以把 CPU 时间片让出去，直到<code>缓冲区</code>写满。</p><p>既然这样，IO 密集型任务其实就有很大的优化空间了（毕竟存在等待），那现有的线程池可以很好的满足我们的需求吗？</p><h3 id="线程池的优化"><a href="#线程池的优化" class="headerlink" title="线程池的优化"></a>线程池的优化</h3><p>还记得上面说的， ThreadPoolExecutor 针对多余任务的处理，是先放到等待队列中，当队列塞满后，再创建额外的线程进行处理。</p><p>假设我们的任务基本都是 IO 密集型，我们希望程序可以有更高的吞吐量，可以在更短的时间内处理更多的任务，那么上面的 ThreadPoolExecutor 明显是不满足我们的需求，那该如何解决呢？</p><p>也许再来看看 ThreadPoolExecutor 的 execute 方法，会让我们有一些思路：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 如果当前活跃线程数，小于核心线程数</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// 则优先创建线程</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果任务可以成功放入队列中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不可以成功放入队列，则创建线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        <span class="comment">// 如果无法继续创建线程，则拒绝任务</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>针对放入队列的操作，如果队列放入失败，线程池就会选择去创建线程了。因此，我们或许可以尝试自定义线程池，针对 offer 操作，做一些自定义处理。</p><p>也就是将任务放入队列时，先检查线程池的线程数是否小于最大线程数，如果是，则拒绝放入队列，否则，再尝试放入队列中。</p><p>如果你有看过 dubbo 或者 tomcat 的线程池，你会发现他们就有这样的实现方法。</p><p>比如 dubbo 中的 TaskQueue，我们来看看它的 offer 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"The task queue does not have executor!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> currentPoolThreadSize = executor.getPoolSize();</span><br><span class="line">    <span class="comment">// 如果有空闲等待的线程，则将任务放入队列中，让线程去处理任务</span></span><br><span class="line">    <span class="keyword">if</span> (executor.getSubmittedTaskCount() &lt; currentPoolThreadSize) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.offer(runnable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前线程数小于最大线程数，则返回 false ，让线程池去创建新的线程</span></span><br><span class="line">    <span class="keyword">if</span> (currentPoolThreadSize &lt; executor.getMaximumPoolSize()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则，就将任务放入队列中</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.offer(runnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就可以让线程池优先新建线程了。需要注意的时，此时的队列因为需要根据线程池中的线程数决定是否放入任务成功，所以需要持有<code>executor</code>对象，这点不要忘记奥。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本篇文章，主要是让大家重新了解了一下 ThreadPoolExecutor ，并针对高吞吐场景下如何进行局部优化。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;针对  IO  密集型的任务，我们可以针对原本的线程池做一些改造，从而可以提高任务的处理效率。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.death00.top/tags/Java/"/>
    
      <category term="线程池" scheme="https://www.death00.top/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 31——栈的压入、弹出序列</title>
    <link href="https://www.death00.top/2020/05/18/%E5%89%91%E6%8C%87offer%2031%E2%80%94%E2%80%94%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/"/>
    <id>https://www.death00.top/2020/05/18/剑指offer 31——栈的压入、弹出序列/</id>
    <published>2020-05-18T01:00:00.000Z</published>
    <updated>2020-05-19T13:43:41.048Z</updated>
    
    <content type="html"><![CDATA[<p>本题主要在于考察栈的特性，优化时可以考虑自己实现一个栈。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p><p>示例 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：我们可以按以下顺序执行：</span><br><span class="line">push(1), push(2), push(3), push(4), pop() -&gt; 4,</span><br><span class="line">push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br></pre></td></tr></table></figure></p><p>示例 2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 不能在 2 之前弹出。</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>0 &lt;= pushed.length == popped.length &lt;= 1000</li><li>0 &lt;= pushed[i], popped[i] &lt; 1000</li><li>pushed 是 popped 的排列。</li></ul><p>原题url：<a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="借用现成的Stack类"><a href="#借用现成的Stack类" class="headerlink" title="借用现成的Stack类"></a>借用现成的Stack类</h3><p>既然本题是要判断进栈、出栈序列是否匹配，那么我们可以直接用现成的<code>Stack</code>类进行模拟。</p><p>栈的特性是<code>先入后出</code>，因此入栈的数字，想进行出栈：</p><ol><li>进栈之后立刻出栈</li><li>进栈之后，等待后面进栈的数字全部出栈后，再进行出栈</li></ol><p>那模拟的时候，就可以遍历进栈序列，先让当前数字进栈，然后开始让栈中数字出栈，如果满足出栈序列，则可以继续出栈，直到不能出栈。</p><p>让我们来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 模拟栈</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 出栈下标</span></span><br><span class="line">        <span class="keyword">int</span> popIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历入栈序列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushed.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 先让当前数字入栈</span></span><br><span class="line">            stack.push(pushed[i]);</span><br><span class="line">            <span class="comment">// 遍历栈</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() == popped[popIndex]) &#123;</span><br><span class="line">                popIndex++;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> popIndex == pushed.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK。</p><p>复杂度分析：<br>时间复杂度 O(N)： 其中 N 为列表 pushed 的长度；每个元素最多入栈与出栈一次，即最多共 2N 次出入栈操作。忽略系数后，得出 O(N)。<br>空间复杂度 O(N)： 辅助栈 stack 最多同时存储 N 个元素。</p><h3 id="自己实现一个简单的栈结构"><a href="#自己实现一个简单的栈结构" class="headerlink" title="自己实现一个简单的栈结构"></a>自己实现一个简单的栈结构</h3><p>上面我们使用了 Java 中现成的类 Stack，但因为我们这里的场景十分简单，而 Stack 会考虑到扩容、并发修改的情况，所以相应会对性能有一定的影响。因此我们完全可以利用数组设计一个符合本题的、简单的栈结构。</p><p>其实代码和上面类似，但因为是直接使用数组实现的，因此在大数量下，性能上可以快很多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validateStackSequences</span><span class="params">(<span class="keyword">int</span>[] pushed, <span class="keyword">int</span>[] popped)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 利用数组实现一个栈</span></span><br><span class="line">    <span class="keyword">int</span> stack[] = <span class="keyword">new</span> <span class="keyword">int</span>[pushed.length];</span><br><span class="line">    <span class="comment">// 栈中的元素个数</span></span><br><span class="line">    <span class="keyword">int</span> stackSize = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 出栈序列被遍历到的下标</span></span><br><span class="line">    <span class="keyword">int</span> poppedIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历入栈序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushed.length; i++) &#123;</span><br><span class="line">        stack[stackSize] = pushed[i];</span><br><span class="line">        stackSize++;</span><br><span class="line">        <span class="comment">// 栈内有数据，并且栈顶元素等于当前出栈序列中的数字</span></span><br><span class="line">        <span class="keyword">while</span> (stackSize != <span class="number">0</span> &amp;&amp; stack[stackSize - <span class="number">1</span>] == popped[poppedIndex]) &#123;</span><br><span class="line">            <span class="comment">// 出栈</span></span><br><span class="line">            stackSize--;</span><br><span class="line">            <span class="comment">// 继续比较下一个</span></span><br><span class="line">            poppedIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> poppedIndex == popped.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提交OK，复杂度和上面完全相同。</p><p>当然，这道题的难度还有可以提高的地方，原题中有<code>假设压入栈的所有数字均不相等</code>，如果允许数字重复的话，你可以想到要怎么解决吗？</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。本题主要在于考察栈的特性，优化时可以考虑自己实现一个栈。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本题主要在于考察栈的特性，优化时可以考虑自己实现一个栈。&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://www.death00.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="栈" scheme="https://www.death00.top/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 16——数值的整数次方</title>
    <link href="https://www.death00.top/2020/05/13/%E5%89%91%E6%8C%87offer%2016%E2%80%94%E2%80%94%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"/>
    <id>https://www.death00.top/2020/05/13/剑指offer 16——数值的整数次方/</id>
    <published>2020-05-13T01:00:00.000Z</published>
    <updated>2020-05-14T13:55:30.006Z</updated>
    
    <content type="html"><![CDATA[<p>这道题可以利用二进制，就可以快速解决了。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p><p>示例 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 2.00000, 10</span><br><span class="line">输出: 1024.00000</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 2.10000, 3</span><br><span class="line">输出: 9.26100</span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2.00000, -2</span><br><span class="line">输出: 0.25000</span><br><span class="line">解释: 2-2 = 1/2^2 = 1/4 = 0.25</span><br></pre></td></tr></table></figure></p><p>说明：</p><ul><li>-100.0 &lt; x &lt; 100.0</li><li>n 是 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1] 。</li></ul><p>原题url：<a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>这道题，如果你是用正常计算的话，提交之后会发现报超时，因此，肯定需要寻找捷径的。</p><p>因为不能使用库函数，而且上面普通方法也是会超时的，那么问题的关键就是在如何快速计算。</p><p>而如果想快的，最好的办法就是可以利用曾经计算的结果，避免重复计算。</p><p>我一开始的想法是，比如计算 2^6 ，从数学上来说，等同于计算 4^3。但如果要用这种逻辑的话，就必须要求传入参数 n 是 2^w（其中 w 是正整数），否则计算逻辑会比较复杂。因此放弃该方案。</p><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>重点依旧是放在<code>利用曾经计算的结果，避免重复计算</code>上，那么理想情况也就是计算 x^n 后，之后希望直接计算 x^2n，而<code>x^2n = x^n * x^n = x^(n + n)</code>。</p><p>从上面的讨论可以看出，计算幂，可以转换成将指数进行合理的加法拆分。所谓<code>合理</code>，就是后一个是前一个的 2 倍，这样的话，就自然联想到要对指数从<code>十进制</code>转为<code>二进制</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7 = (111) = 1 * 2^2 + 1 * 2^1 + 1 * 2^0</span><br><span class="line">9 = (1001) = 1 * 2^3 + 0 * 2^2 + 0 * 2^1 + 1 * 2^0</span><br></pre></td></tr></table></figure><p>当然，上面是从大到小累加，实际计算时肯定是从小到大进行累加的。</p><p>说到二进制，肯定少不了位运算，那么计算每一位二进制上的值，有什么快速的方法呢？</p><p>有的，利用<code>n &amp; 1</code>，求出最低位的值（0或者1），然后<code>n &gt;&gt; 1</code>，右移，相当于移除最低位，不停循环，也就能计算出二进制上每一位的值了。</p><p>接下来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处用long，是防止n是Integer.MIN_VALUE时，取反后直接就超过了Integer.MAX_VALUE</span></span><br><span class="line">        <span class="keyword">long</span> b = n;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            b = -b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                res *= x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 底数扩大</span></span><br><span class="line">            x *= x;</span><br><span class="line">            <span class="comment">// 指数右移</span></span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题利用二进制，就可以快速解决了。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题可以利用二进制，就可以快速解决了。&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://www.death00.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="二进制" scheme="https://www.death00.top/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 14——剪绳子</title>
    <link href="https://www.death00.top/2020/05/10/%E5%89%91%E6%8C%87offer%2014%E2%80%94%E2%80%94%E5%89%AA%E7%BB%B3%E5%AD%90/"/>
    <id>https://www.death00.top/2020/05/10/剑指offer 14——剪绳子/</id>
    <published>2020-05-10T01:00:00.000Z</published>
    <updated>2020-05-10T02:46:32.577Z</updated>
    
    <content type="html"><![CDATA[<p>这道题的一般解法是动态规划，优化时可以尝试找规律。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 <code>k[0],k[1]...k[m]</code> 。请问 <code>k[0]*k[1]*...*k[m]</code> 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p>示例 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: 1</span><br><span class="line">解释: 2 = 1 + 1, 1 × 1 = 1</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 10</span><br><span class="line">输出: 36</span><br><span class="line">解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36</span><br></pre></td></tr></table></figure></p><p>提示：</p><ul><li>2 &lt;= n &lt;= 58</li></ul><p>原题url：<a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/jian-sheng-zi-lcof</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="动态规划-DP"><a href="#动态规划-DP" class="headerlink" title="动态规划 DP"></a>动态规划 DP</h3><p>我们想想，本题要求是计算 n 被分成 m 份后，相乘最大的结果，这比较明显可以看出是需要求一定要求下的最优解，那么如果能求出局部最优解的话，也能求出方便求出最终最优解。讲白了，就是一个个试，但需要保证需要将所有情况都计算过，且不要重复计算。</p><p>那这就要利用动态规划的思想了，从初始情况开始，一步步递推。假设绳子长度为 x ，其最大乘积为 f(x)，则有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f(2) = 1; (1 * 1)</span><br><span class="line">f(3) = 2; (1 * 2)</span><br><span class="line">f(4) = 4; (2 * 2)</span><br><span class="line">f(5) = 6; (3 * 2)</span><br><span class="line">f(6) = 9; (3 * 3)</span><br><span class="line">f(7) = 12; (3 * 2 * 2 = 3 * f(4))</span><br><span class="line">f(8) = 18; (3 * 3 * 2 = f(6) * 2 = 3 * f(5))</span><br></pre></td></tr></table></figure></p><p>自己先试着写出初始的情况，然后从中找出规律：</p><ol><li>长度1、2、3，并没有继续分隔的必要，其作为整体，直接参与计算应该就是最大的数字了。</li><li>长度4，分隔成2、2是比较合理的。</li><li>当长度越长，被分隔成的数量越多时，其实可以想象成将其中多段合并成1段，最后都是可以当做分隔成2段来计算的。</li></ol><p>因此，根据上面总结出来的规律，我们应该是需要从小开始计算，并将中间结果保留，因此可以用一个数组进行存储。</p><p>我们来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录计算结果，第2位代表长度为2的绳子，其最大乘积</span></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        result[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        result[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 默认初始值就是剪成两段：1 和 i-1，所以最大乘积是 i-1</span></span><br><span class="line">            result[i] = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = Math.max(result[i - j], i - j);</span><br><span class="line">                <span class="keyword">int</span> y = Math.max(result[j], j);</span><br><span class="line">                result[i] = Math.max(x * y, result[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK。</p><h3 id="数学推导的极致优化"><a href="#数学推导的极致优化" class="headerlink" title="数学推导的极致优化"></a>数学推导的极致优化</h3><p>这个解法，我也是看了别人的解析才知道的，通过代码提交发现结论确实是正确的，但其中的推导过程我也没有看懂，看看原文：</p><p><img src="https://imgkr.cn-bj.ufileos.com/f299c9b1-62ef-40d2-8536-3dc7d5fc4d92.png" alt=""><br><img src="https://imgkr.cn-bj.ufileos.com/166cc4c8-3b1b-444d-bd6c-bb9a9e053599.png" alt=""></p><p>接下来我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可以被3分成几段</span></span><br><span class="line">        <span class="keyword">int</span> count = n / <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 剩余的数字</span></span><br><span class="line">        <span class="keyword">int</span> remain = n % <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 如果没有剩余的</span></span><br><span class="line">        <span class="keyword">if</span> (remain == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 直接计算当前的值</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">3</span>, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果剩1，则和原本的一个3，重新拆分成2和2，因为2 * 2 &gt; 3 * 1</span></span><br><span class="line">        <span class="keyword">if</span> (remain == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">3</span>, count - <span class="number">1</span>) * <span class="number">2</span> * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果剩2，则正常乘</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">3</span>, count) * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题的一般解法是动态规划，优化时可以尝试找规律，数学推导出其中当然是最快的，但这需要一定的功底。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题的一般解法是动态规划，优化时可以尝试找规律。&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://www.death00.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="动态规划" scheme="https://www.death00.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 13——机器人的运动范围</title>
    <link href="https://www.death00.top/2020/05/08/%E5%89%91%E6%8C%87offer%2013%E2%80%94%E2%80%94%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
    <id>https://www.death00.top/2020/05/08/剑指offer 13——机器人的运动范围/</id>
    <published>2020-05-08T01:00:00.000Z</published>
    <updated>2020-05-10T02:45:54.102Z</updated>
    
    <content type="html"><![CDATA[<p>这道题本质还是搜索，因此可以使用深度优先搜索和广度优先搜索进行解决。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>地上有一个m行n列的方格，从坐标 <code>[0,0]</code> 到坐标 <code>[m-1,n-1]</code> 。一个机器人从坐标 <code>[0, 0]</code> 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：m = 2, n = 3, k = 1</span><br><span class="line">输出：3</span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：m = 3, n = 1, k = 0</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;= n,m &lt;= 100</li><li>0 &lt;= k &lt;= 20</li></ul><p>原题url：<a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>从一个点出发，遍历完所有点，为了保证不会重复遍历，因此我们可以借助一个二维矩阵记录已经遍历过的点。而用深度优先搜索遍历的话，一般都是使用<code>递归</code>的。</p><p>需要注意的是，虽然机器人可以上下左右移动，但因为是从<code>[0, 0]</code>开始的，所以可以想象成根节点往子节点或兄弟节点的遍历方式，深度优先搜索就是先遍历子节点，子节点遍历完成后，在遍历兄弟节点。</p><p>终止条件应该有：</p><ol><li>坐标越界，也就是 <code>x &gt;= m</code> 或者 <code>y &gt;= n</code> 。</li><li>该点已经访问过，既然访问过，自然不用重新计算。</li><li>坐标数字之和大于 <code>k</code> </li></ol><p>求数字各数位之和，最简单的方法应该就是 <code>摸除% + 整除/</code> 就可以了。</p><p>我们来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = m &gt; n ? m : n;</span><br><span class="line">        <span class="comment">// key为数字，value为该数字各位之和</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; numMap = <span class="keyword">new</span> HashMap&lt;&gt;(max * <span class="number">4</span> / <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 记录已经访问过的节点</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="comment">// 从(0, 0)开始移动</span></span><br><span class="line">        <span class="keyword">return</span> move(<span class="number">0</span>, <span class="number">0</span>, m, n, k, numMap, visited);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k, Map&lt;Integer, Integer&gt; numMap, <span class="keyword">boolean</span>[][] visited)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 是否越界</span></span><br><span class="line">        <span class="keyword">if</span> (x &gt;= m || y &gt;= n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果该节点已经访问过</span></span><br><span class="line">        <span class="keyword">if</span> (visited[x][y] == <span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 说明该方格所代表的次数已经被计算过，因此返回0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记该节点已经访问过</span></span><br><span class="line">        visited[x][y] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 计算</span></span><br><span class="line">        <span class="keyword">int</span> xSum = getNumSum(x, numMap);</span><br><span class="line">        <span class="keyword">int</span> ySum = getNumSum(y, numMap);</span><br><span class="line">        <span class="keyword">if</span> (xSum + ySum &gt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试向下、向右</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + move(x + <span class="number">1</span>, y, m, n, k, numMap, visited) + move(x, y + <span class="number">1</span>, m, n, k, numMap, visited);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumSum</span><span class="params">(<span class="keyword">int</span> num, Map&lt;Integer, Integer&gt; numMap)</span> </span>&#123;</span><br><span class="line">        Integer sum = numMap.get(num);</span><br><span class="line">        <span class="keyword">if</span> (sum != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> key = num;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">            sum += num % <span class="number">10</span>;</span><br><span class="line">            num = num / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        numMap.put(key, sum);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK。我们来看看这种方法的复杂度：</p><ul><li>时间复杂度 <code>O(MN)</code> ： 最差情况下，机器人遍历矩阵所有单元格，此时时间复杂度为 O(MN)。</li><li>空间复杂度 <code>O(MN)</code> ： visited 矩阵的大小就是 mn，因此使用了 O(MN) 的额外空间。</li></ul><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>广度优先搜索，也就是从根节点出发，先遍历兄弟节点，再遍历子节点。一般我们都需要借助一个队列存储已经即将要遍历的节点，因为队列的特性是先进先出，因此当父节点遍历完成后，会依序遍历所有该父节点的所有子节点（这些节点都是兄弟），再遍历下一层的子节点。</p><p>（PS：现在想想，如果用栈存储已经遍历过的节点，也是可以的，只是访问节点的方式并没有什么规律可言。）</p><p>针对该机器人的运动，也是从 <code>[0, 0]</code> 出发，向下向右移动，层层递进。</p><p>接下来我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = m &gt; n ? m : n;</span><br><span class="line">        <span class="comment">// key为数字，value为该数字各位之和</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; numMap = <span class="keyword">new</span> HashMap&lt;&gt;(max * <span class="number">4</span> / <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 记录已经访问过的节点</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="comment">// 记录还未访问结束的点</span></span><br><span class="line">        Queue&lt;Coordinate&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 从(0, 0)开始移动</span></span><br><span class="line">        queue.offer(<span class="keyword">new</span> Coordinate(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 获取队首元素</span></span><br><span class="line">            Coordinate coordinate = queue.poll();</span><br><span class="line">            <span class="comment">// 判断当前坐标是否有效</span></span><br><span class="line">            <span class="keyword">if</span> (coordinate.x &gt;= m || coordinate.y &gt;= n) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断当前左边是否已经访问过</span></span><br><span class="line">            <span class="keyword">if</span> (visited[coordinate.x][coordinate.y]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 标记当前坐标已经访问过</span></span><br><span class="line">            visited[coordinate.x][coordinate.y] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">// 判断当前坐标是否有效</span></span><br><span class="line">            <span class="keyword">int</span> xSum = getNumSum(coordinate.x, numMap);</span><br><span class="line">            <span class="keyword">int</span> ySum = getNumSum(coordinate.y, numMap);</span><br><span class="line">            <span class="keyword">if</span> (xSum + ySum &gt; k) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果有效</span></span><br><span class="line">            result++;</span><br><span class="line">            <span class="comment">// 将下边一格节点放入队列中</span></span><br><span class="line">            queue.add(<span class="keyword">new</span> Coordinate(coordinate.x + <span class="number">1</span>, coordinate.y));</span><br><span class="line">            <span class="comment">// 将右边一格节点放入队列中</span></span><br><span class="line">            queue.add(<span class="keyword">new</span> Coordinate(coordinate.x, coordinate.y + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumSum</span><span class="params">(<span class="keyword">int</span> num, Map&lt;Integer, Integer&gt; numMap)</span> </span>&#123;</span><br><span class="line">        Integer sum = numMap.get(num);</span><br><span class="line">        <span class="keyword">if</span> (sum != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> key = num;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">            sum += num % <span class="number">10</span>;</span><br><span class="line">            num = num / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        numMap.put(key, sum);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Coordinate</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Coordinate</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            <span class="keyword">this</span>.y = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK。我们来看看这种方法的复杂度：</p><ul><li>时间复杂度 <code>O(MN)</code> ： 最差情况下，机器人遍历矩阵所有单元格，此时时间复杂度为 O(MN)。</li><li>空间复杂度 <code>O(MN)</code> ： visited 矩阵的大小就是 mn，因此使用了 O(MN) 的额外空间。</li></ul><p>既然上下两种方法时间复杂度相同，但比较奇怪的在于，我在力扣上提交时，上面一种方法所花费的时间是 <code>1ms</code> ，但这种方法所花费的时间是 <code>7ms</code> 。既然复杂度的计算是忽略了系数、低阶、常数，但我认为上下两种方法即使不忽略，应该也是一样的。 <code>如果你有新的看法，欢迎指教。</code></p><h3 id="求坐标之和"><a href="#求坐标之和" class="headerlink" title="求坐标之和"></a>求坐标之和</h3><p>求坐标之和的方法，我写的是比较简单的一种，但如果你好好想想，就可以发现有更简单的方法。</p><p>正常情况下，随着数字逐渐变大，数字各位之和应该也是逐渐上升的，但唯一的特殊情况就是 <code>进位</code> ，比如 19 变到 20 ，各数位之和从 10 变为 2，其实细心点就可以发现，十位数虽然加1，但个位数减9，因此总体减8。所以可以总结出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">假设现在的数字为x，其各位数之和为Sum(x)，那么下一个Sum(x + 1)为：</span><br><span class="line">Sum(x + 1) = ((x + 1) % 10 == 0) ? (Sum(x) - 8) : (Sum(x) + 1)</span><br></pre></td></tr></table></figure><p>那么上面的代码还有可以优化的地方，这个就留给大家去完成了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题本质还是搜索，因此可以使用深度优先搜索和广度优先搜索进行解决。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题本质还是搜索，因此可以使用深度优先搜索和广度优先搜索进行解决。&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://www.death00.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="深度优先搜索" scheme="https://www.death00.top/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
      <category term="广度优先搜索" scheme="https://www.death00.top/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>力扣289——生命游戏</title>
    <link href="https://www.death00.top/2020/05/06/%E5%8A%9B%E6%89%A3289%E2%80%94%E2%80%94%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/"/>
    <id>https://www.death00.top/2020/05/06/力扣289——生命游戏/</id>
    <published>2020-05-06T13:00:00.000Z</published>
    <updated>2020-05-06T13:39:54.669Z</updated>
    
    <content type="html"><![CDATA[<p>这道题还是比较简单的，只要针对数组进行正常遍历即可。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>根据 百度百科 ，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。</p><p>给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p><ol><li>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；</li><li>如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；</li><li>如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；</li><li>如果死细胞周围正好有三个活细胞，则该位置死细胞复活；</li></ol><p>根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入： </span><br><span class="line">[</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,1],</span><br><span class="line">  [1,1,1],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [0,1,1],</span><br><span class="line">  [0,1,0]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>进阶：</p><ul><li>你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。</li><li>本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？</li></ul><p>原题url：<a href="https://leetcode-cn.com/problems/game-of-life/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/game-of-life/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="复制-遍历"><a href="#复制-遍历" class="headerlink" title="复制 + 遍历"></a>复制 + 遍历</h3><p>因为<code>细胞的出生和死亡是同时发生的</code>，所以我们在更新时，只能根据上一个状态进行判定。</p><p>因此，正常思路应该就是复制一个一模一样的数组，然后遍历这个复制的数组，进行条件判断，修改原数组。</p><p>我们来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先复制一份</span></span><br><span class="line">        <span class="keyword">int</span>[][] copyBoard = <span class="keyword">new</span> <span class="keyword">int</span>[board.length][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            copyBoard[i] = <span class="keyword">new</span> <span class="keyword">int</span>[board[i].length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[i].length; j++) &#123;</span><br><span class="line">                copyBoard[i][j] = board[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历copyBoard，更新board</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; copyBoard.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; copyBoard[i].length; j++) &#123;</span><br><span class="line">                <span class="comment">// 求出当前细胞周围8个位置的活细胞个数</span></span><br><span class="line">                <span class="keyword">int</span> aliveCount = -copyBoard[i][j];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> row = -<span class="number">1</span>; row &lt;= <span class="number">1</span> &amp;&amp; i + row &lt;= copyBoard.length - <span class="number">1</span>; row++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i + row &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> col = -<span class="number">1</span>; col &lt;= <span class="number">1</span> &amp;&amp; j + col &lt;= copyBoard[i].length - <span class="number">1</span>; col++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (j + col &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        aliveCount += copyBoard[i + row][j + col];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 规则1、3</span></span><br><span class="line">                <span class="keyword">if</span> (aliveCount &lt; <span class="number">2</span> || aliveCount &gt; <span class="number">3</span>) &#123;</span><br><span class="line">                    <span class="comment">// 该位置细胞死亡</span></span><br><span class="line">                    board[i][j] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 规则2、4</span></span><br><span class="line">                <span class="keyword">if</span> ((copyBoard[i][j] == <span class="number">1</span> &amp;&amp; aliveCount &gt;= <span class="number">2</span> &amp;&amp; aliveCount &lt;= <span class="number">3</span>) || (copyBoard[i][j] == <span class="number">0</span> &amp;&amp; aliveCount == <span class="number">3</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 该位置细胞存活</span></span><br><span class="line">                    board[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK。</p><h3 id="原地算法"><a href="#原地算法" class="headerlink" title="原地算法"></a>原地算法</h3><p>因为题目中给出了：<code>用原地算法解决本题</code>，所以我们是否可以仅使用原数组进行解决呢？</p><p>肯定是可以的，我们只需要将所有可能的情况都考虑好即可。</p><p>原本只有0（死亡）、1（存活）两种状态，现在因为涉及到当前时间和下一次时间，因此我们增加两种状态：</p><ul><li>-1：代表这个细胞过去是活的现在死了</li><li>2：代表这个细胞过去是死的现在活了</li></ul><p>所以我们在进行遍历的时候，需要增加这两种状态的判断，并直接修改原始数组。看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] neighbors = &#123;<span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rows = board.length;</span><br><span class="line">        <span class="keyword">int</span> cols = board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历面板每一个格子里的细胞</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; cols; col++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 对于每一个细胞统计其八个相邻位置里的活细胞数量</span></span><br><span class="line">                <span class="keyword">int</span> liveNeighbors = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!(neighbors[i] == <span class="number">0</span> &amp;&amp; neighbors[j] == <span class="number">0</span>)) &#123;</span><br><span class="line">                            <span class="comment">// 相邻位置的坐标</span></span><br><span class="line">                            <span class="keyword">int</span> r = (row + neighbors[i]);</span><br><span class="line">                            <span class="keyword">int</span> c = (col + neighbors[j]);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 查看相邻的细胞是否是活细胞</span></span><br><span class="line">                            <span class="keyword">if</span> ((r &lt; rows &amp;&amp; r &gt;= <span class="number">0</span>) &amp;&amp; (c &lt; cols &amp;&amp; c &gt;= <span class="number">0</span>) &amp;&amp; (Math.abs(board[r][c]) == <span class="number">1</span>)) &#123;</span><br><span class="line">                                liveNeighbors += <span class="number">1</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 规则 1 或规则 3 </span></span><br><span class="line">                <span class="keyword">if</span> ((board[row][col] == <span class="number">1</span>) &amp;&amp; (liveNeighbors &lt; <span class="number">2</span> || liveNeighbors &gt; <span class="number">3</span>)) &#123;</span><br><span class="line">                    <span class="comment">// -1 代表这个细胞过去是活的现在死了</span></span><br><span class="line">                    board[row][col] = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 规则 4</span></span><br><span class="line">                <span class="keyword">if</span> (board[row][col] == <span class="number">0</span> &amp;&amp; liveNeighbors == <span class="number">3</span>) &#123;</span><br><span class="line">                    <span class="comment">// 2 代表这个细胞过去是死的现在活了</span></span><br><span class="line">                    board[row][col] = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 board 得到一次更新后的状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; cols; col++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[row][col] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    board[row][col] = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    board[row][col] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，相较于上面的方法，这种解法的空间消耗更少。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题主要是针对数组的处理，外加一些状态的定义即可。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题还是比较简单的，只要针对数组进行正常遍历即可。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="找规律" scheme="https://www.death00.top/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"/>
    
      <category term="数组" scheme="https://www.death00.top/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>马拉车算法</title>
    <link href="https://www.death00.top/2020/03/06/%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/"/>
    <id>https://www.death00.top/2020/03/06/马拉车算法/</id>
    <published>2020-03-06T02:00:00.000Z</published>
    <updated>2020-03-07T06:13:59.757Z</updated>
    
    <content type="html"><![CDATA[<p>针对最长回文子串相关的问题，马拉车算法应该是比较通用的解法，今天我们就来具体看看这个算法。<br><a id="more"></a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>马拉车算法(Manacher‘s Algorithm)是用来查找一个字符串的最长回文子串的线性方法，由一个叫 Manacher 的人在1975年发明的，这个方法的最大贡献是在于将时间复杂度提升到了线性。</p></blockquote><p>这个算法最厉害的地方是在于能够在<code>线性时间</code>内解决问题。一般我们解决最长回文子串，不可避免都要进行回溯之类的操作，那么时间复杂度一定是大于线性的。</p><p>而马拉车算法的主要思路是维护一个跟原字符串 str 长度一样的数组 lens，lens[i] 表示以 str[i] 为中点的回串其中一边的长度。</p><p>在这里，有的人把中点算进去，有的人记录两边的长度，其实都是一样的。我在这里是只记录一边的长度，不包括中点。比如<code>CDCDE</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str:  [C, D, C, D, E]</span><br><span class="line">lens: [0, 1, 1, 0, 0]</span><br></pre></td></tr></table></figure></p><p>那么 lens 里最大的自然就对应最长回串的中点了。所以这个算法的核心就是如何快速计算 lens。</p><h2 id="具体思路"><a href="#具体思路" class="headerlink" title="具体思路"></a>具体思路</h2><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>回文有奇偶长度两种情况，通过补充间隔符可以将这两种情况化简为奇数长度。</p><p>比如：</p><blockquote><p><code>ABA</code>补充为<code>^#A#B#A#$</code>，中点还是 B。<br><code>ABBA</code>补充为<code>^#A#B#B#A#$</code>，中点为 #，最后可以去掉。</p></blockquote><p>针对间隔符，首先要确保在字符串中不会出现，这里我是确保字符串中不会出现<code>^、#、$</code>。</p><p>原字符串中每一个字符都会被<code>#</code>包围，这样就确保现在的字符串长度一定是奇数。</p><p>至于在开头增加<code>^</code>，在结尾增加<code>$</code>，这样是为了确保从任意一个位置开始检查回文时，一定会遇到不一样的时候，从而退出循环。而且也方便我们计算原字符的下标，直接除以2即可。</p><p>写法是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"cbcbccde"</span>;</span><br><span class="line"><span class="keyword">char</span>[] T = <span class="keyword">new</span> <span class="keyword">char</span>[str.length() * <span class="number">2</span> + <span class="number">3</span>];</span><br><span class="line">T[<span class="number">0</span>] = <span class="string">'^'</span>;</span><br><span class="line">T[<span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line">T[T.length - <span class="number">1</span>] = <span class="string">'$'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">    <span class="keyword">char</span> charStr = str.charAt(i);</span><br><span class="line">    T[<span class="number">2</span> * i + <span class="number">2</span>] = charStr;</span><br><span class="line">    T[<span class="number">2</span> * i + <span class="number">3</span>] = <span class="string">'#'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="计算长度数组"><a href="#计算长度数组" class="headerlink" title="计算长度数组"></a>计算长度数组</h3><p>这就是算法的关键了，它充分利用了回文串的对称性。</p><p>我们用 C 表示回文串的中心，用 R 表示回文串的右边半径。所以 R = C + P[ i ] 。C 和 R 所对应的回文串是当前循环中 R 最靠右的回文串。用 i_mirror 表示当前需要求的第 i 个字符关于 C 对应的下标。</p><p>让我们考虑求 P [ i ] 的时候：</p><p><img src="https://pic1.zhimg.com/80/v2-11f96d39d9648b7c146e49cdceb0854c_720w.jpg" alt=""></p><p>我们可以利用回文串 C 的对称性。i 关于 C 的对称点是 i_mirror ，P [ i_mirror ] = 3，所以 P [ i ] 也等于 3 。</p><p>但需要考虑特殊情况：</p><h4 id="P-i-mirror-i-gt-R"><a href="#P-i-mirror-i-gt-R" class="headerlink" title="P [ i_mirror ] + i &gt;= R"></a>P [ i_mirror ] + i &gt;= R</h4><p>如下图：</p><p><img src="https://pic2.zhimg.com/80/v2-70833cbd20c51a98257b5bf3a8c53985_720w.jpg" alt=""></p><p>当我们要求 P [ i ] 的时候，P [ mirror ] = 7，而此时 P [ i ] 并不等于 7 ，为什么呢，因为我们从 i 开始往后数 7 个，等于 22 ，已经超过了最右的 R ，此时不能利用对称性了，但我们一定可以扩展到 R 的，所以 P [ i ] 至少等于 R - i = 20 - 15 = 5，会不会更大呢，我们只需要比较 T [ R+1 ] 和 T [ R+1 ]关于 i 的对称点就行了，就像中心扩展法一样一个个扩展。</p><h4 id="i-mirror-P-i-mirror-0"><a href="#i-mirror-P-i-mirror-0" class="headerlink" title="i_mirror - P [ i_mirror ] == 0"></a>i_mirror - P [ i_mirror ] == 0</h4><p>如下图：</p><p><img src="https://pic4.zhimg.com/80/v2-8eb77a3735fb23e67a51e320a47e636b_720w.jpg" alt=""></p><p>此时P [ i_mirror ] = 1，但是 P [ i ] 赋值成 1 是不正确的，出现这种情况的原因是 P [ i_mirror ] 在扩展的时候首先是 “#” == “#” ，之后遇到了 “^”和另一个字符比较，也就是到了边界，才终止循环的。而 P [ i ] 并没有遇到边界，所以我们可以继续通过中心扩展法一步一步向两边扩展就行了。</p><h4 id="C-和-R-的更新"><a href="#C-和-R-的更新" class="headerlink" title="C 和 R 的更新"></a>C 和 R 的更新</h4><p>既然知道如何计算长度数组了，那最关键的 C 和 R 到底什么时候需要更新呢？</p><p><code>i + P [ i ] &gt; R</code>时，也就是当求出的 P [ i ] 的右边界大于当前的 R 时，我们就需要更新 C 和 R 为当前的回文串了。因为我们必须保证 i 在 R 里面，所以一旦有更右边的 R 就要更新 R。</p><h3 id="最终写法"><a href="#最终写法" class="headerlink" title="最终写法"></a>最终写法</h3><p>假设我们要写一个方法，传入参数是原字符串<code>s</code>，返回值是各个字符对应的最长回文子串长度数组，那么具体方法就是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] calSubstrings(String s) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存放新的内容</span></span><br><span class="line">    <span class="keyword">char</span>[] content = <span class="keyword">new</span> <span class="keyword">char</span>[s.length() * <span class="number">2</span> + <span class="number">3</span>];</span><br><span class="line">    <span class="comment">// 开头用^</span></span><br><span class="line">    content[<span class="number">0</span>] = <span class="string">'^'</span>;</span><br><span class="line">    <span class="comment">// s中的每一个字符要用#包围</span></span><br><span class="line">    content[<span class="number">1</span>] = <span class="string">'#'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        content[i * <span class="number">2</span> + <span class="number">2</span>] = s.charAt(i);</span><br><span class="line">        content[i * <span class="number">2</span> + <span class="number">3</span>] = <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结尾用$</span></span><br><span class="line">    content[content.length - <span class="number">1</span>] = <span class="string">'$'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前的回文串中心下标</span></span><br><span class="line">    <span class="keyword">int</span> center = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当前的回文串右边界</span></span><br><span class="line">    <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 存储以每一个位置为中心，所能获得的最长回文子串的长度</span></span><br><span class="line">    <span class="keyword">int</span>[] maxLength = <span class="keyword">new</span> <span class="keyword">int</span>[content.length];</span><br><span class="line">    <span class="comment">// 首尾两个字符没有必要计算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">1</span>; index &lt; content.length - <span class="number">1</span>; index++) &#123;</span><br><span class="line">        <span class="comment">// 如果当前求解的位置，在右边界以内</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 则其最长回文子串的长度，至少为：</span></span><br><span class="line">            maxLength[index] = Math.min(</span><br><span class="line">                    <span class="comment">// 对称center的位置上的</span></span><br><span class="line">                    maxLength[center * <span class="number">2</span> - index],</span><br><span class="line">                    <span class="comment">// 或者当前位置到右边界的距离</span></span><br><span class="line">                    right - index</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正常求解，向左右扩展</span></span><br><span class="line">        <span class="keyword">while</span> (content[index + (maxLength[index] + <span class="number">1</span>)] ==</span><br><span class="line">                content[index - (maxLength[index] + <span class="number">1</span>)]) &#123;</span><br><span class="line">            maxLength[index]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前index对应的右边界，比现有的right大</span></span><br><span class="line">        <span class="keyword">if</span> (index + maxLength[index] &gt; right) &#123;</span><br><span class="line">            <span class="comment">// 更新右边界和中心</span></span><br><span class="line">            right = index + maxLength[index];</span><br><span class="line">            center = index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终的结果</span></span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        result[i] = maxLength[i * <span class="number">2</span> + <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是我关于马拉车算法的理解，用来解决最长回文子串的问题，简直就是一把利器。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;针对最长回文子串相关的问题，马拉车算法应该是比较通用的解法，今天我们就来具体看看这个算法。&lt;br&gt;
    
    </summary>
    
    
      <category term="马拉车算法" scheme="https://www.death00.top/tags/%E9%A9%AC%E6%8B%89%E8%BD%A6%E7%AE%97%E6%B3%95/"/>
    
      <category term="最长回文子串" scheme="https://www.death00.top/tags/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>设计模式——单例模式</title>
    <link href="https://www.death00.top/2020/03/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.death00.top/2020/03/05/设计模式——单例模式/</id>
    <published>2020-03-05T02:00:00.000Z</published>
    <updated>2020-03-05T14:18:42.549Z</updated>
    
    <content type="html"><![CDATA[<p>关于单例模式，这是面试时最容易遇到的问题。当时以为很简单的内容，深挖一下，也可以关联出类加载、序列化等知识。<br><a id="more"></a></p><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>我们先来看看基本的饿汉式写法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hungry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Hungry instance = <span class="keyword">new</span> Hungry();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Hungry</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hungry <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>优点：写法简答，不需要考虑多线程等问题。</p><p>缺点：如果该实例从未被用到的话，相当于资源浪费。</p><h3 id="static-代码块"><a href="#static-代码块" class="headerlink" title="static 代码块"></a>static 代码块</h3><p>我们也可以用 static 代码块的方式，实现饿汉式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hungry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Hungry instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Hungry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Hungry</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Hungry <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这就是利用了 static 代码块的功能：<code>它是随着类的加载而执行，只执行一次，并优先于主函数。</code></p><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>我们先来看看基本的懒汉式写法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lazy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Lazy instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Lazy</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Lazy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Lazy.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Lazy();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里就涉及到了很多知识点，让我们一一讲解。</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">这里使用 volatile，主要是为了禁止指令重排序。</span><br><span class="line"></span><br><span class="line">主要就是针对 instance = new Lazy(); 这1行命令，在 JVM 中至少对应3条指令：</span><br><span class="line">1. 给 instance 分配内存空间。</span><br><span class="line">2. 调用 Lazy 的构造方法等来初始化 instance。</span><br><span class="line">3. 将 instance 对象指向分配的内存空间（执行完这一步，instance 就不是 null 了）。</span><br><span class="line"></span><br><span class="line">这里需要注意，JVM 会对指令进行优化排序，就是第 2 步与第 3 步的顺序是不一定的，可能是 1-2-3 ，也可能是 1-3-2 。</span><br><span class="line"></span><br><span class="line">如果是后者，可能1个线程执行完 1-3 之后，另一个线程进入了</span><br></pre></td></tr></table></figure><p>以上这一段想必就是大家平常看到的解释了，原本我对此也是深信不疑的，但是因为本地一直无法复现，因此让我产生了怀疑。</p><p>查阅资料后，可能是和以下两点有关。</p><h4 id="Intel-64-IA-32架构下的内存访问重排序"><a href="#Intel-64-IA-32架构下的内存访问重排序" class="headerlink" title="Intel 64/IA-32架构下的内存访问重排序"></a>Intel 64/IA-32架构下的内存访问重排序</h4><p>指令重排发生在处理器平台，对于Java来说是看不到的，因为Jvm基于线程栈，所有的读写都对应了 store 操作，而Intel 64/IA-32架构下处理器不需要LoadLoad、LoadStore、StoreStore屏障，因此不会发生需要这三种屏障的重排序。所以，store 操作之间是不会重排序的。</p><h4 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h4><p>JMM 抽象地将内存分为主内存和本地内存，各个线程有各自的本地内存。</p><p>如果2个线程在执行<code>Lazy.getInstance()</code>方法，<code>instance</code>作为 static 修改的变量，处于主内存中，两个线程会各自复制<code>instance</code>到本地内存中，当线程1执行<code>instance = new Lazy();</code>方法，除非全部结束，否则不会将本地内存中的<code>instance</code>写回主内存中。</p><p>以上也可能是我想错了，但欢迎大家一起探讨。</p><h3 id="double-check"><a href="#double-check" class="headerlink" title="double-check"></a>double-check</h3><p>为什么要有双重检查呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第二个 if 判定：是为了保证当有两个线程同时通过了第一个 if 判定，一个线程获取到锁，生成了 Lazy 的一个实例，然后第二个线程获取到锁，如果没有第二个 if 判断，那么此时会再次生成生成 Lazy 的一个实例。</span><br><span class="line">第一个 if 判定：是为了保证多线程同时执行，如果没有第一个 if 判断，所有线程都会串行执行，效率低下。</span><br></pre></td></tr></table></figure></p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>也可以利用静态内部类来实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lazy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Lazy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerLazy</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Lazy INSTANCE = <span class="keyword">new</span> Lazy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Lazy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerLazy.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为什么这样能实现懒加载呢？</p><p>因为只有当调用<code>InnerLazy.INSTANCE</code>时，才会对 InnnerLazy 类进行初始化，然后才会调用 Lazy 的构造方法，这也是由<code>类加载机制</code>保证的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">遇到 new 、getstatic、putstatic 或者 invokestatic 这 4 条字节码指令时，如果没有对类进行初始化，则需要先触发其初始化。</span><br><span class="line">这4个指令对应的 Java 场景是：使用 new 新建一个 Java 对象，访问或者设置一个类的静态字段，访问一个类的静态方法的时候。</span><br></pre></td></tr></table></figure></p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>以上方法的优缺点：</p><p>优点：使用的时候才会进行初始化，拥有更好的资源优化。</p><p>缺点：</p><ol><li>除去最后一种<code>静态内部类</code>之外，写法都比较繁琐。</li><li>如果使用反射或者反序列化，依旧可以强制生成新的实例。</li></ol><p>针对第2点，我们可以举例子来说明一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lazy</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Lazy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        name = String.valueOf(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerLazy</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Lazy INSTANCE = <span class="keyword">new</span> Lazy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Lazy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerLazy.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Lazy print : "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        Lazy instance1 = Lazy.getInstance();</span><br><span class="line">        instance1.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反射</span></span><br><span class="line">        Lazy instance3 = Lazy.class.newInstance();</span><br><span class="line">        instance3.print();</span><br><span class="line">        System.out.println(instance1 == instance3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"file"</span>));</span><br><span class="line">        oos.writeObject(instance1);</span><br><span class="line">        oos.close();</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"file"</span>));</span><br><span class="line">        Lazy instance2 = (Lazy) ois.readObject();</span><br><span class="line">        instance2.print();</span><br><span class="line">        System.out.println(instance1 == instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Lazy print : 1583410057762</span><br><span class="line">Lazy print : 1583410057768</span><br><span class="line">false</span><br><span class="line">Lazy print : 1583410057762</span><br><span class="line">false</span><br></pre></td></tr></table></figure></p><p>说明反射和反序列化，都会破坏以上写法的单例特征。那该如何解决呢？</p><ol><li>针对反射，解决起来比较简单，可以在构造方法中判断一下 InnerLazy.INSTANCE ，如果不为 null ，则抛出异常。</li><li>针对反序列化，可以实现接口 Serializable ，重写 readResolve 方法，返回单例对象 InnerLazy.INSTANCE。</li></ol><p>看看修改后的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lazy</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Lazy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (InnerLazy.INSTANCE != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"can not be invoked"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        name = String.valueOf(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerLazy</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Lazy INSTANCE = <span class="keyword">new</span> Lazy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Lazy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerLazy.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Lazy print : "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerLazy.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        Lazy instance1 = Lazy.getInstance();</span><br><span class="line">        instance1.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"file"</span>));</span><br><span class="line">        oos.writeObject(instance1);</span><br><span class="line">        oos.close();</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"file"</span>));</span><br><span class="line">        Lazy instance2 = (Lazy) ois.readObject();</span><br><span class="line">        instance2.print();</span><br><span class="line">        System.out.println(instance1 == instance2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反射</span></span><br><span class="line">        Lazy instance3 = Lazy.class.newInstance();</span><br><span class="line">        instance3.print();</span><br><span class="line">        System.out.println(instance1 == instance3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Lazy print : 1583409803987</span><br><span class="line">Lazy print : 1583409803987</span><br><span class="line">true</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: can not be invoked</span><br><span class="line">    at singleton.Lazy.&lt;init&gt;(Lazy.java:11)</span><br><span class="line">    at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">    at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span><br><span class="line">    at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span><br><span class="line">    at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span><br><span class="line">    at java.lang.Class.newInstance(Class.java:442)</span><br><span class="line">    at singleton.Lazy.main(Lazy.java:46)</span><br></pre></td></tr></table></figure></p><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>针对上面的缺点，我们也可以用 enum 解决。来看看写法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> singleton;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        name = String.valueOf(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Lazy print : "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, IOException </span>&#123;</span><br><span class="line">        Singleton instance1 = Singleton.INSTANCE;</span><br><span class="line">        instance1.print();</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        String content = objectMapper.writeValueAsString(instance1);</span><br><span class="line">        Singleton instance3 = objectMapper.readValue(content, Singleton.class);</span><br><span class="line">        System.out.println(instance1 == instance3);</span><br><span class="line">        instance3.print();</span><br><span class="line">        <span class="comment">// 反射</span></span><br><span class="line">        Singleton instance2 = Singleton.class.newInstance();</span><br><span class="line">        System.out.println(instance1 == instance2);</span><br><span class="line">        instance2.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Lazy print : 1583409004276</span><br><span class="line">true</span><br><span class="line">Lazy print : 1583409004276</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.InstantiationException: singleton.Singleton</span><br><span class="line">    at java.lang.Class.newInstance(Class.java:427)</span><br><span class="line">    at singleton.Singleton.main(Singleton.java:31)</span><br><span class="line">Caused by: java.lang.NoSuchMethodException: singleton.Singleton.&lt;init&gt;()</span><br><span class="line">    at java.lang.Class.getConstructor0(Class.java:3082)</span><br><span class="line">    at java.lang.Class.newInstance(Class.java:412)</span><br><span class="line">    ... 1 more</span><br></pre></td></tr></table></figure></p><p>首先，枚举是不能被反射生成实例的，这也就解决了<code>反射破坏单例</code>的问题。</p><p>其次，在序列化枚举类型时，只会存储枚举类的引用和枚举常量的名称。随后的反序列化的过程中，这些信息被用来在运行时环境中查找存在的枚举类型对象，这也就解决了<code>序列化破坏单例</code>的问题。</p><p>但需要注意：<code>这种方法属于饿汉模式</code>，所以有浪费资源的隐患，但如果你的单例对象并不占用资源，没有状态变量，那么这种方式就很适合你。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是我关于单例模式的一些理解，简单的问题，也可以关联出并发、类加载、序列化等重要知识。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于单例模式，这是面试时最容易遇到的问题。当时以为很简单的内容，深挖一下，也可以关联出类加载、序列化等知识。&lt;br&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://www.death00.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="单例模式" scheme="https://www.death00.top/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>力扣621——任务调度器</title>
    <link href="https://www.death00.top/2020/02/21/%E5%8A%9B%E6%89%A3621%E2%80%94%E2%80%94%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/"/>
    <id>https://www.death00.top/2020/02/21/力扣621——任务调度器/</id>
    <published>2020-02-21T02:00:00.000Z</published>
    <updated>2020-02-22T03:39:38.670Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要是找规律，优化的时候可以采用贪心算法的思想。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。</p><p>然而，两个<code>相同种类</code>的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p><p>你需要计算完成所有任务所需要的<code>最短时间</code>。</p><p>示例 1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 2</span><br><span class="line">输出: 8</span><br><span class="line">执行顺序: A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B.</span><br></pre></td></tr></table></figure></p><p>注：</p><ol><li>任务的总个数为 [1, 10000]。</li><li>n 的取值范围为 [0, 100]。</li></ol><p>原题url：<a href="https://leetcode-cn.com/problems/task-scheduler/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/task-scheduler/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="找规律"><a href="#找规律" class="headerlink" title="找规律"></a>找规律</h3><p>这道题的思路，正向推导的话，其实就是优先排出现次数多的任务，根据间隔 n ，填充任务，直到所有任务的次数最终都减为0。</p><p>因此，我们可以用数组存储任务的总次数（因为用大写英文字母表示任务，那就代表最多只能有26种任务），排序之后，按照间隔 n ，从大到小取任务，取完后，再对数组排序，重复上述取任务的过程，直到数组的最大值为0。</p><p>接下来我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="keyword">char</span>[] tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将task放入数组中</span></span><br><span class="line">        <span class="keyword">int</span>[] countArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> task: tasks) &#123;</span><br><span class="line">            countArray[task - <span class="string">'A'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从小到大，进行排序</span></span><br><span class="line">        Arrays.sort(countArray);</span><br><span class="line">        <span class="comment">// 最终耗时</span></span><br><span class="line">        <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 从大到小开始遍历</span></span><br><span class="line">        <span class="keyword">while</span> (countArray[<span class="number">25</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 每次遍历前n个数</span></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">                <span class="comment">// 说明所有任务已经执行完成</span></span><br><span class="line">                <span class="keyword">if</span> (countArray[<span class="number">25</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 遍历</span></span><br><span class="line">                <span class="keyword">if</span> (i &lt; <span class="number">26</span> &amp;&amp; countArray[<span class="number">25</span> - i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    countArray[<span class="number">25</span> - i]--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 耗时+1</span></span><br><span class="line">                time++;</span><br><span class="line">                <span class="comment">// 更换任务</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从小到大排序</span></span><br><span class="line">            Arrays.sort(countArray);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，但执行时间上确实不太好，只打败了<code>47.62%</code>的 java 执行时间，其时间复杂度为<code>O(time)</code>， time 代表最终的执行时间。</p><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>我们再来想想这道题，影响最终执行时间的，有两个因素，一个是任务中出现的最大次数，另一个就是间隔 n 了。</p><p>如果我们站在最多任务的角度，来看这个问题，假设其最大次数为 maxCount，那么该任务所需的最短执行时间为<code>(maxCount - 1) * (n + 1) + 1</code>，如果还有其他 i 个和 maxCount 相同次数的任务，那么需要在最终的结果上再加上 i。</p><p>那么上面求出来的就是正确答案了吗？</p><p>并不是，因为上面的最短时间，是当剩余时间片能够塞满任务数小于 maxCount 的所有任务。假设 n 很小，那么剩余任务肯定需要在任务数等于 maxCount 的那些任务执行完之后，还要继续执行。</p><p>但因为最大任务已经可以满足在间隔时间内执行完，那么出现次数小于 maxCount 的任务，肯定可以连续执行完成的，也就是不需要空闲等待时间。那么此时的最短执行时间也就是总任务数了。</p><p>接下来我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="keyword">char</span>[] tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tasks.length == <span class="number">0</span> || n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> tasks.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将task放入数组中</span></span><br><span class="line">        <span class="keyword">int</span>[] countArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> task : tasks) &#123;</span><br><span class="line">            countArray[task - <span class="string">'A'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从小到大，进行排序</span></span><br><span class="line">        Arrays.sort(countArray);</span><br><span class="line">        <span class="comment">// 获取最大次数</span></span><br><span class="line">        <span class="keyword">int</span> maxCount = countArray[<span class="number">25</span>];</span><br><span class="line">        <span class="comment">// 如果其他次数都比maxCount小的话，求出针对maxCount的最短时间</span></span><br><span class="line">        <span class="keyword">int</span> result = (maxCount - <span class="number">1</span>) * (n + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 遍历countArray</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">25</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 如果有和maxCount相同的，则执行时间+1</span></span><br><span class="line">            <span class="keyword">if</span> (countArray[i] == maxCount) &#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则，直接结束</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果总任务数比理论上的最短时间长，说明任务很多，但可以把每个桶填满，因此最短时间也就是总任务数</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(result, tasks.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK ，在所有 Java 提交中击败了<code>100.00%</code>的用户，确实快了很多。其时间复杂度为<code>O(M)</code>，M 代表总任务数。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题主要是找规律，优化的时候可以采用贪心算法的思想。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要是找规律，优化的时候可以采用贪心算法的思想。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="找规律" scheme="https://www.death00.top/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"/>
    
      <category term="贪心算法" scheme="https://www.death00.top/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>力扣739——每日温度</title>
    <link href="https://www.death00.top/2020/02/21/%E5%8A%9B%E6%89%A3739%E2%80%94%E2%80%94%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/"/>
    <id>https://www.death00.top/2020/02/21/力扣739——每日温度/</id>
    <published>2020-02-21T02:00:00.000Z</published>
    <updated>2020-03-01T07:06:17.958Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要是找规律，优化的时候可以利用数据结构的特性（数组和栈）。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>根据每日<code>气温</code>列表，请重新生成一个列表，对应位置的输入是你需要再等待多久，温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。</p><p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p><p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p><p>原题url：<a href="https://leetcode-cn.com/problems/daily-temperatures/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/daily-temperatures/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>如果正向思考的话，就是从前向后遍历，将温度存储在一个优先级队列中（小顶堆），队列中的结构需要记录温度和天数。</p><p>遍历时需要找到队列中最小的值是否大于当前温度，如果大于，则更新结果；如果小于，则将当前记录放入队列中。</p><p>接下来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="comment">// 以温度为排序依据的小顶堆，温度越低越靠前</span></span><br><span class="line">        PriorityQueue&lt;Node&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Comparator.comparingInt(o -&gt; o.temperature));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; T.length; index++) &#123;</span><br><span class="line">            Node node = <span class="keyword">new</span> Node();</span><br><span class="line">            node.temperature = T[index];</span><br><span class="line">            node.index = index;</span><br><span class="line">            <span class="comment">// 放入队列中</span></span><br><span class="line">            queue.add(node);</span><br><span class="line">            <span class="comment">// 取队列中最小的元素</span></span><br><span class="line">            Node newNode = queue.peek();</span><br><span class="line">            <span class="comment">// 如果队列中最低温度就是当前温度</span></span><br><span class="line">            <span class="keyword">if</span> (newNode.temperature == node.temperature) &#123;</span><br><span class="line">                <span class="comment">// 说明queue中没有比当前温度低的天</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 最低温度比当前低，满足情况</span></span><br><span class="line">            <span class="keyword">while</span> (newNode.temperature &lt; node.temperature) &#123;</span><br><span class="line">                <span class="comment">// 更新T，并且移除</span></span><br><span class="line">                T[newNode.index] = node.index - newNode.index;</span><br><span class="line">                queue.remove();</span><br><span class="line">                newNode = queue.peek();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列中剩余的节点，都对应0</span></span><br><span class="line">        Iterator&lt;Node&gt; iterator = queue.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Node node = iterator.next();</span><br><span class="line">            T[node.index] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temperature;</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，时间复杂度为<code>O(n)</code>，但小顶堆的更新也是需要时间的，因此还是有可以优化的地方。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>因为题目中给出了：<code>每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数</code>，所以我们可以用一个长度为100的数组存储气温对应的天数。</p><p>这样我们就需要从后向前遍历了，将气温对应的天数记录在数组中，这样每向前遍历一个，就遍历一次这个长度为<code>100</code>的数组，如果有比当前温度高的，则更新结果，否则就记为0。</p><p>虽然每次都要遍历一次长度为<code>100</code>的数组，但因为数组查询的时间复杂度为<code>O(1)</code>，所以速度是很快的。接下来我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="comment">// 最终结果</span></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">        <span class="comment">// 因为温度不超过100度，所以温度对应的天数存储在这个数组中</span></span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">101</span>];</span><br><span class="line">        Arrays.fill(next, Integer.MAX_VALUE);</span><br><span class="line">        <span class="comment">// 从后向前遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = T.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="comment">// 比当前温度更高的下标</span></span><br><span class="line">            <span class="keyword">int</span> warmerIndex = Integer.MAX_VALUE;</span><br><span class="line">            <span class="comment">// 从next数组中查找比当前温度高的天数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> t = T[i] + <span class="number">1</span>; t &lt;= <span class="number">100</span>; ++t) &#123;</span><br><span class="line">                <span class="comment">// 找出天数最小的一个</span></span><br><span class="line">                <span class="keyword">if</span> (next[t] &lt; warmerIndex) &#123;</span><br><span class="line">                    warmerIndex = next[t];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果有找到，则更新result</span></span><br><span class="line">            <span class="keyword">if</span> (warmerIndex &lt; Integer.MAX_VALUE) &#123;</span><br><span class="line">                result[i] = warmerIndex - i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在next数组中记录当前的温度</span></span><br><span class="line">            next[T[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，这里其实就够了，但有没有其他更方便的数据结构呢？</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>我们主要想知道的，就是最近的比当前温度高的天数，这样的需求，感觉栈应该是可以满足的，因为先进后出。</p><p>我们还是从后向前遍历，在栈中存储气温的天数，当前遍历到的温度，如果比栈顶的存储的天数对应的温度高，那么栈中存储的是没有意义的；如果比它低，那么就可以更新结果了。</p><p>接下来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="comment">// 用栈存储温度的下标</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 最终的结果</span></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">        <span class="comment">// 从后向前遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = T.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 如果当前温度大于栈顶的温度</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; T[i] &gt;= T[stack.peek()]) &#123;</span><br><span class="line">                <span class="comment">// 因为当前温度比栈顶存储的温度高，</span></span><br><span class="line">                <span class="comment">// 栈顶元素也没有存储的意义，所以出栈</span></span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果栈为空，则结果为0</span></span><br><span class="line">            <span class="comment">// 如果栈不为空，则用当前栈顶存储的温度</span></span><br><span class="line">            result[i] = stack.isEmpty() ? <span class="number">0</span> : (stack.peek() - i);</span><br><span class="line">            <span class="comment">// 让当前的温度入栈</span></span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，时间复杂度和上面的方法相同，但空间复杂度理论上是会比上面小的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题主要是找规律，优化的时候可以利用数据结构的特性（数组和栈）。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要是找规律，优化的时候可以利用数据结构的特性（数组和栈）。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="找规律" scheme="https://www.death00.top/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>力扣560——和为K的子数组</title>
    <link href="https://www.death00.top/2020/02/19/%E5%8A%9B%E6%89%A3560%E2%80%94%E2%80%94%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>https://www.death00.top/2020/02/19/力扣560——和为K的子数组/</id>
    <published>2020-02-19T02:00:00.000Z</published>
    <updated>2020-02-22T03:38:42.003Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要是找规律，优化的时候可以利用哈希表和数组的特性。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p><p>示例 1 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入:nums = [1,1,1], k = 2</span><br><span class="line">输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</span><br></pre></td></tr></table></figure></p><p>说明 :</p><ol><li>数组的长度为 [1, 20,000]。</li><li>数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。</li></ol><p>原题url：<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/subarray-sum-equals-k/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>一开始的想法肯定就是利用暴力解法了，三层 for 循环的那种，第1层和第2层选择起点和终点，第3层则是计算起点到终点的总和。这样的想法最简单，但很可惜，直接超时了，让我们稍微优化一下。</p><h3 id="子数组之和"><a href="#子数组之和" class="headerlink" title="子数组之和"></a>子数组之和</h3><p>因为题目要求子数组下标连续，那么我们想想，如果要求<code>sum(i, j)</code>(也就是从下标 i 到下标 j 的子数组之和)，其实可以转化成<code>sum(0, i - 1) - sum(0, j)</code>。这样的话，就可以把上面的三层for循环优化成两层。</p><p>接下来我们直接看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// sum(i, j) = sum(0, j) - sum(0, i - 1)</span></span><br><span class="line">        <span class="keyword">int</span>[] sumArray = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        sumArray[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sumArray[i] = sumArray[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = sumArray.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 前i个数之和</span></span><br><span class="line">            <span class="keyword">if</span> (sumArray[i] == k) &#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 查询从(j + 1)到i的和</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; j != i; j--) &#123;</span><br><span class="line">                sum = sumArray[i] - sumArray[j];</span><br><span class="line">                <span class="keyword">if</span> (sum == k) &#123;</span><br><span class="line">                    result++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，但时间复杂度是<code>O(n^2)</code>，优化一下。</p><h3 id="用哈希表优化"><a href="#用哈希表优化" class="headerlink" title="用哈希表优化"></a>用哈希表优化</h3><p>我们想想，上面使用使用第二层for循环，主要是为了查出 sumArray 中是否还存在等于<code>sumArray[i] - k</code>的数，这明显是一个映射关系，因此我们用一个 map 去记录中间的求和结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// sum(i, j) = sum(0, j) - sum(0, i - 1)</span></span><br><span class="line">        <span class="comment">// 用map存储，key为sum，value为第i个数</span></span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(nums.length * <span class="number">4</span> / <span class="number">3</span> + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 数组求和</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录一共有哪些和</span></span><br><span class="line">        Set&lt;Integer&gt; sumSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            sumSet.add(sum);</span><br><span class="line">            <span class="comment">// 查看当前是否已经记录</span></span><br><span class="line">            List&lt;Integer&gt; indexList = map.get(sum);</span><br><span class="line">            <span class="keyword">if</span> (indexList == <span class="keyword">null</span>) &#123;</span><br><span class="line">                indexList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            indexList.add(i);</span><br><span class="line">            map.put(sum, indexList);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer subSum : sumSet) &#123;</span><br><span class="line">            List&lt;Integer&gt; list = map.get(subSum);</span><br><span class="line">            <span class="comment">// 如果list为null，说明是被移除了，说明之前已经计算过</span></span><br><span class="line">            <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (subSum == k) &#123;</span><br><span class="line">                result += map.get(subSum).size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 剩余的和</span></span><br><span class="line">            <span class="keyword">int</span> remainSum = subSum - k;</span><br><span class="line">            List&lt;Integer&gt; remainList = map.get(remainSum);</span><br><span class="line">            <span class="comment">// 如果为null，说明不存在</span></span><br><span class="line">            <span class="keyword">if</span> (remainList == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果不为null，说明存在，则可以进行配对</span></span><br><span class="line">            <span class="comment">// 让list和remainList进行配对</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index1 : list) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> index2 : remainList) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (index1 &lt;= index2) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    result++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提交OK，虽然较之前的方法时间效率上有所提高，但并没有本质区别。特别是最后的双重 for 循环，因为下标只有大的减小的才有意义，这样也就给自己额外增加了运算。</p><p>那么反思一下，是否真的有必要提前算好子数组的和？如果一边遍历一边求和，并将求和的结果存入map中，那么 map 中存在的，一定是下标小于自己的求和结果。针对这点，我们可以再做一步优化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 最终结果的数量</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 求和</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// key为中间求出了哪些和，value为当前和有几种情况</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 和为0有1中情况，就是一个数都不选</span></span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 求和</span></span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="comment">// map中是否有记录剩余的值</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(sum - k)) &#123;</span><br><span class="line">                <span class="comment">// 累加，此处可以直接添加，是因为求和是从前往后进行的，现在能找到的，说明一定是之前的</span></span><br><span class="line">                count += map.get(sum - k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录当前的值</span></span><br><span class="line">            map.put(sum, map.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，这样时间复杂度就变为了<code>O(n)</code>。</p><h3 id="数据结构的优化"><a href="#数据结构的优化" class="headerlink" title="数据结构的优化"></a>数据结构的优化</h3><p>现在，我们用哈希表来存储中间结果。虽然哈希表的查找效率理论上可以达到<code>O(1)</code>，但考虑到哈希冲突，最坏情况下还是有可能达到<code>O(n)</code>。真正能够保证达到<code>O(1)</code>的数据结构，是数组（用空间换取时间）。</p><p>那这个用来存储的一维数组究竟长度该设置为多少呢？自然就是找出数组中子数组之和的最大值和最小值，两者求差，结果就是最终的数组长度。利用这个数组去存储子数组求和的结果，这样就能保证在查找时的效率了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// sum的最小值和最大值，因为可以一个数值都不选，因此0作为初始值</span></span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 求和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            sum += n;</span><br><span class="line">            min = Math.min(min, sum);</span><br><span class="line">            max = Math.max(max, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sums[i]代表从下标为0到下标为i的子数组之和</span></span><br><span class="line">        <span class="comment">// 用一个数组存储，相比于map，取值更快，用空间换取时间</span></span><br><span class="line">        <span class="keyword">int</span>[] sums = <span class="keyword">new</span> <span class="keyword">int</span>[max - min + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 最终结果</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="comment">// 需要重新求和，因为没有类似set这样的结构存储了结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            <span class="comment">// 求和</span></span><br><span class="line">            sum += n;</span><br><span class="line">            <span class="comment">// 新的目标值</span></span><br><span class="line">            <span class="keyword">int</span> target = sum - min - k;</span><br><span class="line">            <span class="comment">// 是否有超过范围</span></span><br><span class="line">            <span class="keyword">if</span> (target &gt;= <span class="number">0</span> &amp;&amp; target &lt; sums.length) &#123;</span><br><span class="line">                count += sums[target];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sums[sum - min]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再加上本身就是k的子数组的数量</span></span><br><span class="line">        <span class="keyword">if</span> (k - min &gt;= <span class="number">0</span> &amp;&amp; k - min &lt; sums.length) &#123;</span><br><span class="line">            count += sums[k - min];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提交OK，执行时间上更快了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题主要是找规律，优化的时候可以利用哈希表和数组的特性。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要是找规律，优化的时候可以利用哈希表和数组的特性。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="找规律" scheme="https://www.death00.top/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>力扣494——目标和</title>
    <link href="https://www.death00.top/2020/02/18/%E5%8A%9B%E6%89%A3494%E2%80%94%E2%80%94%E7%9B%AE%E6%A0%87%E5%92%8C/"/>
    <id>https://www.death00.top/2020/02/18/力扣494——目标和/</id>
    <published>2020-02-18T02:00:00.000Z</published>
    <updated>2020-02-22T03:37:45.466Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要是利用动态规划进行求解，优化的时候可以找规律，转化成正常的背包问题。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p><p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入: nums: [1, 1, 1, 1, 1], S: 3</span><br><span class="line">输出: 5</span><br><span class="line">解释: </span><br><span class="line"></span><br><span class="line">-1+1+1+1+1 = 3</span><br><span class="line">+1-1+1+1+1 = 3</span><br><span class="line">+1+1-1+1+1 = 3</span><br><span class="line">+1+1+1-1+1 = 3</span><br><span class="line">+1+1+1+1-1 = 3</span><br><span class="line"></span><br><span class="line">一共有5种方法让最终目标和为3。</span><br></pre></td></tr></table></figure></p><p>注意:</p><ol><li>数组非空，且长度不会超过20。</li><li>初始的数组的和不会超过1000。</li><li>保证返回的最终结果能被32位整数存下。</li></ol><p>原题url：<a href="https://leetcode-cn.com/problems/target-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/target-sum/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="简单递归"><a href="#简单递归" class="headerlink" title="简单递归"></a>简单递归</h3><p>最简单的方法就是计算出所有的可能性，如果最终结果等于目标值，则说明该情况可以。直接看一下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        findTargetSumWays(nums, S, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 返回最终结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// index : 当前计算到数组中的位置</span></span><br><span class="line">    <span class="comment">// sum : 当前的总和</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S, <span class="keyword">int</span> index, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历是否结束</span></span><br><span class="line">        <span class="keyword">if</span> (index == nums.length) &#123;</span><br><span class="line">            <span class="comment">// 如果总和等于S，则最终结果+1</span></span><br><span class="line">            <span class="keyword">if</span> (sum == S) &#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 针对当前的数值，有加和减两种情况</span></span><br><span class="line">        findTargetSumWays(nums, S, index + <span class="number">1</span>, sum + nums[index]);</span><br><span class="line">        findTargetSumWays(nums, S, index + <span class="number">1</span>, sum - nums[index]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法很简单，但是时间复杂度太高，<code>O(2^n)</code>，执行用时在 java 中也只打败了<code>31.65%</code>，看来确实不够好。</p><h3 id="简单的动态规划"><a href="#简单的动态规划" class="headerlink" title="简单的动态规划"></a>简单的动态规划</h3><p>这其实类似于<code>背包问题</code>，有容量要求（部分数字之和等于目标值）。首先我们来想一下状态转移方程：</p><p>我们用二维数组<code>dp[i][j]</code>表示用数组中的前<code>i</code>个元素，组成和为<code>j</code>的方案数。考虑第<code>i</code>个数<code>nums[i]</code>，它可以被添加 + 或 -，因此状态转移方程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = dp[i - 1][j - nums[i]] + dp[i - 1][j + nums[i]]</span><br></pre></td></tr></table></figure></p><p>也可以写成递推的形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j + nums[i]] += dp[i - 1][j]</span><br><span class="line">dp[i][j - nums[i]] += dp[i - 1][j]</span><br></pre></td></tr></table></figure></p><p>因为题目中提到所有数的和不超过 1000，那么 j 的最小值可以达到 -1000。在 java 中，是不允许数组的下标为负数的，因此我们需要给<code>dp[i][j]</code>的第二维预先增加 1000，那么新的递推关系如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j + nums[i] + 1000] += dp[i - 1][j + 1000]</span><br><span class="line">dp[i][j - nums[i] + 1000] += dp[i - 1][j + 1000]</span><br></pre></td></tr></table></figure></p><p>接下来我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (S &gt; <span class="number">1000</span> || S &lt; -<span class="number">1000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求和的最大值</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1000</span>;</span><br><span class="line">        <span class="comment">// 初始的数组的和不会超过1000，因此最大为1000，最小为-1000</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length][max * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 针对nums[0]，先求出第一步</span></span><br><span class="line">        dp[<span class="number">0</span>][nums[<span class="number">0</span>] + max] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">0</span>][-nums[<span class="number">0</span>] + max] += <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> sum = -max; sum &lt;= max; sum++) &#123;</span><br><span class="line">                <span class="comment">// 如果上一步有求出和为sum，那么可以继续计算下一步</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i - <span class="number">1</span>][sum + max] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][nums[i] + sum + max] += dp[i - <span class="number">1</span>][sum + max];</span><br><span class="line">                    dp[i][-nums[i] + sum + max] += dp[i - <span class="number">1</span>][sum + max];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[nums.length - <span class="number">1</span>][S + max];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，时间复杂度为<code>O(N ∗ max)</code>，max 代表数组中所有数字之和的最大值，执行用时在 java 中打败了<code>58.91%</code>，看来还有很大的提升空间。</p><h3 id="动态规划-找规律"><a href="#动态规划-找规律" class="headerlink" title="动态规划 + 找规律"></a>动态规划 + 找规律</h3><p>我们想一下，之所以上面的方法会涉及到 max，因为所谓的<code>求和</code>，并不只是加法，也可以用减法。这和我们一般理解的<code>背包问题</code>还是有所不同的，那么我们是否可以将本题转换成真正意义上的<code>背包问题</code>呢？</p><p>首先，我们可以将这组数看成两部分，P 和 N，其中 P 使用正号，N 使用负号，那么可以推导出一下关系：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、target = sum(P) - sum(N)</span><br><span class="line">2、sum(nums) = sum(P) + sum(N)</span><br><span class="line">由1可以得出：sum(P) = target + sum(N)</span><br><span class="line">由2可以得出：sum(N) = sum(nums) - sum(P)</span><br><span class="line">综合以上，可以得出：</span><br><span class="line">sum(P) = (target + sum(nums)) / 2</span><br></pre></td></tr></table></figure></p><p>因此只要找到一个子集，令它们都取正号，并且和等于 (target + sum(nums))/2，就证明存在解，这就属于正常的<code>0-1背包问题</code>的范畴了。需要注意<code>target + sum(nums)</code>必须为偶数，否则 sum(P) 就是小数了，这和题目要求的所有数都是<code>非负整数</code>不符。</p><p>接下来我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (S &gt; <span class="number">1000</span> || S &lt; -<span class="number">1000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求出数组的和</span></span><br><span class="line">        <span class="keyword">int</span> sumNums = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sumNums += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新的目标和(sumNums + S) / 2</span></span><br><span class="line">        <span class="keyword">int</span> newTarget = sumNums + S;</span><br><span class="line">        <span class="comment">// 如果是奇数，那么无法被2整除，不符合规则</span></span><br><span class="line">        <span class="keyword">if</span> ((newTarget &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        newTarget = newTarget / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 正常的背包问题，在nums中找几个数，满足和为newTarget</span></span><br><span class="line">        <span class="comment">// dp[i]表示从数组nums找出和为i的组合情况</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[newTarget + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="comment">// 更新dp</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> sum = newTarget; sum &gt;= num; sum--) &#123;</span><br><span class="line">                dp[sum] += dp[sum - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[newTarget];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><pre><code>提交OK，时间复杂度是`O(n * newTarget)`，其中，` newTarget = (target + sum(nums))/2`，和前面方法中的`max`相比，`sum(nums) &lt;= max`，如果`target &gt; max`，也会直接返回0，因此这个方法的时间复杂度更优。## 总结</code></pre><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题主要是利用<code>动态规划</code>，优化时可以<code>找规律</code>，转化成正常的<code>背包问题</code>。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要是利用动态规划进行求解，优化的时候可以找规律，转化成正常的背包问题。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="动态规划" scheme="https://www.death00.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>力扣438——找到字符串中所有字母异位词</title>
    <link href="https://www.death00.top/2020/02/11/%E5%8A%9B%E6%89%A3438%E2%80%94%E2%80%94%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"/>
    <id>https://www.death00.top/2020/02/11/力扣438——找到字符串中所有字母异位词/</id>
    <published>2020-02-11T02:00:00.000Z</published>
    <updated>2020-02-11T07:33:34.659Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要是利用”窗口”这一概念，优化的时候可以利用题目本身的特殊性。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。</p><p>字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。</p><p>说明：</p><ul><li>字母异位词指字母相同，但排列不同的字符串。</li><li>不考虑答案输出的顺序。</li></ul><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s: &quot;cbaebabacd&quot; p: &quot;abc&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[0, 6]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的字母异位词。</span><br><span class="line">起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的字母异位词。</span><br></pre></td></tr></table></figure></p><p> 示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s: &quot;abab&quot; p: &quot;ab&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[0, 1, 2]</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的字母异位词。</span><br><span class="line">起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的字母异位词。</span><br><span class="line">起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的字母异位词。</span><br></pre></td></tr></table></figure></p><p>原题url：<a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="利用”窗口”思想"><a href="#利用”窗口”思想" class="headerlink" title="利用”窗口”思想"></a>利用”窗口”思想</h3><p>这道题类似<code>字符串完全匹配</code>，只是这道题要求连续但顺序可以不一致。这样就无法利用<code>待匹配字符串</code>预先构造了。</p><p>那么结合这道题，为了能够让我们知道当前字符是否在<code>待匹配字符串</code>中，我们需要一个<code>集合</code>存储。</p><p>为了能够让我们知道各个字符出现了几次，我们需要一个<code>哈希表</code>，并且实时更新其次数，如果次数为0，则移除该项，如果<code>哈希表</code>为空，则说明找到了，记录开始下标，并且<code>窗口滑动</code>。</p><p>结合上面的思路，我们可以写出代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 最终结果</span></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据p构造map，key代表字符，value代表相应次数</span></span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Character character : p.toCharArray()) &#123;</span><br><span class="line">            map.put(character, map.getOrDefault(character, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p中所有的字符</span></span><br><span class="line">        Set&lt;Character&gt; pCharSet = <span class="keyword">new</span> HashSet&lt;&gt;(map.keySet());</span><br><span class="line">        <span class="comment">// 每个字母出现的位置，value表示每一次出现的下标</span></span><br><span class="line">        Map&lt;Character, LinkedList&lt;Integer&gt;&gt; indexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 开始的下标</span></span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] sArray = s.toCharArray();</span><br><span class="line">        <span class="comment">// 遍历s</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sArray.length; i++) &#123;</span><br><span class="line">            Character character = sArray[i];</span><br><span class="line">            <span class="comment">// 如果character不在pCharSet中，说明该字符不存在</span></span><br><span class="line">            <span class="keyword">if</span> (!pCharSet.contains(character)) &#123;</span><br><span class="line">                <span class="comment">// 则重新构造indexMap</span></span><br><span class="line">                indexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                <span class="comment">// 从first位置到i位置，还原map</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = first; j &lt; i; j++) &#123;</span><br><span class="line">                    character = sArray[j];</span><br><span class="line">                    map.put(character, map.getOrDefault(character, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 重置first的位置</span></span><br><span class="line">                first = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从indexMap中获取该字符出现的位置</span></span><br><span class="line">            LinkedList&lt;Integer&gt; indexList = indexMap.computeIfAbsent(character, k -&gt; <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">            <span class="comment">// 在末尾记录当前位置</span></span><br><span class="line">            indexList.add(i);</span><br><span class="line">            <span class="comment">// map中相应字符剩余出现次数</span></span><br><span class="line">            Integer count = map.get(character);</span><br><span class="line">            <span class="comment">// 如果次数为null，说明无法再减</span></span><br><span class="line">            <span class="keyword">if</span> (count == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 从开始下标到该字符第一次出现的下标，还原map和indexMap</span></span><br><span class="line">                <span class="keyword">int</span> firstIndex = indexList.removeFirst();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = first; j &lt; firstIndex; j++) &#123;</span><br><span class="line">                    character = sArray[j];</span><br><span class="line">                    map.put(character, map.getOrDefault(character, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                    indexMap.get(character).removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 重置first的位置</span></span><br><span class="line">                first = firstIndex + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 次数-1</span></span><br><span class="line">            count--;</span><br><span class="line">            <span class="comment">// 如果次数不为0，则重新放进map中</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                map.put(character, count);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果次数减为0，则移除该项</span></span><br><span class="line">            map.remove(character);</span><br><span class="line">            <span class="comment">// 检查map是否为空</span></span><br><span class="line">            <span class="keyword">if</span> (!map.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果为空，说明满足条件，记录进result中</span></span><br><span class="line">            result.add(first);</span><br><span class="line">            <span class="comment">// first向后移动1个（窗口滑动）</span></span><br><span class="line">            character = sArray[first];</span><br><span class="line">            map.put(character, map.getOrDefault(character, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            indexMap.get(character).removeFirst();</span><br><span class="line">            first++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，但执行用时很慢，需要优化。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>上面解法查询慢，我感觉根本原因在于使用了比较复杂的数据结构，包括集合、哈希表、链表等，虽然 Java 中针对这些结构做了优化，但相比于最基础的结构<code>数组</code>而言，在查找和更新上还是更慢了。这道题可以用数组的主要原因在于只会出现26个小写英文字母。这样用了数组之后，查找和更新都快了太多。大家可以根据这个思路优化试试。</p><p>既然有提到<code>窗口</code>，那么我们就将这个思想用到极致。可以先将窗口设置的大一些，比如至少包含目标字符串里的所有字符。达成条件后，就开始把左边开始缩小，直到缩小成目标字符串的长度后，然后记录进结果中，之后窗口右移，重复上述过程。</p><p>接下来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findAnagrams</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 需要的字符，由于都是小写字母，因此直接用26个长度的数组代替原来的HashMap</span></span><br><span class="line">        <span class="keyword">int</span>[] needs = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch : p.toCharArray()) &#123;</span><br><span class="line">            needs[ch - <span class="string">'a'</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// "窗口"</span></span><br><span class="line">        <span class="keyword">int</span>[] window = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="comment">// 窗口的左右下标</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 用total检测窗口中是否已经涵盖了p中的所有字符</span></span><br><span class="line">        <span class="keyword">int</span> total = p.length();</span><br><span class="line">        <span class="comment">// 遍历s</span></span><br><span class="line">        <span class="keyword">while</span>(right &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> chr = s.charAt(right);</span><br><span class="line">            <span class="comment">// 如果该字符在p中出现过</span></span><br><span class="line">            <span class="keyword">if</span>(needs[chr - <span class="string">'a'</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 则在窗口中记下该字符</span></span><br><span class="line">                window[chr - <span class="string">'a'</span>] ++;</span><br><span class="line">                <span class="comment">// 如果当前窗口中该字符的数量，小于需要的数量</span></span><br><span class="line">                <span class="keyword">if</span>(window[chr - <span class="string">'a'</span>] &lt;= needs[chr - <span class="string">'a'</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 则total数量减1</span></span><br><span class="line">                    total --;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// total为0，说明窗口中包含了p中所有字符</span></span><br><span class="line">            <span class="keyword">while</span>(total == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// (right - left + 1)代表窗口的大小</span></span><br><span class="line">                <span class="comment">// 如果窗口的大小等于p，说明符合要求</span></span><br><span class="line">                <span class="keyword">if</span>(right - left + <span class="number">1</span> == p.length())&#123;</span><br><span class="line">                    <span class="comment">// 记录左指针</span></span><br><span class="line">                    res.add(left);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">// 左指针向右移动1个</span></span><br><span class="line">                <span class="keyword">char</span> chl = s.charAt(left);</span><br><span class="line">                left ++;</span><br><span class="line">                <span class="comment">// 如果左指针属于p中</span></span><br><span class="line">                <span class="keyword">if</span>(needs[chl - <span class="string">'a'</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 那么窗口中该字符的数量也需要减1</span></span><br><span class="line">                    window[chl - <span class="string">'a'</span>] --;</span><br><span class="line">                    <span class="comment">// 如果窗口中该字符的数量小于需要的数量</span></span><br><span class="line">                    <span class="keyword">if</span>(window[chl - <span class="string">'a'</span>] &lt; needs[chl - <span class="string">'a'</span>]) &#123;</span><br><span class="line">                        <span class="comment">// 则total加1，跳出循环，说明还需要继续向右寻找</span></span><br><span class="line">                        total ++;</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 继续向右寻找</span></span><br><span class="line">            right ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，执行时间加快了一个量级。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题主要是利用”窗口”这一概念，优化的时候可以利用题目本身的特殊性。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要是利用”窗口”这一概念，优化的时候可以利用题目本身的特殊性。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="窗口滑动" scheme="https://www.death00.top/tags/%E7%AA%97%E5%8F%A3%E6%BB%91%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>力扣416——分割等和子集</title>
    <link href="https://www.death00.top/2020/02/04/%E5%8A%9B%E6%89%A3416%E2%80%94%E2%80%94%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/"/>
    <id>https://www.death00.top/2020/02/04/力扣416——分割等和子集/</id>
    <published>2020-02-04T02:00:00.000Z</published>
    <updated>2020-02-04T13:56:20.608Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要涉及的是动态规划，类似背包问题，主要还是需要找出状态转移方程，优化时可以考虑采用深度优先搜索。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>注意:</p><ol><li>每个数组中的元素不会超过 100</li><li>数组的大小不会超过 200</li></ol><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 5, 11, 5]</span><br><span class="line"></span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">解释: 数组可以分割成 [1, 5, 5] 和 [11].</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 2, 3, 5]</span><br><span class="line"></span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">解释: 数组不能分割成两个元素和相等的子集.</span><br></pre></td></tr></table></figure></p><p>原题url：<a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/partition-equal-subset-sum/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>针对这种问题，动态规划是最直接的思路。针对每一个数字，你都有两个选择：选、不选。我们的目标是为了让选出来的数字之和等于所有数字之和的一半。</p><p>这和<code>0-1 背包问题</code>很类似，我们可以利用二维表格 dp 解决，表格有<code>len</code>行、<code>target+1</code>列，这里<code>len</code>表示当前数字所处的数组下标，<code>target</code>表示所有数字之和(最大值为：所有数字之和的一半)，<code>target+1</code>是表明数字之和从0开始。</p><p>接下来考虑<code>状态定义</code>和<code>状态转移方程</code>：</p><p>状态定义：<code>dp[i][j]</code>表示从原始数组的 [0, i] 这个子区间内挑选一些数，每个数只能用一次，使得这些数的和恰好等于 j。</p><p>状态转移方程：对于“0-1 背包问题”，就是考虑数字是否选择。</p><ol><li>不选择 nums[i]，如果在 [0, i - 1] 这个子区间内已经有一部分元素，使得它们的和为 j ，那么 dp[i][j] = true；</li><li>选择 nums[i]，如果在 [0, i - 1] 这个子区间内就得找到一部分元素，使得它们的和为 j - nums[i]，那么 dp[i][j] = true；</li><li>其余情况，dp[i][j] = false；</li></ol><p>所以状态转移方程是：<code>dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i]]</code></p><p>接下来我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="comment">// 求所有数字之和</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果总和是奇数，就无法计算</span></span><br><span class="line">        <span class="keyword">if</span> ((sum &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 目标值：总和的一半</span></span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 创建二维状态数组，行：物品索引，列：容量（包括 0）</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][target + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先填表格第 0 行，第 1 个数只能让容积为它自己的背包恰好装满</span></span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= target) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][nums[<span class="number">0</span>]] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再填表格后面几行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= target; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果之前已经有总和为 j 的情况(这样不需要nums[i])，说明可以满足</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j] ||</span><br><span class="line">                    <span class="comment">// 如果当前的数字nums[i]刚好为j，说明可以满足</span></span><br><span class="line">                    nums[i] == j ||</span><br><span class="line">                    <span class="comment">// 如果当前的数字nums[i]小于j，并且之前就有总和为(j - nums[i])的情况(这样加上nums[i]刚好满足j)</span></span><br><span class="line">                    (nums[i] &lt; j &amp;&amp; dp[i - <span class="number">1</span>][j - nums[i]])) &#123;</span><br><span class="line">                    dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">1</span>][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK。</p><h3 id="动态规划——优化"><a href="#动态规划——优化" class="headerlink" title="动态规划——优化"></a>动态规划——优化</h3><p>时间上的优化，其实可以提前结束，只要满足 target，就满足了总和一半的条件，可以直接结束，并不需要全部算完。</p><p>空间上的优化，其实只需要一维即可，因为只用了上一次的所有情况，并不需要所有。</p><p>接下来我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">        <span class="comment">// 求所有数字之和</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果总和是奇数，就无法计算</span></span><br><span class="line">        <span class="keyword">if</span> ((sum &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 目标值：总和的一半</span></span><br><span class="line">        <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 创建一维数组</span></span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[target + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 记录第一个数字的情况</span></span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= target) &#123;</span><br><span class="line">            dp[nums[<span class="number">0</span>]] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再填表格</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = target; nums[i] &lt;= j; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[target]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                dp[j] = dp[j] || dp[j - nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK。</p><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>和动态规划类似，只是换成了递归的写法。</p><p>针对一个数字选还是不选的问题，要求选择的数字之和达到一半，等价于不选择的数字之和也达到了一半。</p><p>只是针对<code>剪枝</code>，需要提供更多一些的情况：可以先从小到大排序，然后从大的一方开始找，这样可以快速失败，因为当超过一半之后，可以直接结束。</p><p>接下来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 求和</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是奇数，说明不可平分</span></span><br><span class="line">        <span class="keyword">if</span> ((sum &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求出一半应该是多少</span></span><br><span class="line">        sum = sum &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从小到大排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">// 从后向前添加</span></span><br><span class="line">        <span class="keyword">return</span> canPartition(nums, nums.length - <span class="number">1</span>, sum, sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span>[] nums,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> index,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> canIncrease,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> canDecrease)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果可以增加或者可以减少的量为0，说明已经达到一半，成功</span></span><br><span class="line">        <span class="keyword">if</span> (canIncrease == <span class="number">0</span> || canDecrease == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果可以增加或者可以减少的量为0，说明已经超过一半，失败</span></span><br><span class="line">        <span class="keyword">if</span> (canIncrease &lt; <span class="number">0</span> || canDecrease &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续下一个，如果已经遍历完，则失败</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加当前元素或者放弃当前元素</span></span><br><span class="line">        <span class="keyword">return</span> canPartition(nums, index - <span class="number">1</span>, canIncrease - nums[index], canDecrease) ||</span><br><span class="line">            canPartition(nums, index - <span class="number">1</span>, canIncrease, canDecrease - nums[index]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，从时间上来看，比之前的动态规划更快。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题主要涉及的是动态规划，类似背包问题，主要还是需要找出状态转移方程，优化时可以考虑采用深度优先搜索。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要涉及的是动态规划，类似背包问题，主要还是需要找出状态转移方程，优化时可以考虑采用深度优先搜索。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="深度优先搜索" scheme="https://www.death00.top/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
      <category term="动态规划" scheme="https://www.death00.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>力扣406——根据身高重建队列</title>
    <link href="https://www.death00.top/2020/02/03/%E5%8A%9B%E6%89%A3406%E2%80%94%E2%80%94%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/"/>
    <id>https://www.death00.top/2020/02/03/力扣406——根据身高重建队列/</id>
    <published>2020-02-03T02:00:00.000Z</published>
    <updated>2020-02-03T12:24:20.019Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要涉及的是找规律和快速排序，优化时需要考虑 Java 中数据结构的特性。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。</p><p>注意：</p><p>总人数少于1100人。</p><p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</span><br></pre></td></tr></table></figure></p><p>原题url：<a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/queue-reconstruction-by-height/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="两次快速排序"><a href="#两次快速排序" class="headerlink" title="两次快速排序"></a>两次快速排序</h3><p>拿到这道题目，先想想规律。关注的重点应该在于这句话：<code>k是排在这个人前面且身高大于或等于h的人数</code>。</p><p>所以一般肯定是 h 大的在前面，但也需要考虑 k，当 h 相同时，肯定是 k 越小，越在前面。</p><p>这样也就涉及到了排序，排序中时间复杂度低的也就是<code>快速排序</code>和<code>归并排序</code>。本题并不需要考虑<code>稳定性</code>，因为原始的数组并没有规律，且并没有涉及原始数组的顺序，所以两种排序用哪个都可以。但考虑到快速排序写起来更简单，因此就采用它。</p><p>我的思路是：</p><ul><li>先针对 h ，如果 h 越大，则越靠前(也就是降序)，做一次快速排序。</li><li>如果 h 相同时，再针对 k，如果 k 越小，则越靠前(也就是升序)，再做一次快速排序。</li><li>利用自定义的 TreeNode 结构，也就是单向链表，根据 k 进行插入。</li><li>遍历单向链表，输出最终结果</li></ul><p>接下来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] reconstructQueue(<span class="keyword">int</span>[][] people) &#123;</span><br><span class="line">        <span class="keyword">if</span> (people.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> people;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用快排，针对people进行排序</span></span><br><span class="line">        <span class="comment">// h越大，越靠前，降序</span></span><br><span class="line">        binarySort(people, <span class="number">0</span>, people.length - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// h相等时，k越小越靠前，升序</span></span><br><span class="line">        sortByK(people);</span><br><span class="line">        <span class="comment">// 构造树</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode();</span><br><span class="line">        TreeNode temp = <span class="keyword">new</span> TreeNode();</span><br><span class="line">        temp.val = people[<span class="number">0</span>];</span><br><span class="line">        root.next = temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; people.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] person = people[i];</span><br><span class="line">            <span class="comment">// 根据k，往树中放</span></span><br><span class="line">            TreeNode preNode = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; person[<span class="number">1</span>]; j++) &#123;</span><br><span class="line">                preNode = preNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加节点</span></span><br><span class="line">            temp = <span class="keyword">new</span> TreeNode();</span><br><span class="line">            temp.val = person;</span><br><span class="line">            temp.next = preNode.next;</span><br><span class="line">            preNode.next = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终结果</span></span><br><span class="line">        <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[people.length][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        root = root.next;</span><br><span class="line">        <span class="comment">// 遍历并赋值</span></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode node = root;</span><br><span class="line">            result[index] = node.val;</span><br><span class="line">            root = root.next;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortByK</span><span class="params">(<span class="keyword">int</span>[][] people)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] prePeople = people[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 遍历，找出相等的结果</span></span><br><span class="line">        <span class="keyword">while</span> (end &lt; people.length) &#123;</span><br><span class="line">            <span class="comment">// 如果两者不等</span></span><br><span class="line">            <span class="keyword">if</span> (prePeople[<span class="number">0</span>] != people[end][<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (end - start &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                    binarySortByK(people, start, end - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                prePeople = people[end];</span><br><span class="line">                start = end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果两者相等，则什么都不需要改变</span></span><br><span class="line">            end++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end - start &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            binarySortByK(people, start, end - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binarySortByK</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span>[][] people,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> left,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 标准值(待比较)</span></span><br><span class="line">        <span class="keyword">int</span>[] standard = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        standard[<span class="number">0</span>] = people[left][<span class="number">0</span>];</span><br><span class="line">        standard[<span class="number">1</span>] = people[left][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 提前记录</span></span><br><span class="line">        <span class="keyword">int</span> low = left;</span><br><span class="line">        <span class="keyword">int</span> high = right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 先从right找起，因为left的值已经被重新存储，可以被替换</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; people[right][<span class="number">1</span>] &gt;= standard[<span class="number">1</span>]) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            people[left] = people[right];</span><br><span class="line">            <span class="comment">// 再替换right</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; people[left][<span class="number">1</span>] &lt; standard[<span class="number">1</span>]) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            people[right] = people[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终left和right必然相等</span></span><br><span class="line">        people[right] = standard;</span><br><span class="line">        <span class="comment">// 继续</span></span><br><span class="line">        binarySortByK(people, low, right - <span class="number">1</span>);</span><br><span class="line">        binarySortByK(people, right + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binarySort</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span>[][] people,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> left,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 标准值(待比较)</span></span><br><span class="line">        <span class="keyword">int</span>[] standard = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        standard[<span class="number">0</span>] = people[left][<span class="number">0</span>];</span><br><span class="line">        standard[<span class="number">1</span>] = people[left][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 提前记录</span></span><br><span class="line">        <span class="keyword">int</span> low = left;</span><br><span class="line">        <span class="keyword">int</span> high = right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 先从right找起，因为left的值已经被重新存储，可以被替换</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; people[right][<span class="number">0</span>] &lt; standard[<span class="number">0</span>]) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            people[left] = people[right];</span><br><span class="line">            <span class="comment">// 再替换right</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; people[left][<span class="number">0</span>] &gt;= standard[<span class="number">0</span>]) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            people[right] = people[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终left和right必然相等</span></span><br><span class="line">        people[right] = standard;</span><br><span class="line">        <span class="comment">// 继续</span></span><br><span class="line">        binarySort(people, low, right - <span class="number">1</span>);</span><br><span class="line">        binarySort(people, right + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] val;</span><br><span class="line">    TreeNode next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，但执行时间较长，我们再优化优化。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>首先，针对快速排序，是否可以只用一次？答案是肯定的，我们只需要将比较条件特殊处理即可，也就是将上面两次的排序判断条件合并。</p><p>其次，针对最终结果的输出，我之前考虑用单向链表，是因为相比于数组每次插入时需要复制，链表的插入比较简单，只需要将地址换掉即可。但链表在找元素过程中耗时较长，数组可以直接利用下标计算出目标位置，且 Java 中的 ArrayList 的 add(int index, E element)，其复制方法是 native 类型，因此效率较高。所以我将最终的结果放入 ArrayList 进行处理。</p><p>接下来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] reconstructQueue(<span class="keyword">int</span>[][] people) &#123;</span><br><span class="line">        <span class="keyword">if</span> (people.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> people;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用快排，针对people进行排序</span></span><br><span class="line">        binarySort(people, <span class="number">0</span>, people.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(people.length);</span><br><span class="line">        <span class="comment">// 根据k向ArrayList中添加元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] person : people) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = person[<span class="number">1</span>];</span><br><span class="line">            list.add(k, person);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 转化为数组</span></span><br><span class="line">        <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[people.length][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binarySort</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span>[][] people,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> left,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 标准值(待比较)</span></span><br><span class="line">        <span class="keyword">int</span>[] standard = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        standard[<span class="number">0</span>] = people[left][<span class="number">0</span>];</span><br><span class="line">        standard[<span class="number">1</span>] = people[left][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 提前记录</span></span><br><span class="line">        <span class="keyword">int</span> low = left;</span><br><span class="line">        <span class="keyword">int</span> high = right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 先从right找起，因为left的值已经被重新存储，可以被替换</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; !compare(people[right], standard)) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            people[left] = people[right];</span><br><span class="line">            <span class="comment">// 再替换right</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; compare(people[left], standard)) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            people[right] = people[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终left和right必然相等</span></span><br><span class="line">        people[right] = standard;</span><br><span class="line">        <span class="comment">// 继续</span></span><br><span class="line">        binarySort(people, low, right - <span class="number">1</span>);</span><br><span class="line">        binarySort(people, right + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] person1, <span class="keyword">int</span>[] person2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// h越大，越靠前，降序</span></span><br><span class="line">        <span class="keyword">int</span> height1 = person1[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> height2 = person2[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (height1 &gt; height2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (height1 &lt; height2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当h相等时，k越小越靠前，升序</span></span><br><span class="line">        <span class="keyword">int</span> k1 = person1[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> k2 = person2[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> k1 &lt; k2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，这样速度提升了至少一倍。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题主要涉及的是找规律和快速排序，优化时需要考虑 Java 中数据结构的特性。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要涉及的是找规律和快速排序，优化时需要考虑 Java 中数据结构的特性。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="找规律" scheme="https://www.death00.top/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"/>
    
      <category term="快速排序" scheme="https://www.death00.top/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>力扣399——除法求值</title>
    <link href="https://www.death00.top/2020/02/02/%E5%8A%9B%E6%89%A3399%E2%80%94%E2%80%94%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC/"/>
    <id>https://www.death00.top/2020/02/02/力扣399——除法求值/</id>
    <published>2020-02-02T02:00:00.000Z</published>
    <updated>2020-02-03T12:32:42.321Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要涉及的是对树的理解，相关的算法是BFS、DFS、并查集。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给出方程式 A / B = k, 其中 A 和 B 均为代表字符串的变量， k 是一个浮点型数字。根据已知方程式求解问题，并返回计算结果。如果结果不存在，则返回 -1.0。</p><p>示例 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定 a / b = 2.0, b / c = 3.0</span><br><span class="line">问题: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? </span><br><span class="line">返回 [6.0, 0.5, -1.0, 1.0, -1.0 ]</span><br><span class="line"></span><br><span class="line">输入为: vector&lt;pair&lt;string, string&gt;&gt; equations, vector&lt;double&gt; values, vector&lt;pair&lt;string, string&gt;&gt; queries(方程式，方程式结果，问题方程式)。</span><br><span class="line">其中 equations.size() == values.size()，即方程式的长度与方程式结果长度相等（程式与结果一一对应），并且结果值均为正数。以上为方程式的描述。</span><br><span class="line">返回vector&lt;double&gt;类型。</span><br></pre></td></tr></table></figure></p><p>基于上述例子，输入如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">equations(方程式) = [ [&quot;a&quot;, &quot;b&quot;], [&quot;b&quot;, &quot;c&quot;] ],</span><br><span class="line">values(方程式结果) = [2.0, 3.0],</span><br><span class="line">queries(问题方程式) = [ [&quot;a&quot;, &quot;c&quot;], [&quot;b&quot;, &quot;a&quot;], [&quot;a&quot;, &quot;e&quot;], [&quot;a&quot;, &quot;a&quot;], [&quot;x&quot;, &quot;x&quot;] ].</span><br></pre></td></tr></table></figure></p><p>输入总是有效的。你可以假设除法运算中不会出现除数为0的情况，且不存在任何矛盾的结果。</p><p>原题url：<a href="https://leetcode-cn.com/problems/evaluate-division/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/evaluate-division/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="BFS或DFS"><a href="#BFS或DFS" class="headerlink" title="BFS或DFS"></a>BFS或DFS</h3><p>一般而言，如果我们知道了<code>a/b</code>和<code>b/c</code>，求<code>a/c</code>的话，可以通过<code>a/b * b/c</code>求得结果。联想成树的话，也就是节点与节点之间是否相连。总的来说，我们需要进行关系的转换。</p><p>利用递归的话，可以很好写出代码，我提供一个 DFS 的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">        <span class="comment">// 记录出现了哪些字符串</span></span><br><span class="line">        Set&lt;String&gt; keySet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">// 记录等式关系，第一层key为除数，第二层key为被除数，第二层value为结果</span></span><br><span class="line">        Map&lt;String, Map&lt;String, Double&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 当前是第几个等式，也代表当前要去取第几个结果</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历等式</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; equation : equations) &#123;</span><br><span class="line">            <span class="comment">// 除数</span></span><br><span class="line">            String divisor = equation.get(<span class="number">0</span>);</span><br><span class="line">            keySet.add(divisor);</span><br><span class="line">            <span class="comment">// 被除数</span></span><br><span class="line">            String divided = equation.get(<span class="number">1</span>);</span><br><span class="line">            keySet.add(divided);</span><br><span class="line">            <span class="comment">// 结果</span></span><br><span class="line">            <span class="keyword">double</span> value = values[count];</span><br><span class="line">            <span class="comment">// 赋值</span></span><br><span class="line">            putValue(value, divisor, divided, map);</span><br><span class="line"></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算结果</span></span><br><span class="line">        <span class="keyword">double</span>[] result = <span class="keyword">new</span> <span class="keyword">double</span>[queries.size()];</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; query : queries) &#123;</span><br><span class="line">            <span class="comment">// 除数</span></span><br><span class="line">            String divisor = query.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 被除数</span></span><br><span class="line">            String divided = query.get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 求结果</span></span><br><span class="line">            result[count] = cal(divisor, divided, map, <span class="keyword">new</span> HashSet&lt;&gt;(), keySet);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cal</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String divisor, </span></span></span><br><span class="line"><span class="function"><span class="params">        String divided,</span></span></span><br><span class="line"><span class="function"><span class="params">        Map&lt;String, Map&lt;String, Double&gt;&gt; map,</span></span></span><br><span class="line"><span class="function"><span class="params">        Set&lt;String&gt; divisorSet,</span></span></span><br><span class="line"><span class="function"><span class="params">        Set&lt;String&gt; keySet)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 但凡除数、被除数有一个不存在，则直接返回-1.0</span></span><br><span class="line">        <span class="keyword">if</span> (!keySet.contains(divisor) || !keySet.contains(divided)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据除数，获取valueMap</span></span><br><span class="line">        Map&lt;String, Double&gt; valueMap = map.get(divisor);</span><br><span class="line">        <span class="comment">// 查找是否有现成结果</span></span><br><span class="line">        Double result = valueMap.get(divided);</span><br><span class="line">        <span class="comment">// 如果有就直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有就进行计算</span></span><br><span class="line">        <span class="keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">            Double value = valueMap.get(key);</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果为-1.0，说明无法计算</span></span><br><span class="line">            <span class="keyword">if</span> (value == -<span class="number">1.0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 原本是计算"divisor/divided"，现在可以尝试求出"divisor/key"和"key/divided"</span></span><br><span class="line">            <span class="comment">// 如果key的数据已经计算过，则不再重复计算</span></span><br><span class="line">            <span class="keyword">if</span> (divisorSet.contains(key)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            divisorSet.add(key);</span><br><span class="line">                        <span class="comment">// DFS</span></span><br><span class="line">            <span class="keyword">double</span> tempResult = cal(key, divided, map, divisorSet, keySet);</span><br><span class="line">            <span class="comment">// 记录中间结果</span></span><br><span class="line">            putValue(tempResult, key, divided, map);</span><br><span class="line">            <span class="comment">// 如果为-1.0，说明无法计算</span></span><br><span class="line">            <span class="keyword">if</span> (tempResult == -<span class="number">1.0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录最终结果</span></span><br><span class="line">            putValue(value * tempResult, divisor, divided, map);</span><br><span class="line">            <span class="comment">// 返回结果</span></span><br><span class="line">            <span class="keyword">return</span> value * tempResult;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 说明无法计算</span></span><br><span class="line">        putValue(-<span class="number">1.0</span>, divisor, divided, map);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putValue</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">double</span> value,</span></span></span><br><span class="line"><span class="function"><span class="params">        String divisor, </span></span></span><br><span class="line"><span class="function"><span class="params">        String divided,</span></span></span><br><span class="line"><span class="function"><span class="params">        Map&lt;String, Map&lt;String, Double&gt;&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据除数赋值</span></span><br><span class="line">        Map&lt;String, Double&gt; valueMap = map.get(divisor);</span><br><span class="line">        <span class="keyword">if</span> (valueMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">            valueMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            map.put(divisor, valueMap);</span><br><span class="line">            <span class="comment">// 记录"divisor/divisor = 1.0"</span></span><br><span class="line">            valueMap.put(divisor, <span class="number">1.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        valueMap.put(divided, value);</span><br><span class="line">        <span class="comment">// 根据被除数赋值</span></span><br><span class="line">        valueMap = map.get(divided);</span><br><span class="line">        <span class="keyword">if</span> (valueMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">            valueMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            map.put(divided, valueMap);</span><br><span class="line">            <span class="comment">// 记录"divided/divided = 1.0"</span></span><br><span class="line">            valueMap.put(divided, <span class="number">1.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        valueMap.put(divisor, <span class="number">1.0</span> / value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，大家可以尝试写一个 BFS(广度优先搜索) 的版本，需要借用队列记录中间遍历过的节点。</p><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>首先，我们需要了解什么是<code>并查集</code>，可以参考这一篇博客：<a href="https://www.cnblogs.com/noKing/p/8018609.html" target="_blank" rel="noopener">并查集(Java实现)</a></p><p>我的理解是：当我们知道了一堆元素里某几个之间的关联关系，可以将所有元素归并到一个集合中，这个集合中所有元素都是有关系的。</p><p>虽然并查集在构造时复杂，消耗一定的时间，但它可以提高了查找的效率。</p><p>针对这道题目，我们不仅需要记录 数字 与 数字 之间是否存在关联，还需要记录具体的<code>倍数</code>关系。其实你可以简单理解为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当我们知道了：</span><br><span class="line">a / b = 3</span><br><span class="line">b / d = 2</span><br><span class="line">c / d = 4</span><br><span class="line">我们可以将 d 看成是根节点，它有子节点 b、c，b有子节点 a</span><br></pre></td></tr></table></figure></p><p>这样是不是好理解多了。</p><p>我是利用一个 HashMap 存储了节点之间是否关联，用另一个 HashMap 存储了节点之间的<code>倍数</code>关系，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 并查集</span></span><br><span class="line"><span class="comment">     * key : 当前节点</span></span><br><span class="line"><span class="comment">     * value : 其父节点(也可以认为是大哥节点)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; parents = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 并查集</span></span><br><span class="line"><span class="comment">     * key : 当前节点</span></span><br><span class="line"><span class="comment">     * value : 父节点(也可以认为是大哥节点) /当前节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Double&gt; values = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 添加节点x</span></span><br><span class="line">        <span class="keyword">if</span> (!parents.containsKey(x)) &#123;</span><br><span class="line">            parents.put(x, x);</span><br><span class="line">            values.put(x, <span class="number">1.0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(String parent, String child, <span class="keyword">double</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 添加节点</span></span><br><span class="line">        add(parent);</span><br><span class="line">        add(child);</span><br><span class="line">        <span class="comment">// 找到parent和child的最终父节点</span></span><br><span class="line">        String p1 = find(parent);</span><br><span class="line">        String p2 = find(child);</span><br><span class="line">        <span class="comment">// 如果两个结果不等</span></span><br><span class="line">        <span class="keyword">if</span> (!p1.equals(p2)) &#123;</span><br><span class="line">            <span class="comment">// 记录p1、p2的关系</span></span><br><span class="line">            parents.put(p2, p1);</span><br><span class="line">            values.put(p2, value * (values.get(parent) / values.get(child)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找到x的最终父节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">find</span><span class="params">(String x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!parents.get(x).equals(x)) &#123;</span><br><span class="line">            x = parents.get(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一直计算到和根节点的关联</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">cal</span><span class="params">(String x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> v = values.get(x);</span><br><span class="line">        <span class="keyword">while</span> (!parents.get(x).equals(x)) &#123;</span><br><span class="line">            x = parents.get(x);</span><br><span class="line">            v *= values.get(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="keyword">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">        <span class="comment">// 构建并查集</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; equations.size(); i++) &#123;</span><br><span class="line">            union(equations.get(i).get(<span class="number">0</span>), equations.get(i).get(<span class="number">1</span>), values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最终的结果</span></span><br><span class="line">        <span class="keyword">double</span>[] answer = <span class="keyword">new</span> <span class="keyword">double</span>[queries.size()];</span><br><span class="line">        <span class="comment">// 计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queries.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 需要计算的两个数</span></span><br><span class="line">            String c1 = queries.get(i).get(<span class="number">0</span>);</span><br><span class="line">            String c2 = queries.get(i).get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 如果有一个是不存在的，则没有计算的必要</span></span><br><span class="line">            <span class="keyword">if</span> (!parents.containsKey(c1) || !parents.containsKey(c2)) &#123;</span><br><span class="line">                answer[i] = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果两者相等，则返回1</span></span><br><span class="line">            <span class="keyword">if</span> (c1.equals(c2)) &#123;</span><br><span class="line">                answer[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到两者的最终父节点，也就是各自的根节点​</span></span><br><span class="line">            String p1 = find(c1);</span><br><span class="line">            String p2 = find(c2);</span><br><span class="line">            <span class="comment">// 如果两者不等，说明两个节点无法构成关联</span></span><br><span class="line">            <span class="keyword">if</span> (!p1.equals(p2)) &#123;</span><br><span class="line">                answer[i] = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算两者的结果</span></span><br><span class="line">            answer[i] = cal(c2) / cal(c1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK，我的这个写法中，并查集是没有进行<code>路径压缩</code>的，有兴趣的同学可以在此之上进行优化，这样当 queries 越大时，查找的效率会越高。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题主要涉及的是对树的理解，相关的算法是BFS、DFS、并查集。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要涉及的是对树的理解，相关的算法是BFS、DFS、并查集。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="深度优先搜索" scheme="https://www.death00.top/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
      <category term="广度优先搜索" scheme="https://www.death00.top/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
      <category term="并查集" scheme="https://www.death00.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>力扣394——字符串解码</title>
    <link href="https://www.death00.top/2020/02/01/%E5%8A%9B%E6%89%A3394%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/"/>
    <id>https://www.death00.top/2020/02/01/力扣394——字符串解码/</id>
    <published>2020-02-01T02:00:00.000Z</published>
    <updated>2020-02-01T06:01:46.571Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要涉及的是对递归和栈的理解。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。</p><p>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;3[a]2[bc]&quot;, 返回 &quot;aaabcbc&quot;.</span><br><span class="line">s = &quot;3[a2[c]]&quot;, 返回 &quot;accaccacc&quot;.</span><br><span class="line">s = &quot;2[abc]3[cd]ef&quot;, 返回 &quot;abcabccdcdcdef&quot;.</span><br></pre></td></tr></table></figure></p><p>原题url：<a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/decode-string/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>这道题目，简单来看就是根据数字和内容，进行不断重复输出，最终得出结果。因此，递归也是最容易让人想到的。</p><p>数字代表内容需要重复的次数，<code>[</code>代表一次新的递归开始，<code>]</code>代表本次递归的结束，有点类似括号匹配这种问题。只是需要记录中间结果，以及最开始的<code>s</code>进过一次递归遍历后的下标位置。</p><p>基于上面的讲解，我们也就能够写出代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuilder resultSb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        dfs(s, <span class="number">0</span>, resultSb);</span><br><span class="line">        <span class="keyword">return</span> resultSb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(String s, <span class="keyword">int</span> index, StringBuilder resultSb)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 需要重复的次数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = s.charAt(index);</span><br><span class="line">            <span class="comment">// 如果是数字，则先累计进count中</span></span><br><span class="line">            <span class="keyword">if</span> (temp &gt;= <span class="string">'0'</span> &amp;&amp; temp &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">                count = count * <span class="number">10</span> + temp - <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遇到'['，则开始新一轮的递归</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">'['</span>) &#123;</span><br><span class="line">                StringBuilder tempResult = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                index = dfs(s, index + <span class="number">1</span>, tempResult);</span><br><span class="line">                <span class="comment">// 重复</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                    resultSb.append(tempResult);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// count进行重置</span></span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遇到']'，结束递归</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">']'</span>) &#123;</span><br><span class="line">                            <span class="comment">// 返回新的下标</span></span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遇到字母</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                resultSb.append(temp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK。</p><h3 id="利用栈"><a href="#利用栈" class="headerlink" title="利用栈"></a>利用栈</h3><p>既然有递归的写法，那么自然有不递归的写法，这就需要借助栈了。大家可以类比成计算一段普通的数学表达式，里面有括号、数字、符号运算等，所以需要两个栈，分别存储数字和运算符。</p><p>这道题目自然也是需要两个栈的，一个用来存储重复的次数，一个用来存储中间的字符串结果。判断出栈、入栈的依据，依据是<code>[]</code>，<code>[</code>代表数字和字符串都压入相应的栈，<code>]</code>代表需要将数字和字符串都需要从栈首压出，进行计算。</p><p>接下来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存放次数的栈</span></span><br><span class="line">        Stack&lt;Integer&gt; countStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 存放字符串的栈</span></span><br><span class="line">        Stack&lt;StringBuilder&gt; sbStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 临时存储字符串的内容</span></span><br><span class="line">        StringBuilder tempSb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// 临时存储数字的内容</span></span><br><span class="line">        <span class="keyword">int</span> tempCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> temp : s.toCharArray()) &#123;</span><br><span class="line">            <span class="comment">// 如果是数字，则先累计进tempCount中</span></span><br><span class="line">            <span class="keyword">if</span> (temp &gt;= <span class="string">'0'</span> &amp;&amp; temp &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">                tempCount = tempCount * <span class="number">10</span> + temp - <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遇到'['，将之前的数字和字符串放进countStack中</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">'['</span>) &#123;</span><br><span class="line">                countStack.push(tempCount);</span><br><span class="line">                tempCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                sbStack.push(tempSb);</span><br><span class="line">                tempSb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遇到']'，从countStack拿出数字</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">']'</span>) &#123;</span><br><span class="line">                <span class="comment">// 重复</span></span><br><span class="line">                StringBuilder tempResult = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                <span class="keyword">int</span> count = countStack.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">                    tempResult.append(tempSb);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 拿出sbStack第一个</span></span><br><span class="line">                StringBuilder sb = sbStack.pop();</span><br><span class="line">                tempSb = sb.append(tempResult);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遇到字母</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tempSb.append(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> tempSb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题主要涉及的是对递归和栈的理解，有点类似数学表达式的计算，只是做一下类比即可。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要涉及的是对递归和栈的理解。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
      <category term="栈" scheme="https://www.death00.top/tags/%E6%A0%88/"/>
    
      <category term="递归" scheme="https://www.death00.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>力扣347——前 K 个高频元素</title>
    <link href="https://www.death00.top/2020/01/31/%E5%8A%9B%E6%89%A3347%E2%80%94%E2%80%94%E5%89%8D%20K%20%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/"/>
    <id>https://www.death00.top/2020/01/31/力扣347——前 K 个高频元素/</id>
    <published>2020-01-31T02:00:00.000Z</published>
    <updated>2020-01-31T13:50:54.159Z</updated>
    
    <content type="html"><![CDATA[<p>这道题主要涉及的是对数据结构里哈希表、小顶堆的理解，优化时可以参考一些排序方法。<br><a id="more"></a></p><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p><p>示例 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">输出: [1,2]</span><br></pre></td></tr></table></figure></p><p>示例 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1], k = 1</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure></p><p>说明：</p><ul><li>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li><li>你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。</li></ul><p>原题url：<a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/top-k-frequent-elements/</a></p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><h3 id="正常思路"><a href="#正常思路" class="headerlink" title="正常思路"></a>正常思路</h3><p>为了解决这道题，我们首先需要知道每个元素出现的次数。最方便的话，可以使用哈希表，因为这就是一个<code>数字——出现次数</code>的映射关系。此处的时间复杂度为<code>O(n)</code></p><p>其次，因为需要查找频率前 k 高的元素，所以我们肯定是需要排序的，时间复杂度为<code>O(n log n)</code>的排序方法有许多，快速排序、堆排序等，我是用的堆排序，使用<code>小顶堆</code>，这样在每次入堆的时候，检查一下堆的个数是否超过 k，如果超过，则移除堆顶的元素(也就是次数最少的元素)。</p><p>这样堆里剩余的元素也就是最终的结果了，接下来我们看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构建hashMap，记录每个元素出现的个数</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; countMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            countMap.put(num, countMap.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用PriorityQueue构建小顶堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;((n1, n2) -&gt; countMap.get(n1) - countMap.get(n2));</span><br><span class="line">        Set&lt;Integer&gt; keySet = countMap.keySet();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> key : keySet) &#123;</span><br><span class="line">            heap.add(key);</span><br><span class="line">            <span class="comment">// 如果个数大于k，则移除次数最少的数</span></span><br><span class="line">            <span class="keyword">if</span> (heap.size() &gt; k) &#123;</span><br><span class="line">                heap.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = heap.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            result.add(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK。</p><h3 id="桶排序优化"><a href="#桶排序优化" class="headerlink" title="桶排序优化"></a>桶排序优化</h3><p>针对排序，我想到了一个优化，利用桶排序，其时间复杂度为<code>O(n)</code>，主要是浪费空间，因为需要申请额外的数组，下标代表出现的次数，元素我用的是 LinkedList，这样可以存储多个。那么这个在进行输出时，只要从后往前进行遍历，当结果的数量达到 k 时，就可以停止了。</p><p>接下来我们看看代码 ：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构建hashMap，记录每个元素出现的个数</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; countMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 记录最多的次数</span></span><br><span class="line">        <span class="keyword">int</span> maxCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = countMap.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; maxCount) &#123;</span><br><span class="line">                maxCount = count;</span><br><span class="line">            &#125;</span><br><span class="line">            countMap.put(num, count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 桶排序，构建数组，下标为重复的次数</span></span><br><span class="line">        LinkedList[] array = <span class="keyword">new</span> LinkedList[maxCount + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : countMap.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> key = entry.getKey();</span><br><span class="line">            <span class="keyword">int</span> count = entry.getValue();</span><br><span class="line">            LinkedList&lt;Integer&gt; list = array[count];</span><br><span class="line">            <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">                list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                array[count] = list;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 倒着遍历数组，直到找到K个元素</span></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = array.length - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; result.size() &lt; k; i--) &#123;</span><br><span class="line">            List&lt;Integer&gt; list = array[i];</span><br><span class="line">            <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result.addAll(list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交OK。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。这道题主要涉及的是对数据结构的理解，优化时可以参考一些特殊的排序方法。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p><a href="https://death00.github.io/" target="_blank" rel="noopener">https://death00.github.io/</a></p><p>公众号：健程之道</p><p><img src="https://imgkr.cn-bj.ufileos.com/01be7a29-45a6-4739-ae17-807c175741db.jfif" alt=""></p><p><img src="https://imgkr.cn-bj.ufileos.com/2984c6cb-07db-460e-aa3a-4dde4df2f4cc.jfif" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道题主要涉及的是对数据结构里哈希表、小顶堆的理解，优化时可以参考一些排序方法。&lt;br&gt;
    
    </summary>
    
      <category term="力扣" scheme="https://www.death00.top/categories/%E5%8A%9B%E6%89%A3/"/>
    
    
  </entry>
  
</feed>
